---
jupyter:
  jupytext:
    formats: ipynb,Rmd
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.2'
      jupytext_version: 1.3.2
  kernelspec:
    display_name: Python 3
    language: python
    name: python3
---

# Imports

Besides external libraries, we import several function from the local file : `utils.py`

```{python}
# %load_ext autoreload
# %autoreload 2
# %matplotlib inline
import pandas as pd
import time
import matplotlib.pyplot as plt
import numpy as np
import brightway2 as bw
import SALib
from sympy import *

# Custom utils defined for inter-acv
from utils import *

from IPython.core.display import display, HTML
display(HTML("<style>.container { width:70% !important; }</style>"))

pd.options.display.max_rows = 100
```

# Init brightway2 and databases

```{python}
# Setup bw2
bw.projects.set_current('acv-pv')
bw.bw2setup()

# Import Ecoinvent DB (if not already done)
# Update the PATH to suit your installation
#resetDb(ECOINVENT_DB_NAME)
importDb(ECOINVENT_DB_NAME, './ecoinvent 3.4_cutoff_ecoSpold02/datasets')

# We use a separate DB for defining our model, reset it beforehand
resetDb(ACV_DB_NAME)

# Parameters are stored at project level : reset them
resetParams()
```

# Select the impacts to consider

```{python}
# List of impacts to consider
impacts = [m for m in bw.methods if 'ILCD 1.0.8 2016' in str(m) and 'no LT' in str(m)]
```

# Electricity mix


```{python}
# Switch parameter for electricity mix
elec_switch = newEnumParam(
    'elec_switch', 
    values=["us", "eu", "row", "cn", "fr" ], 
    default=None, 
    description="Switch on electricty mix")
```

```{python}
ELEC_NAME = 'market for electricity, medium voltage'
ELEC_GROUP_NAME = 'market group for electricity, medium voltage'
elec_us = findTechAct(ELEC_GROUP_NAME, "US")
elec_eu = findTechAct(ELEC_GROUP_NAME, "ENTSO-E")
elec_fr = findTechAct(ELEC_NAME, "FR")
elec_cn = findTechAct(ELEC_NAME, "CN-CSG")
elec_row = findTechAct(ELEC_NAME, "RoW")
```

```{python}
# Virtual activity corresponding to switch upon elec mixes
elec = newSwitchAct("elec", elec_switch, {
    "us" : elec_us,
    "eu" : elec_eu,
    "fr" : elec_fr,
    "cn" : elec_cn,
    "row" : elec_row})
```

```{python}
multiLCA([elec_us, elec_eu, elec_row, elec_cn, elec_fr], impacts)
```

# Aluminium 

```{python}
alu=findTechAct('aluminium alloy production, AlMg3', 'RER')
alu_scrap=findTechAct('aluminium scrap, new, Recycled Content cut-off')
alu_cast_amount = alu.getAmount('aluminium, cast alloy')
```

```{python}
share_recycled_aluminium = newFloatParam(
    'share_recycled_aluminium',  
    default=0.27, min=0, max=1,
    unit="ratio",
    description="Share of reycled aluminium")
```

```{python}
alu_adjusted = copyActivity(alu, "Alu adjusted")

alu_adjusted.updateExchanges( 
    {"aluminium, cast alloy": alu_cast_amount * (1 - share_recycled_aluminium)}) 
alu_adjusted.addExchanges( 
    {alu_scrap : alu_cast_amount * share_recycled_aluminium} )

alu_adjusted.substituteWithDefault(
    'electricity, high voltage, aluminium industry', 
    elec, elec_switch)
```

```{python}
printAct(alu, alu_adjusted, share_recycled_aluminium=0.3, elec_switch=None)
multiLCA([alu, alu_adjusted], impacts, share_recycled_aluminium=0.3, elec_switch=None)
```

# Mounting system

```{python}
# 2 Mounting system are identified (Aluminium and stainless steel based)
ground_system = findTechAct('photovoltaic mounting system production, for 570kWp open ground module')
roof_system = findTechAct('photovoltaic mounting system production, for slanted-roof installation', 'RER')
```

```{python}
# Build a modified roof system with recycled output
roof_alu_amount = roof_system.getAmount('aluminium, wrought alloy')
roof_steel_amount = roof_system.getAmount('steel, low-alloyed, hot rolled')
scrap_steel_market = findTechAct('market for scrap steel', 'Europe without Switzerland')
scrap_alu_market= findTechAct('market for scrap aluminium', 'Europe without Switzerland')


roof_system_modified = copyActivity(roof_system, "Roof system recycled")

# Add scrap alu and steel output 
roof_system_modified.addExchanges({
    scrap_alu_market : - roof_alu_amount,
    scrap_steel_market : - roof_steel_amount})
```

```{python}
# Replace alu with recycled alu
ground_system_modified = copyActivity(ground_system, "Ground system modified")

roof_system_modified.updateExchanges(
    {'aluminium, wrought alloy' : dict(input=alu_adjusted)})
ground_system_modified.updateExchanges(
    {'aluminium, wrought alloy' : dict(input=alu_adjusted)})
```

```{python}
printAct(ground_system, ground_system_modified)
printAct(roof_system, roof_system_modified)
```

```{python}
multiLCA(
    [roof_system_modified, ground_system_modified], 
    impacts, 
    elec_switch=None, 
    share_recycled_aluminium=0.3)
```


# Electrical installation

```{python}
P = newFloatParam("P", 
    default=10, min=3, max=3000, 
    description="Power of the system", unit="kWc")

electrical_installation_3kW = findTechAct('photovoltaics, electric installation for 3kWp module, at building', 'RoW')

# 3kW system weights 33 kg, 570kW system weight 1570kg
# We compute a formula computing the number of unit of 3kw electrical installation for given power, based on weigth
unit_3kW_equiv = interpolate(P, 3, 570, 1, 1570/33)
```

# Inverter

```{python}
inverter_500kW = findTechAct('inverter production, 500kW', 'RER')
inverter_2500W = findTechAct('inverter production, 2.5kW', 'RER')
weigth_2500W = 18.5
weigth_500kW = 3000
printAct(inverter_500kW, inverter_2500W)
```

```{python}
# Generate a dataset for 1kG of inverter, based on the power
inverter_per_kg = newInterpolatedAct(
    "Inverter production, P kW per kg",
    inverter_2500W, 
    inverter_500kW,
    2.5, # FIXME : Wrong in original model should be 2.5 ?
    500,
    P,
    1 / weigth_2500W,
    1 / weigth_500kW, 
    unit="kilogram")
```

```{python}
# Add recycling 
recycling_rate = newFloatParam(
    "recycling_rate", 
    default=0.9, min=0.75, max=1, 
    description="Recycling rate for inverter", unit="ratio")

scrap_alu = findTechAct("market for scrap aluminium", "Europe without Switzerland")
scrap_steel = findTechAct("market for scrap steel", "Europe without Switzerland")
scrap_coper = findTechAct("market for scrap copper", "Europe without Switzerland")
scrap_electronic = findTechAct("market for electronics scrap")

amount_alu = inverter_per_kg.getAmount('aluminium, cast alloy')
amount_copper = inverter_per_kg.getAmount('copper')
amount_steel = inverter_per_kg.getAmount('steel, low-alloyed, hot rolled')
amount_electronic = inverter_per_kg.getAmount(
    ['capacitor*', 'diode*', 'integrated circuit*', 'printed wiring*', 'resistor*', 'transitor*'], 
    sum=True)

inverter_per_kg.addExchanges({
    scrap_alu : amount_alu * recycling_rate,
    scrap_coper : amount_copper * recycling_rate,
    scrap_electronic : amount_electronic * recycling_rate,
    scrap_steel : amount_steel * recycling_rate})
```

```{python}
printAct(inverter_per_kg, P=500, recycling_rate=0.3)
```

# Metalization paste

This section replaces all the silver used in the metallization paste by copper. However, the adequate replacement will be accomplished in the following sections according to the conductivity.


```{python}
# Find root activities
metal_paste = findTechAct("metallization paste production, back side", "RER")
copper = findTechAct('copper production, primary', "RoW")

# Copy and update mateal paste with copper
metal_paste_copper = copyActivity(metal_paste, 'metal paste, copper')
metal_paste_copper.updateExchanges({'silver' : dict(input=copper, name="copper")})
```

```{python}
printAct(metal_paste_copper)
```

# Silicon solar grade manufacturing

In this section, the main modification implemented is the change of the electrcity intensity used for the manufacturing of the solar grade.

```{python}
silicon_elec_intensity = newFloatParam(
    "silicon_elec_intensity", 
    default=40, min=20, max=200,  
    description="electricity used for solar processing and casting ", unit="kWh per kg")
```

```{python}
silicon = findTechAct('silicon production, solar grade, modified Siemens process', 'RER')
silicon_adjusted = copyActivity(silicon, "silicon production adjusted")

# Delete hydroelectricy, for not counting it twice
silicon_adjusted.updateExchanges(
    {
        'electricity, high voltage#RoW' : None,
        'electricity, high voltage#RER' : silicon_elec_intensity})
# Replace elec with elec switch, and update amount as a parameter
silicon_adjusted.substituteWithDefault('electricity, high voltage#RER', elec, elec_switch)
```

```{python}
printAct(silicon, silicon_adjusted, silicon_elec_intensity=40, elec_switch=None)
```

```{python}
multiLCAAlgebric([silicon, silicon_adjusted], impacts, elec_switch=None, silicon_elec_intensity=40)
```

# Casting Dataset 

Let's remove the use of silicon electronics grade (it was significant when the world silicon production was relatively low, nowadays this volume can be neglected compared to the level reached by the solar industry).
Let's remove also silicon solar grade as it is directly call by the wafer dataset and also electricity that is already accounted in the amount of electricity for solar grade manufacturing.
As a consequence, only chemicals, the factory and ceramic will be left and this dataset will complement the silicon solar grade dataset and both will be called for the wafer dataset.

```{python}
silicon_casting = findTechAct('silicon production, multi-Si, casted', 'RoW')

silicon_casting_adjusted = copyActivity(silicon_casting, 'silicon casting adjusted')

silicon_casting_adjusted.updateExchanges({
    'silicon,*' : None,
    'electricity, medium voltage*' : None})
```

```{python}
printAct(silicon_casting, silicon_casting_adjusted)
```

```{python}
multiLCAAlgebric([silicon_casting, silicon_casting_adjusted], impacts)
```

# Wafer manufacturing

In this section, some modifications were integrated by creating new datasets related mainly to the emerging practices in the cutting processes: 6 new datasets were created to serve this purpose.
On one hand, 2 of them (SiC recycled and TEG recycled) are related to the advancements of the traditional cutting process (loose abrasive slurry). The advancement of their recycling has resulted in the use of their recycled material recovered.
On another hand, the 4 new datasets are created to represent 1 meter of wire used in the emerging technology: the diamond wiring.


## Cutting Process

### SiC, Recycled

```{python}
silicon_carbide = findTechAct('silicon carbide production', 'RER')
silicon_carbide_recycled = copyActivity(silicon_carbide, 'silicon carbid adjusted', withExchanges=False)
silicon_carbide_recycled.addExchanges({
    findTechAct('market group for electricity, medium voltage', 'ENTSO-E') : 0.78571,
    findTechAct('market for transport, freight, lorry, unspecified', 'GLO') : 0.2625,
    findTechAct('market for silicone factory') : 1e-11,
    findBioAct('Heat, waste', categories=['air']) : 2.8286,
    findTechAct('market for waste, from silicon wafer production, inorganic') : -0.042857,
    findTechAct('treatment of spent antifreezer liquid, hazardous waste incineration', 'CH') : -0.071429,
    findTechAct('market for sludge, pig iron production', 'Europe without Switzerland') : -0.13571,
})
```

```{python}
printAct(silicon_carbide, silicon_carbide_recycled)
```

```{python}
multiLCAAlgebric([silicon_carbide, silicon_carbide_recycled], impacts)
```

### TEG, Recycled

FIXME : This model is wrong, it is a pure copy-paste of SiC recycled.

```{python}
teg = findTechAct(code='85c5a45f05a8e40c76aebf8a4dbdc3ad')
teg_recycled = copyActivity(teg, "TEG recycled", withExchanges=False)

teg_recycled.addExchanges({
    findTechAct('market group for electricity, medium voltage', 'ENTSO-E') : 0.78571,
    findTechAct('market for transport, freight, lorry, unspecified', 'GLO') : 0.2625,
    findTechAct('market for silicone factory') : 1e-11,
    findBioAct('Heat, waste', categories=['air']) : 2.8286,
    findTechAct('market for waste, from silicon wafer production, inorganic') : -0.042857,
    findTechAct('treatment of spent antifreezer liquid, hazardous waste incineration', 'CH') : -0.071429,
    findTechAct('market for sludge, pig iron production', 'Europe without Switzerland') : -0.13571,
})
```

```{python}
multiLCAAlgebric([teg, teg_recycled], impacts)
```

### Diamond Wiring

All the following datasets are based on Isabella Bianco thesis (2018) in which she analyzed the cutting processes in details. It was essential to integrate these datasets to elaborate the dataset of the wire which will be used for the cutting process according to the emerging diamond wiring technology.

#### Tungstene

```{python}
tungstene_carbide = copyActivity(silicon_carbide, "tungstene carbide", withExchanges=False)

tungstene_carbide.addExchanges({
    findTechAct('market for sodium hydroxide*') : 1.49,
    findTechAct('aluminium sulfate production, powder', 'RER') : 0.071,
    findTechAct('sodium sulfide production') : 0.044,
    findTechAct('magnesium sulfate production', 'RER') : 0.027,
    findTechAct('market for ammonia, liquid', 'RER') : 0.106,
    findTechAct('market for soda ash, dense') : 1.21,
    findTechAct('sulfuric acid production', 'RER') : 1.24,
    findTechAct('market group for electricity, medium voltage', 'ENTSO-E') : 111.16,
    findTechAct('hydrogen sulfide production', 'RER') : 0.0076,
    findTechAct('market for nitrogen, liquid', 'RER') : 1.65,
    findTechAct('market for hydrogen, liquid', 'RER') : 0.32,
    findTechAct('market for tap water', 'RoW') : 2.84,
    findTechAct('carbon black production') : 0.13,
})
    
```

```{python}
multiLCAAlgebric(tungstene_carbide, impacts)
```

```{python}
printAct(tungstene_carbide)
```

```{python}
multiLCAAlgebric(tungstene_carbide, impacts)
```

#### Diamond powder

```{python}
diamond_powder_ori = findTechAct('sodium percarbonate production, powder', 'RER')
diamond_powder = copyActivity(diamond_powder_ori, "Diamond powder",  withExchanges=False)
diamond_powder.addExchanges({
    findTechAct("market for electricity, medium voltage", "RoW") : 840,
    findTechAct("graphite production", "RER") : 1,
    findTechAct("transport, freight, sea, transoceanic ship") : 170,
    findTechAct("transport, freight, lorry 16-32 metric ton, EURO4", "RER") : 0.53,
})
```

```{python}
printAct(diamond_powder)
```

```{python}
multiLCAAlgebric(diamond_powder, impacts)
```

#### Sintered diamond bead

```{python}
sintered_diamond_ori = findTechAct("polymethyl methacrylate production, beads", "RER")

sintered_diamond = copyActivity(sintered_diamond_ori, "sintered diamond bead, for quarrying", withExchanges=False)
sintered_diamond.addExchanges({
    findTechAct("market group for electricity, medium voltage", "ENTSO-E") : 0.1,
    findTechAct("market for steel, unalloyed") : 0.003,
    findTechAct("market for cobalt") : 7e-08,
    findTechAct("market for copper") : 2.1e-07,
    findTechAct("market for pig iron") : 3.5e-07,
    findTechAct("market for nickel, 99.5%") : 2.1e-08,
    tungstene_carbide : 3.5e-08,
    diamond_powder : 2e-05,
    findTechAct('polymethyl methacrylate production, beads', "RER") :  2e-05,
    findTechAct("cobalt production") : 5e-05,
    findTechAct("market for silver") : 2.1e-04,
    findTechAct("market for nitrogen, liquid", "RER") : 0.0323, 
    findTechAct("market for hydrogen, liquid", "RER") : 9e-04, 
})

sintered_diamond.setOutputAmount(0.004)
```

```{python}
printAct(sintered_diamond)
```

```{python}
multiLCAAlgebric(sintered_diamond, impacts)
```

#### sintered diamond wire, steel

```{python}
act_ori = findTechAct('wire drawing, steel', 'RER')
sintered_diamond_wire = copyActivity(act_ori, "sintered diamond wire, steel", withExchanges=False)

sintered_diamond_wire.addExchanges({
    sintered_diamond : 0.0427,
    findTechAct("market group for electricity, medium voltage", "ENTSO-E") : 0.9, 
    findTechAct("wire drawing, steel", "RER") : 0.095, 
    findTechAct("wire drawing, steel", "RER") : 0.095, 
    findTechAct("polyurethane production, flexible foam", "RER") : 0.15, 
    findTechAct("transport, freight, lorry 16-32 metric ton, EURO4", "RER") : 0.003, 
    findTechAct("market for waste plastic, mixture", "Europe without Switzerland") : 0.045, 
})
```

```{python}
printAct(sintered_diamond_wire)
```

```{python}
multiLCAAlgebric(sintered_diamond_wire, impacts)
```

## Wafer 

This function generates an inventory of 1 m² of wafer production. 
    The initial amount of electricity (8 kWh/m²) is adjusted (to 20 kWh/m2 as per KBOB:2016) considering the possibility 
    to be improved (by using less) using manufacturing_efficiency_gains parameter (expressed in fraction/percentage).
    The electricity dataset can be also controlled using the elec_dataset parameter.
    The wafer solar grade used is the wafer solar grade adjusted (that considered the progress in solar grade wafer production),
    the amount of wafer is also adjusted considering the wafer thickness decreasing with the technical progress and evolution 
    of cutting processes with less kerf loss. manufacturing_efficiency_gains and kerf loss are expressed in fraction.
    wafer thickness is expressed in micrometer.
    SiC amount is adjusted from 2.63 kg (Ecoinvent 3.4) to 2.02988 kg (KBOB:2016) in total of which a certain amount (69.4%) 
    is produced from a recycled process with the possibility to modify it. SiC_recycled_share is the amount of recycled SiC
    expressed in fraction/percentage.
    TEG amount is adjusted from 2.71 kg (Ecoinvent 3.4) to 2.16548 kg (KBOB:2016) in total of which a certain amount (89.9%) 
    is produced from a recycled process with the possibility to modify it. TEG_recycled_share is the amount of recycled TEG
    expressed in fraction/percentage.
    Since the Diamond wiring technology is emerging, hence an added boolean parameter is added related to the added/omitted
    amount of SiC, TEG, diamond wire, and water.

```{python}
# Parameters
diamond_wiring = newBoolParam(
    "diamond_wiring", False, description="Diamond wiring") 

wafer_thickness = newFloatParam(
    "wafer_thickness", 
    default=200, min=128, max=300,
    description="Wafer thickness", unit="micrometer")

kerf_loss = newFloatParam(
    "kerf_loss", 0.44, min=0.20, max=0.50,
    description="Kerf loss", unit="fraction")

sic_recycled_share = newFloatParam(
    "sic_recycled_share", 
    0.694, min=0.528, max=1, 
    description="Silicon recycled share", 
    unit="fraction")

teg_recycled_share = newFloatParam(
    "teg_recycled_share", 
    0.899, min=0.528, max=1, 
    description="Recycled TEG", unit="fraction")

manufacturing_efficiency = newFloatParam(
    "manufacturing_efficiency", 
    0, min=0, max=1, 
    description="Manufacturing efficiency gain (elec for wafer)", unit="fraction")

# Root activities
natural_gas = findTechAct(in_name="heat production, natural gas, at industrial furnace >100kW", loc="Europe without Switzerland")

# Formulas 
sili_casting_amount = wafer_thickness * 1e-6 * 2328 / (1 - kerf_loss)
non_diamond_wiring = 1 - diamond_wiring


# Copy Wafer
wafer = findTechAct("multi-Si wafer production", "RER")
wafer_adjusted = copyActivity(wafer, "Wafer adjusted")

# Update wafer
wafer_adjusted.updateExchanges({
    'silicon, multi-Si, casted' : dict(
        input = silicon_adjusted, 
        amount = sili_casting_amount, 
        name='silicon production, adjusted'),  
    'tap water' : old_amount + diamond_wiring * 98.94,
    'silicon carbide' : non_diamond_wiring * 2.02988 * (1 - sic_recycled_share),
    'triethylene glycol' : non_diamond_wiring * 2.16548 * (1 - teg_recycled_share),
})

wafer_adjusted.addExchanges({
    # Diamond wiring (see also Tap water updated above)
    # sintered_diamond : diamond_wiring * 0.0006075,
    sintered_diamond_wire :  diamond_wiring * 0.0006075,
    
    # Non -diamond wiring
    silicon_carbide_recycled : non_diamond_wiring * 2.02988 * sic_recycled_share,
    teg_recycled : non_diamond_wiring * 2.16548 * teg_recycled_share,
    
    silicon_casting_adjusted : sili_casting_amount,
    
    # Adding the 4 MJ natural gas used for the wafer as proposed by KBOB
    natural_gas : 4 
})

# Adjusting the amount of electricity used
wafer_adjusted.substituteWithDefault(
    'electricity, medium voltage', 
    elec, elec_switch,
    amount=20 * (1 - manufacturing_efficiency))
```

```{python}
#printAct(wafer_adjusted, 
#         sic_recycled_share=0.4,
#        teg_recycled_share=0.3,
#        diamond_wiring=1,
#        manufacturing_efficiency=0.2,
#        kerf_loss=0.50,
#        wafer_thickness=240,
#        elec_switch=None,
#        silicon_elec_intensity=40)

printAct(wafer, wafer_adjusted, 
         sic_recycled_share=0,
        teg_recycled_share=0,
        diamond_wiring=1,
        manufacturing_efficiency=0,
        kerf_loss=0.50,
        wafer_thickness=240,
        elec_switch=None,
        silicon_elec_intensity=40)
```

```{python}
multiLCAAlgebric([wafer, wafer_adjusted, silicon_casting_adjusted, silicon_carbide_recycled, silicon_adjusted], 
        impacts, 
        sic_recycled_share=0,
        teg_recycled_share=0,
       diamond_wiring=1,
        manufacturing_efficiency=0,
        kerf_loss=0.50,
        wafer_thickness=240,
        elec_switch=None,
        silicon_elec_intensity=40)
```

```{python}
multiLCAAlgebric([wafer, wafer_adjusted], 
        impacts, 
        sic_recycled_share=0.694,
        teg_recycled_share=0.899,
        diamond_wiring=0,
        manufacturing_efficiency=0,
        kerf_loss=0.44,
        wafer_thickness=200,
        elec_switch=None,
        silicon_elec_intensity=40)
```

```{python}
printAct(wafer, wafer_adjusted,
         sic_recycled_share=0.694,
        teg_recycled_share=0.899,
        diamond_wiring=0,
        manufacturing_efficiency=0,
        kerf_loss=0.44,
        wafer_thickness=200,
        elec_switch=None,
        silicon_elec_intensity=40)
```

# PV Cell manufacturing

```{python}
# Params

silver_amount = newFloatParam(
    "silver_amount", 
    9.6, min=2, max=11, 
    description="Silver amount for PV cell", unit="g/m2")

cell_init = findTechAct('photovoltaic cell production, multi-Si wafer', 'RER')
cell_adjusted = copyActivity(cell_init, 'photovoltaic cell production, multi-Si wafer - adjusted')

#Adapting the amount of Silver used for the metallic contact
#By default, for the front side : 7.4 g/m² Silver based paste corresponding to 6.2 g/m² of Ag (84% Silver)
#By default, for the back side : 4.9 g/m² Silver based paste corresponding to 3.3 g/m² of Ag (67% Silver)
#An additional 0.7 g of Ag is used is anyway considered for the panel.
    
#Adding copper paste used to substitute the amount of Silver used.
#The amount of copper is calculated considering the difference of conductivity between Ag and Cu
#Conductiviy of Ag = 6.3e7 S/m, Cu = 5.96e7 S/m at 20°C

# FIXME removing Min/Max 
#front_silver_amount = Max(7.4e-3 * (silver_amount - 0.7)  / (6.2 + 3.3), zero)
front_silver_amount = 7.4e-3 * (silver_amount - 0.7)  / (6.2 + 3.3)
new_front_silver_amount = 0.84 * front_silver_amount

#back_silver_amount = Max(4.9e-3 * (silver_amount - 0.7)  / (6.2 + 3.3), zero)
back_silver_amount = 4.9e-3 * (silver_amount - 0.7)  / (6.2 + 3.3)
new_back_silver_amount = 0.67 * back_silver_amount

#copper_amount = Max(1/0.67 * 6.3e7 / 5.96e7 * ( 9.6e-3 -(new_front_silver_amount + new_back_silver_amount)), zero)
copper_amount=1/0.67 * 6.3e7 / 5.96e7 * ( 9.6e-3 -(new_front_silver_amount + new_back_silver_amount))
new_copper_amount = 0.67 * copper_amount


cell_adjusted.updateExchanges({
    'metallization paste, front side' : front_silver_amount,
    'metallization paste, back side': back_silver_amount,
    # 'metallization paste production, back side, copper' : copper_amount, # FIXME ! Was bugged in current model, not added at all
    'multi-Si wafer' : dict(input=wafer_adjusted)
})

cell_adjusted.substituteWithDefault(
    'electricity, medium voltage', 
    elec, elec_switch,
    amount=30.243 * (1 - manufacturing_efficiency))
```

```{python}
printAct(
    cell_adjusted, 
    sic_recycled_share=0,
    teg_recycled_share = 0,
    diamond_wiring = 1,
    manufacturing_efficiency = 0,
    kerf_loss = 0.5, 
    wafer_thickness = 240,
    silver_amount = 11.2,
    silicon_elec_intensity = 110+19.5,
    elec_switch = None)
```

```{python}
multiLCAAlgebric(
    [cell_init, cell_adjusted], 
    impacts,
    sic_recycled_share=0,
    teg_recycled_share = 0,
    diamond_wiring = 1,
    manufacturing_efficiency = 0,
    kerf_loss = 0.5, 
    wafer_thickness = 240,
    silver_amount = 11.2,
    silicon_elec_intensity = 110+19.5,
    elec_switch = None)
```

# PV Module 

```{python}
# Params 
recycling_rate_alu = newFloatParam(
    "recycling_rate_alu", 
    0.92, min=0.56, max=1, 
    description="Recycling rate for alu in panel", unit="fraction")

recycling_rate_cu = newFloatParam(
    "recycling_rate_cu", 
    0.75, min=0.44, max=1, 
    description="Recycling rate for copper in panel", unit="fraction")

recycling_rate_glass = newFloatParam(
    "recycling_rate_glass", 
    0.9, min=0.6, max=1, 
    description="Recycling rate for glass in panel", unit="fraction")

electricity_recycling = newFloatParam(
    "electricity_recycling", 
    50, min=50, max=100, 
    description="elec used for recycling", unit="kWh/ton")

heat_recycling = newFloatParam(
    "heat_recycling",
    76, min=75, max=150, 
    description="Heat for recycling", unit="MJ/ton")

glass_thickness = newFloatParam(
    "glass_thickness", 
    4, min=2, max=4,
description="Glass thickness", unit="mm") 

# Activities
scrapGlass = findTechAct('market for waste glass sheet', 'Europe without Switzerland')
scrapAlu = findTechAct('market for scrap alu*', 'Europe without Switzerland')
scrapCopper = findTechAct('market for scrap copper*', 'Europe without Switzerland')
heat_for_recycling = findTechAct('heat and power co-generation, biogas, gas engine', 'RoW', unit='megajoule')

# Base activity
module_init = findTechAct('photovoltaic panel production, multi-Si wafer', 'RER')

# Amount to recycle
amount_copper = new_copper_amount + module_init.getAmount('copper')
amount_glass = module_init.getAmount('solar glass, low-iron')
amount_alu =  cell_adjusted.getAmount('Aluminium') + module_init.getAmount('aluminium alloy, AlMg3')

# Copy / update activity
module = copyActivity(module_init, 'photovoltaic panel production, multi-Si wafer - adjusted')

module.addExchanges({
    scrapAlu : amount_alu * recycling_rate_alu,
    scrapCopper : amount_copper * recycling_rate_cu,
    scrapGlass : amount_glass * recycling_rate_glass,
    elec : dict(name='elec for recycling', amount = electricity_recycling * (20e-3/1.6)),
    heat_for_recycling : heat_recycling * (20e-3/1.6) / 3.6,
})

module.updateExchanges({
    'aluminium alloy, AlMg3' : alu_adjusted,
    'solar glass, low-iron' : glass_thickness * 2.5 * 1,
    'tempering, flat glass' : glass_thickness * 2.5 * 1,
    'photovoltaic cell, multi-Si wafer' : cell_adjusted,
})

module.substituteWithDefault('electricity, medium voltage', elec, elec_switch)

```

```{python}
multiLCAAlgebric(
    [module_init, module, alu_adjusted, wafer_adjusted], 
    impacts,
    sic_recycled_share=0,
    teg_recycled_share = 0,
    diamond_wiring = 1, 
    glass_thickness = 4, 
    elec_switch = None,
    manufacturing_efficiency = 0, 
    kerf_loss = 0.44 - 0.15,
    wafer_thickness = 200, 
    silver_amount = 9.6,
    silicon_elec_intensity = 40, 
    recycling_rate_alu = 0.96, 
    recycling_rate_cu = 0.75, 
    recycling_rate_glass = 0.9,
    electricity_recycling = 50, 
    heat_recycling = 76,
    share_recycled_aluminium=0.3)
```

```{python}
printAct(
    module_init, module, 
    sic_recycled_share=0,
    teg_recycled_share = 0,
    diamond_wiring = 1, 
    glass_thickness = 4, 
    elec_switch = None,
    manufacturing_efficiency = 0, 
    kerf_loss = 0.5,
    wafer_thickness = 240, 
    silver_amount = 11.2,
    silicon_elec_intensity = 40, 
    recycling_rate_alu = 0, 
    recycling_rate_cu = 0, 
    recycling_rate_glass = 0,
    electricity_recycling = 0, 
    heat_recycling = 0,
    share_recycled_aluminium=0.3)
```

```{python}
printAct(
    module_init,
    module,
    sic_recycled_share=0,
    teg_recycled_share = 0,
    diamond_wiring = 1, 
    glass_thickness = 4, 
    elec_switch = None,
    manufacturing_efficiency = 0, 
    kerf_loss = 0.5,
    wafer_thickness = 240, 
    silver_amount = 11.2,
    silicon_elec_intensity = 40, 
    recycling_rate_alu = 0, 
    recycling_rate_cu = 0, 
    recycling_rate_glass = 0,
    electricity_recycling = 0, 
    heat_recycling = 0,
    share_recycled_aluminium=0.3)

```

# Final model

```{python}
# Tech datasets
diesel = findTechAct('market for diesel, burned in building machine')

# Transport datasets
transport_car = findTechAct('transport, passenger car, large size, petrol, EURO 5', 'RER')
transport_van = findTechAct('transport, freight, light commercial vehicle', 'Europe without Switzerland')
transport_lorry = findTechAct('lorry, all sizes, EURO6*', 'RER')
transport_train = findTechAct('transport, freight train, electricity', 'RoW')
transport_sea = findTechAct('transport, freight, sea, transoceanic ship')
```

```{python}
# New params
module_efficiency =  newFloatParam(
    "module_efficiency", 
    default=0.2, min=0.15, max=0.22, 
    unit="kWc per m2")

is_roof_system = newBoolParam("is_roof_system", True, description="Is roof system")

pv_lifetime = newFloatParam(
    "pv_lifetime", 
    default=30, min=20, max=40, 
    unit="year")

inverter_lifetime = newFloatParam(
    "inverter_lifetime", 
    default=15, min=10, max=30,
    unit="year")

inverter_weight_per_p = newFloatParam(
    "inverter_weight_per_p", 
    default=2, min=1, max=6, 
    unit="kg per kWc",
    description="Inverter weight. Kg per kWc")

d_lorry = newFloatParam(
    "d_lorry", 
    default=1020, min=40, max=2000, 
    unit="km",
    description="Distance by lorry")

d_train = newFloatParam(
    "d_train", 
    default=350, min=0, max=600,
    unit="km",
    description="Distance by train")

d_sea = newFloatParam(
    "d_sea", 
    default=4000, min=0, max=6000,
    description="Distance by ships")

# Alias for ground system
is_ground_system = 1 - is_roof_system
```

```{python}
surface_module = 1.6 #Module surface in m²
P_module = module_efficiency * surface_module * 1000
surface  = P*1e3 / P_module * surface_module
```

```{python}
pvModel = newActivity("PV model", "unit")

inverter_weight = inverter_weight_per_p * P

# PV panel weigths 20kg 
total_mass_tons = 1e-3 * ((surface / surface_module) * 20 + unit_3kW_equiv * 33 + inverter_weight * pv_lifetime / inverter_lifetime)

pvModel.addExchanges({
    ground_system_modified : is_ground_system * surface,
    roof_system_modified : is_roof_system * surface,
    
    # Adding diesel burned in machine for site preparation
    # 7673 MJ were accounted for the 570 kWp power plant
    diesel : is_ground_system * P/570 * 7673, 
    
    # Number of equivalent unit of 3kW elec install
    electrical_installation_3kW : unit_3kW_equiv, 
    
    
    inverter_per_kg : inverter_weight * pv_lifetime / inverter_lifetime,
    module : surface,
    
    #for engineers for feasability study (100 - 200 km)
    transport_car : 150,
    
    #for maintenance
    transport_van : 1e-3 * (inverter_weight) * 100 * pv_lifetime / inverter_lifetime,
    
    transport_lorry : total_mass_tons * d_lorry,
    transport_sea : total_mass_tons * d_sea,
    transport_train : total_mass_tons * d_train
})
```

```{python}
printAct(pvModel, 
         P = 10, 
        module_efficiency = 0.125, 
        is_roof_system = 1,
        share_recycled_aluminium = 0.27, 
        elec_switch = None, 
        inverter_weight_per_p = 2,   
        inverter_lifetime = 15,
        pv_lifetime = 30,
        glass_thickness = 4,
        recycling_rate = 0,
        manufacturing_efficiency = 0,
        kerf_loss = 0.44, 
        wafer_thickness = 200, 
        silver_amount = 9.6, 
        silicon_elec_intensity = 30+10,
        sic_recycled_share=0.694, 
        teg_recycled_share = 0.899, 
        diamond_wiring=False, 
        d_lorry = 1020, 
        d_train = 350, 
        d_sea = 4000,
        recycling_rate_alu = 0.96, 
        recycling_rate_cu = 0.75,
        recycling_rate_glass = 0.9,
        electricity_recycling = 50,
        heat_recycling = 76)
```

```{python}
multiLCAAlgebric(
    #[pvModel, roof_system_modified, inverter_per_kg, module], 
    [pvModel, module, wafer_adjusted],
    impacts,
        P = 10, 
        module_efficiency = 0.125, 
        is_roof_system = 1,
        share_recycled_aluminium = 0.27, 
        elec_switch = None, 
        inverter_weight_per_p = 2,   
        inverter_lifetime = 15,
        pv_lifetime = 30,
        glass_thickness = 4,
        recycling_rate = 0,
        manufacturing_efficiency = 0,
        kerf_loss = 0.44, 
        wafer_thickness = 200, 
        silver_amount = 9.6, 
        silicon_elec_intensity = 30+10,
        sic_recycled_share=0.694, 
        teg_recycled_share = 0.899, 
        diamond_wiring=0, 
        d_lorry = 1020, 
        d_train = 350, 
        d_sea = 4000,
        recycling_rate_alu = 0.96, 
        recycling_rate_cu = 0.75,
        recycling_rate_glass = 0.9,
        electricity_recycling = 50,
        heat_recycling = 76)
```

```{python}
printAct(
    wafer, wafer_adjusted,
        P = 10, 
        module_efficiency = 0.125, 
        is_roof_system = 1,
        share_recycled_aluminium = 0.27, 
        elec_switch = None, 
        inverter_weight_per_p = 2,   
        inverter_lifetime = 15,
        pv_lifetime = 30,
        glass_thickness = 4,
        recycling_rate = 0,
        manufacturing_efficiency = 0,
        kerf_loss = 0.44, 
        wafer_thickness = 200, 
        silver_amount = 9.6, 
        silicon_elec_intensity = 30+10,
        sic_recycled_share=0.694, 
        teg_recycled_share = 0.899, 
        diamond_wiring=0, 
        d_lorry = 1020, 
        d_train = 350, 
        d_sea = 4000,
        recycling_rate_alu = 0.96, 
        recycling_rate_cu = 0.75,
        recycling_rate_glass = 0.9,
        electricity_recycling = 50,
        heat_recycling = 76)
```

## PV Production

We do not compute PV production here. Just take it as a parameter, together with performance factor of the panel.


```{python}
productible = newFloatParam(
    "productible", 
    default=1200, min=800, max=1600, 
    description="PV productible for one year",  
    unit="kWh per kWc per year")

performance_ratio = newFloatParam(
    "performance_ratio", 
    default=0.8, min=0.6, max=1, 
    description="Performance of PV installation, accounting  for setup conditions and decay of performances over lifetime",  
    unit="kWh per kWc per year")

# productible over lifetime
productible_life = performance_ratio * productible * pv_lifetime

impact_model = newActivity("impact model per kWh produced over lifetime", unit="unit per kWh", exchanges={
    pvModel: 1 / (performance_ratio * productible * P * pv_lifetime)
})
```

# Statistics : One at a time

```{python}
interactive_param_analysis(impact_model, impacts)
```

# Statistics : Stochastics

```{python}
res = stochastic(impact_model, impacts[1])
```

```{python}
res
```

```{python}

```
