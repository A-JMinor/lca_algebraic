---
jupyter:
  jupytext:
    formats: ipynb,Rmd
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.2'
      jupytext_version: 1.3.2
  kernelspec:
    display_name: Python 3
    language: python
    name: python3
---

# Imports

Besides external libraries, we import several function from the local file : `utils.py`

```{python}
# %load_ext autoreload
# %autoreload 2
import pandas as pd
import time
import matplotlib.pyplot as plt
import numpy as np
import brightway2 as bw

# Custom utils defined for inter-acv
from utils import *

pd.options.display.max_rows = 100
```

# Init brightway2 and databases

```{python}
# Setup bw2
bw.projects.set_current('acv-pv')
bw.bw2setup()

# Import Ecoinvent DB (if not already done)
# Update the PATH to suit your installation
#resetDb(ECOINVENT_DB_NAME)
importDb(ECOINVENT_DB_NAME, './ecoinvent 3.4_cutoff_ecoSpold02/datasets')

# We use a separate DB for defining our model, reset it beforehand
resetDb(ACV_DB_NAME)

# Parameters are stored at project level : reset them
resetParams()
```

#  Parameters of the model

We define the parameters of the model.

The numeric parametes are instances of sympy' 'Symbol' . Thus, any python arithmetic expression composed of parameters will not result into direct evaluation, but the creation of a symbolic formula that can be manipulated later.


# Select the impacts to consider

```{python}
# List of impacts to consider
impacts = [m for m in bw.methods if 'ILCD 1.0.8 2016' in str(m) and 'no LT' in str(m)]
```

# Electricity mix


```{python}
# Switch parameter for electricity mix
elec_switch = newParamDef(
    'elec_switch', 
    ParamType.ENUM, 
    values=["us", "eu", "row", "cn", "fr" ], 
    default=None, 
    description="Switch on electricty mix")
```

```{python}
ELEC_NAME = 'market for electricity, medium voltage'
ELEC_GROUP_NAME = 'market group for electricity, medium voltage'
elec_us = findTechAct(ELEC_GROUP_NAME, "US")
elec_eu = findTechAct(ELEC_GROUP_NAME, "ENTSO-E")
elec_fr = findTechAct(ELEC_NAME, "FR")
elec_cn = findTechAct(ELEC_NAME, "CN-CSG")
elec_row = findTechAct(ELEC_NAME, "RoW")
```

```{python}
# Virtual activity corresponding to switch upon elec mixes
elec = newSwitchAct("elec", elec_switch, {
    "us" : elec_us,
    "eu" : elec_eu,
    "fr" : elec_fr,
    "cn" : elec_cn,
    "row" : elec_row})
```

```{python}
multiLCA([elec_us, elec_eu, elec_row, elec_cn, elec_fr], impacts)
```

# Aluminium 

```{python}
alu=findTechAct('aluminium alloy production, AlMg3', 'RER')
alu_scrap=findTechAct('aluminium scrap, new, Recycled Content cut-off')
alu_cast_amount = alu.getAmount('aluminium, cast alloy')
```

```{python}
share_recycled_aluminium = newFloatParam(
    'share_recycled_aluminium',  
    default=0.3, 
    description="Share of reycled aluminium")
```

```{python}
alu_adjusted = copyActivity(alu, "Alu adjusted")

alu_adjusted.updateExchanges( 
    {"aluminium, cast alloy": alu_cast_amount * (1 - share_recycled_aluminium)}) 
alu_adjusted.addExchanges( 
    {alu_scrap : alu_cast_amount * share_recycled_aluminium} )

alu_adjusted.substituteWithDefault(
    'electricity, high voltage, aluminium industry', 
    elec)
```

```{python}
printAct(alu, alu_adjusted, share_recycled_aluminium=0.3, elec_switch=None)
multiLCA([alu, alu_adjusted], impacts, share_recycled_aluminium=0.3, elec_switch=None)
```

# Mounting system

```{python}
# 2 Mounting system are identified (Aluminium and stainless steel based)
ground_system = findTechAct('photovoltaic mounting system production, for 570kWp open ground module')
roof_system = findTechAct('photovoltaic mounting system production, for slanted-roof installation', 'RER')
```

```{python}
# Build a modified roof system with recycled output
roof_alu_amount = roof_system.getAmount('aluminium, wrought alloy')
roof_steel_amount = roof_system.getAmount('steel, low-alloyed, hot rolled')
scrap_steel_market = findTechAct('market for scrap steel', 'Europe without Switzerland')
scrap_alu_market= findTechAct('market for scrap aluminium', 'Europe without Switzerland')


roof_system_modified = copyActivity(roof_system, "Roof system recycled")

# Add scrap alu and steel output 
roof_system_modified.addExchanges({
    scrap_alu_market : - roof_alu_amount,
    scrap_steel_market : - roof_steel_amount})
```

```{python}
# Replace alu with recycled alu
ground_system_modified = copyActivity(ground_system, "Ground system modified")

roof_system_modified.updateExchanges(
    {'aluminium, wrought alloy' : dict(input=alu_adjusted)})
ground_system_modified.updateExchanges(
    {'aluminium, wrought alloy' : dict(input=alu_adjusted)})
```

```{python}
printAct(ground_system, ground_system_modified)
printAct(roof_system, roof_system_modified)
```

```{python}
multiLCA(
    [roof_system_modified, ground_system_modified], 
    impacts, 
    elec_switch=None, 
    share_recycled_aluminium=0.3)
```


# Electrical installation

```{python}
P = newFloatParam("P", 10, description="power Kwc")

electrical_installation_3kW = findTechAct('photovoltaics, electric installation for 3kWp module, at building', 'RoW')

# 3kW system weights 33 kg, 570kW system weight 1570kg
# We compute a formula computing the number of unit of 3kw electrical installation for given power, based on weigth
unit_3kW_equiv = interpolate(P, 3, 570, 1, 1570/33)
```

# Inverter

```{python}
inverter_500kW = findTechAct('inverter production, 500kW', 'RER')
inverter_2500W = findTechAct('inverter production, 2.5kW', 'RER')
weigth_2500W = 18.5
weigth_500kW = 3000
printAct(inverter_500kW, inverter_2500W)
```

```{python}
# Generate a dataset for 1kG of inverter, based on the power
inverter_per_kg = newInterpolatedAct(
    "Inverter production, P kW per kg",
    inverter_2500W, 
    inverter_500kW,
    2.5, # FIXME : Wrong in original model should be 2.5 ?
    500,
    P,
    1 / weigth_2500W,
    1 / weigth_500kW, 
    unit="kilogram")
```

```{python}
# Add recycling 
recycling_rate = newFloatParam("recycling_rate", 0.3, description="Recycling rate for inverter")

scrap_alu = findTechAct("market for scrap aluminium", "Europe without Switzerland")
scrap_steel = findTechAct("market for scrap steel", "Europe without Switzerland")
scrap_coper = findTechAct("market for scrap copper", "Europe without Switzerland")
scrap_electronic = findTechAct("market for electronics scrap")

amount_alu = inverter_per_kg.getAmount('aluminium, cast alloy')
amount_copper = inverter_per_kg.getAmount('copper')
amount_steel = inverter_per_kg.getAmount('steel, low-alloyed, hot rolled')
amount_electronic = inverter_per_kg.getAmount(
    ['capacitor*', 'diode*', 'integrated circuit*', 'printed wiring*', 'resistor*', 'transitor*'], 
    sum=True)

inverter_per_kg.addExchanges({
    scrap_alu : amount_alu * recycling_rate,
    scrap_coper : amount_copper * recycling_rate,
    scrap_electronic : amount_electronic * recycling_rate,
    scrap_steel : amount_steel * recycling_rate})
```

```{python}
printAct(inverter_per_kg, P=500, recycling_rate=0.3)
```

# Metalization paste

This section replaces all the silver used in the metallization paste by copper. However, the adequate replacement will be accomplished in the following sections according to the conductivity.


```{python}
# Find root activities
metal_paste = findTechAct("metallization paste production, back side", "RER")
copper = findTechAct('copper production, primary', "RoW")

# Copy and update mateal paste with copper
metal_paste_copper = copyActivity(metal_paste, 'metal paste, copper')
metal_paste_copper.updateExchanges({'silver' : dict(input=copper, name="copper")})
```

```{python}
printAct(metal_paste_copper)
```

# Silicon solar grade manufacturing

In this section, the main modification implemented is the change of the electrcity intensity used for the manufacturing of the solar grade.

```{python}
silicon_elec_intensity = newFloatParam(
    "silicon_elec_intensity", 
    40, 
    description="electricity used for solar processing and casting ")
```

```{python}
silicon = findTechAct('silicon production, solar grade, modified Siemens process', 'RER')
silicon_adjusted = copyActivity(silicon, "silicon production adjusted")

# Delete hydroelectricy, for not counting it twice
silicon_adjusted.updateExchanges({'electricity, high voltage#RoW' : None})

# Replace elec with elec switch, and update amount as a parameter
silicon_adjusted.substituteWithDefault('electricity, high voltage#RER', elec, silicon_elec_intensity)
```

```{python}
printAct(silicon_adjusted)
```

```{python}
multiLCAAlgebric([silicon, silicon_adjusted], impacts, elec_switch=None, silicon_elec_intensity=40)
```

# Casting Dataset 

Let's remove the use of silicon electronics grade (it was significant when the world silicon production was relatively low, nowadays this volume can be neglected compared to the level reached by the solar industry).
Let's remove also silicon solar grade as it is directly call by the wafer dataset and also electricity that is already accounted in the amount of electricity for solar grade manufacturing.
As a consequence, only chemicals, the factory and ceramic will be left and this dataset will complement the silicon solar grade dataset and both will be called for the wafer dataset.

```{python}
silicon_casting = findTechAct('silicon production, multi-Si, casted', 'RoW')

silicon_casting_adjusted = copyActivity(silicon_casting, 'silicon casting adjusted')

silicon_casting_adjusted.updateExchanges({
    'silicon,*' : None,
    'electricity, medium voltage*' : None})
```

```{python}
printAct(silicon_casting, silicon_casting_adjusted)
```

```{python}
multiLCAAlgebric([silicon_casting, silicon_casting_adjusted], impacts)
```

# Wafer manufacturing

In this section, some modifications were integrated by creating new datasets related mainly to the emerging practices in the cutting processes: 6 new datasets were created to serve this purpose.
On one hand, 2 of them (SiC recycled and TEG recycled) are related to the advancements of the traditional cutting process (loose abrasive slurry). The advancement of their recycling has resulted in the use of their recycled material recovered.
On another hand, the 4 new datasets are created to represent 1 meter of wire used in the emerging technology: the diamond wiring.


## Cutting Process

### SiC, Recycled

```{python}
silicon_carbide = findTechAct('silicon carbide production', 'RER')
silicon_carbide_recycled = copyActivity(silicon_carbide, 'silicon carbid adjusted', withExchanges=False)
silicon_carbide_recycled.addExchanges({
    findTechAct('market group for electricity, medium voltage', 'ENTSO-E') : 0.78571,
    findTechAct('market for transport, freight, lorry, unspecified', 'GLO') : 0.2625,
    findTechAct('market for silicone factory') : 1e-11,
    findBioAct('Heat, waste', categories=['air']) : 2.8286,
    findTechAct('market for waste, from silicon wafer production, inorganic') : -0.042857,
    findTechAct('treatment of spent antifreezer liquid, hazardous waste incineration', 'CH') : -0.071429,
    findTechAct('market for sludge, pig iron production', 'Europe without Switzerland') : -0.13571,
})
```

```{python}
printAct(silicon_carbide, silicon_carbide_recycled)
```

```{python}
multiLCAAlgebric([silicon_carbide, silicon_carbide_recycled], impacts)
```

### TEG, Recycled

FIXME : This model is wrong, it is a pure copy-paste of SiC recycled.

```{python}
teg = findTechAct(code='85c5a45f05a8e40c76aebf8a4dbdc3ad')
teg_recycled = copyActivity(teg, "TEG recycled", withExchanges=False)

teg_recycled.addExchanges({
    findTechAct('market group for electricity, medium voltage', 'ENTSO-E') : 0.78571,
    findTechAct('market for transport, freight, lorry, unspecified', 'GLO') : 0.2625,
    findTechAct('market for silicone factory') : 1e-11,
    findBioAct('Heat, waste', categories=['air']) : 2.8286,
    findTechAct('market for waste, from silicon wafer production, inorganic') : -0.042857,
    findTechAct('treatment of spent antifreezer liquid, hazardous waste incineration', 'CH') : -0.071429,
    findTechAct('market for sludge, pig iron production', 'Europe without Switzerland') : -0.13571,
})
```

```{python}
multiLCAAlgebric([teg, teg_recycled], impacts)
```

### Diamond Wiring

All the following datasets are based on Isabella Bianco thesis (2018) in which she analyzed the cutting processes in details. It was essential to integrate these datasets to elaborate the dataset of the wire which will be used for the cutting process according to the emerging diamond wiring technology.

#### Tungstene

```{python}
tungstene_carbide = copyActivity(silicon_carbide, "tungstene carbide", withExchanges=False)

tungstene_carbide.addExchanges({
    findTechAct('market for sodium hydroxide*') : 1.49,
    findTechAct('aluminium sulfate production, powder', 'RER') : 0.071,
    findTechAct('sodium sulfide production') : 0.044,
    findTechAct('magnesium sulfate production', 'RER') : 0.027,
    findTechAct('market for ammonia, liquid', 'RER') : 0.106,
    findTechAct('market for soda ash, dense') : 1.21,
    findTechAct('sulfuric acid production', 'RER') : 1.24,
    findTechAct('market group for electricity, medium voltage', 'ENTSO-E') : 111.16,
    findTechAct('hydrogen sulfide production', 'RER') : 0.0076,
    findTechAct('market for nitrogen, liquid', 'RER') : 1.65,
    findTechAct('market for hydrogen, liquid', 'RER') : 0.32,
    findTechAct('market for tap water', 'RoW') : 2.84,
    findTechAct('carbon black production') : 0.13,
})
    
```

```{python}
multiLCAAlgebric(tungstene_carbide, impacts)
```

```{python}
printAct(tungstene_carbide)
```

```{python}
multiLCAAlgebric(tungstene_carbide, impacts)
```

#### Diamond powder

```{python}
diamond_powder_ori = findTechAct('sodium percarbonate production, powder', 'RER')
diamond_powder = copyActivity(diamond_powder_ori, "Diamond powder",  withExchanges=False)
diamond_powder.addExchanges({
    findTechAct("market for electricity, medium voltage", "RoW") : 840,
    findTechAct("graphite production", "RER") : 1,
    findTechAct("transport, freight, sea, transoceanic ship") : 170,
    findTechAct("transport, freight, lorry 16-32 metric ton, EURO4", "RER") : 0.53,
})
```

```{python}
printAct(diamond_powder)
```

```{python}
multiLCAAlgebric(diamond_powder, impacts)
```

#### Sintered diamond bead

```{python}
sintered_diamond_ori = findTechAct("polymethyl methacrylate production, beads", "RER")

sintered_diamond = copyActivity(sintered_diamond_ori, "sintered diamond bead, for quarrying", withExchanges=False)
sintered_diamond.addExchanges({
    findTechAct("market group for electricity, medium voltage", "ENTSO-E") : 0.1,
    findTechAct("market for steel, unalloyed") : 0.003,
    findTechAct("market for cobalt") : 7e-08,
    findTechAct("market for copper") : 2.1e-07,
    findTechAct("market for pig iron") : 3.5e-07,
    findTechAct("market for nickel, 99.5%") : 2.1e-08,
    tungstene_carbide : 3.5e-08,
    diamond_powder : 2e-05,
    findTechAct('polymethyl methacrylate production, beads', "RER") :  2e-05,
    findTechAct("cobalt production") : 5e-05,
    findTechAct("market for silver") : 2.1e-04,
    findTechAct("market for nitrogen, liquid", "RER") : 0.0323, 
    findTechAct("market for hydrogen, liquid", "RER") : 9e-04, 
})

sintered_diamond.setOutputAmount(0.004)
```

```{python}
printAct(sintered_diamond)
```

```{python}
multiLCAAlgebric(sintered_diamond, impacts)
```

#### sintered diamond wire, steel

```{python}
act_ori = findTechAct('wire drawing, steel', 'RER')
sintered_diamond_wire = copyActivity(act_ori, "sintered diamond wire, steel", withExchanges=False)

sintered_diamond_wire.addExchanges({
    sintered_diamond : 0.0427,
    findTechAct("market group for electricity, medium voltage", "ENTSO-E") : 0.9, 
    findTechAct("wire drawing, steel", "RER") : 0.095, 
    findTechAct("wire drawing, steel", "RER") : 0.095, 
    findTechAct("polyurethane production, flexible foam", "RER") : 0.15, 
    findTechAct("transport, freight, lorry 16-32 metric ton, EURO4", "RER") : 0.003, 
    findTechAct("market for waste plastic, mixture", "Europe without Switzerland") : 0.045, 
})
```

```{python}
printAct(sintered_diamond_wire)
```

```{python}
multiLCAAlgebric(sintered_diamond_wire, impacts)
```

## Wafer 

This function generates an inventory of 1 m² of wafer production. 
    The initial amount of electricity (8 kWh/m²) is adjusted (to 20 kWh/m2 as per KBOB:2016) considering the possibility 
    to be improved (by using less) using manufacturing_efficiency_gains parameter (expressed in fraction/percentage).
    The electricity dataset can be also controlled using the elec_dataset parameter.
    The wafer solar grade used is the wafer solar grade adjusted (that considered the progress in solar grade wafer production),
    the amount of wafer is also adjusted considering the wafer thickness decreasing with the technical progress and evolution 
    of cutting processes with less kerf loss. manufacturing_efficiency_gains and kerf loss are expressed in fraction.
    wafer thickness is expressed in micrometer.
    SiC amount is adjusted from 2.63 kg (Ecoinvent 3.4) to 2.02988 kg (KBOB:2016) in total of which a certain amount (69.4%) 
    is produced from a recycled process with the possibility to modify it. SiC_recycled_share is the amount of recycled SiC
    expressed in fraction/percentage.
    TEG amount is adjusted from 2.71 kg (Ecoinvent 3.4) to 2.16548 kg (KBOB:2016) in total of which a certain amount (89.9%) 
    is produced from a recycled process with the possibility to modify it. TEG_recycled_share is the amount of recycled TEG
    expressed in fraction/percentage.
    Since the Diamond wiring technology is emerging, hence an added boolean parameter is added related to the added/omitted
    amount of SiC, TEG, diamond wire, and water.

```{python}
# Parameters
diamond_wiring = newFloatParam("diamond_wiring", 1, description="Boolean choice. ") 
wafer_thickness = newFloatParam("wafer_thickness", 200)
kerf_loss = newFloatParam("kerf_loss", 0.44)
sic_recycled_share = newFloatParam("sic_recycled_share", 0.694)
teg_recycled_share = newFloatParam("teg_recycled_share", 0.899)
manufacturing_efficiency = newFloatParam("manufacturing_efficiency", 0)

# Root activities
natural_gas = findTechAct(in_name="heat production, natural gas, at industrial furnace >100kW", loc="Europe without Switzerland")

# Formulas 
sili_casting_amount = wafer_thickness * 1e-6 * 2328 / (1 - kerf_loss)
non_diamond_wiring = 1 - diamond_wiring


# Copy Wafer
wafer = findTechAct("multi-Si wafer production", "RER")
wafer_adjusted = copyActivity(wafer, "Wafer adjusted")

# Update wafer
wafer_adjusted.updateExchanges({
    'silicon, multi-Si, casted' : dict(
        input = silicon_adjusted, 
        amount = sili_casting_amount, 
        name='silicon production, adjusted'),  
    'tap water' : old_amount + diamond_wiring * 98.94,
    'silicon carbide' : non_diamond_wiring * 2.02988 * (1 - sic_recycled_share),
    'triethylene glycol' : non_diamond_wiring * 2.16548 * (1 - teg_recycled_share),
})

wafer_adjusted.addExchanges({
    # Diamond wiring (see also Tap water updated above)
    # sintered_diamond : diamond_wiring * 0.0006075,
    sintered_diamond_wire :  diamond_wiring * 0.0006075,
    
    # Non -diamond wiring
    silicon_carbide_recycled : non_diamond_wiring * 2.02988 * sic_recycled_share,
    teg_recycled : non_diamond_wiring * 2.16548 * teg_recycled_share,
    
    silicon_casting_adjusted : sili_casting_amount,
    
    # Adding the 4 MJ natural gas used for the wafer as proposed by KBOB
    natural_gas : 4 
})

# Adjusting the amount of electricity used
wafer_adjusted.substituteWithDefault(
    'electricity, medium voltage', 
    elec, 
    amount=20 * (1 - manufacturing_efficiency))
```

```{python}
printAct(wafer_adjusted, 
         sic_recycled_share=0.4,
        teg_recycled_share=0.3,
        diamond_wiring=1,
        manufacturing_efficiency=0.2,
        kerf_loss=0.50,
        wafer_thickness=240,
        elec_switch=None,
        silicon_elec_intensity=40)
```

```{python}
multiLCAAlgebric([wafer, wafer_adjusted], 
        impacts, 
        sic_recycled_share=0.4,
        teg_recycled_share=0.3,
        diamond_wiring=1,
        manufacturing_efficiency=0.2,
        kerf_loss=0.50,
        wafer_thickness=240,
        elec_switch=None,
        silicon_elec_intensity=40)
```

```{python}
multiLCAAlgebric([wafer, wafer_adjusted], 
        impacts, 
        sic_recycled_share=0.694,
        teg_recycled_share=0.899,
        diamond_wiring=0,
        manufacturing_efficiency=0,
        kerf_loss=0.44,
        wafer_thickness=200,
        elec_switch=None,
        silicon_elec_intensity=40)
```

```{python}
printAct(wafer_adjusted,
         sic_recycled_share=0.694,
        teg_recycled_share=0.899,
        diamond_wiring=0,
        manufacturing_efficiency=0,
        kerf_loss=0.44,
        wafer_thickness=200,
        elec_switch=None,
        silicon_elec_intensity=40)
```

```{python}

```
