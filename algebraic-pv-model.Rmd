---
jupyter:
  jupytext:
    formats: ipynb,Rmd
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.2'
      jupytext_version: 1.3.2
  kernelspec:
    display_name: Python 3
    language: python
    name: python3
---

# Imports

Besides external libraries, we import several function from the local file : `utils.py`

```{python}
# %load_ext autoreload
# %autoreload 2
import pandas as pd
import time
import matplotlib.pyplot as plt
import numpy as np
import brightway2 as bw

# Custom utils defined for inter-acv
from utils import *
from expression import *

pd.options.display.max_rows = 100
```

# Init brightway2 and databases

```{python}
# Setup bw2
bw.projects.set_current('B_Publication')
bw.bw2setup()

# Import Ecoinvent DB (if not already done)
# Update the PATH to suit your installation
#resetDb(ECOINVENT_DB_NAME)
importDb(ECOINVENT_DB_NAME, './ecoinvent 3.4_cutoff_ecoSpold02/datasets')

# We use a separate DB for defining our model, reset it beforehand
resetDb(ACV_DB_NAME)

# Parameters are stored at project level : reset them
resetParams()
```

#  Parameters of the model

We define the parameters of the model.

The numeric parametes are instances of sympy' 'Symbol' . Thus, any python arithmetic expression composed of parameters will not result into direct evaluation, but the creation of a symbolic formula that can be manipulated later.


# Select the impacts to consider

```{python}
# List of impacts to consider
impacts = [m for m in bw.methods if 'ILCD 1.0.8 2016' in str(m) and 'no LT' in str(m)]
```

# Electricity mix


```{python}
# Switch parameter for electricity mix
elec_switch = newParamDef(
    'elec_switch', 
    ParamType.ENUM, 
    values=["us", "eu", "row", "cn", "fr" ], 
    default=None, 
    description="Switch on electricty mix")
```

```{python}
ELEC_NAME = 'market for electricity, medium voltage'
ELEC_GROUP_NAME = 'market group for electricity, medium voltage'
elec_us = findTechAct(ELEC_GROUP_NAME, "US")
elec_eu = findTechAct(ELEC_GROUP_NAME, "ENTSO-E")
elec_fr = findTechAct(ELEC_NAME, "FR")
elec_cn = findTechAct(ELEC_NAME, "CN-CSG")
elec_row = findTechAct(ELEC_NAME, "RoW")
```

```{python}
# Virtual activity corresponding to switch upon elec mixes
elec = switch("elec", elec_switch, {
    "us" : elec_us,
    "eu" : elec_eu,
    "fr" : elec_fr,
    "cn" : elec_cn,
    "row" : elec_row})
```

```{python}
multiLCA([elec_us, elec_eu, elec_row, elec_cn, elec_fr], impacts)
```

# Aluminium 

```{python}
alu=findTechAct('aluminium alloy production, AlMg3', 'RER')
alu_scrap=findTechAct('aluminium scrap, new, Recycled Content cut-off')
alu_cast_amount = alu.get_amount('aluminium, cast alloy')
```

```{python}
share_recycled_aluminium = newFloatParam(
    'share_recycled_aluminium',  
    default=0.3, 
    description="Share of reycled aluminium")
```

```{python}
alu_adjusted = copyActivity(alu, "Alu adjusted")

updateExchanges(alu_adjusted, 
    {"aluminium, cast alloy": alu_cast_amount * (1 - share_recycled_aluminium)}) 

addExchanges(alu_adjusted, 
    {alu_scrap : alu_cast_amount * share_recycled_aluminium} )

substituteWithDefault(
    alu_adjusted, 
    'electricity, high voltage, aluminium industry', 
    elec)

```

```{python}
print_act(alu, alu_adjusted, share_recycled_aluminium=0.3, elec_switch=None)
multiLCA([alu, alu_adjusted], impacts, share_recycled_aluminium=0.3, elec_switch=None)
```

# Mounting system

```{python}
# 2 Mounting system are identified (Aluminium and stainless steel based)
ground_system = findTechAct('photovoltaic mounting system production, for 570kWp open ground module')
roof_system = findTechAct('photovoltaic mounting system production, for slanted-roof installation', 'RER')
```

```{python}
# Build a modified roof system with recycled output
roof_alu_amount = roof_system.get_amount('aluminium, wrought alloy')
roof_steel_amount = roof_system.get_amount('steel, low-alloyed, hot rolled')
scrap_steel_market = findTechAct('market for scrap steel', 'Europe without Switzerland')
scrap_alu_market= findTechAct('market for scrap aluminium', 'Europe without Switzerland')


roof_system_modified = copyActivity(roof_system, "Roof system recycled")

# Add scrap alu and steel output 
addExchanges(roof_system_modified, {
    scrap_alu_market : - roof_alu_amount,
    scrap_steel_market : - roof_steel_amount})
```

```{python}
# Replace alu with recycled alu
ground_system_modified = copyActivity(ground_system, "Ground system modified")

updateExchanges(roof_system_modified, 
    {'aluminium, wrought alloy' : dict(input=alu_adjusted)})
updateExchanges(ground_system_modified, 
    {'aluminium, wrought alloy' : dict(input=alu_adjusted)})
```

```{python}
print_act(ground_system_modified)
print_act(roof_system_modified)
```

```{python}
multiLCA(
    [roof_system_modified, ground_system_modified], 
    impacts, 
    elec_switch=None, 
    share_recycled_aluminium=0.3)
```


# Electrical installation

```{python}
P = newFloatParam("P", 10, description="power Kwc")

electrical_installation_3kW = findTechAct('photovoltaics, electric installation for 3kWp module, at building', 'RoW')

# 3kW system weights 33 kg, 570kW system weight 1570kg
# We compute a formula computing the number of unit of 3kw electrical installation for given power, based on weigth
unit_3kW_equiv = interpolate(P, 3, 570, 1, 1570/33)
```

# Inverter

```{python}
inverter_500kW = findTechAct('inverter production, 500kW', 'RER')
inverter_2500W = findTechAct('inverter production, 2.5kW', 'RER')
weigth_2500W = 18.5
weigth_500kW = 3000
print_act(inverter_500kW, inverter_2500W)
```

```{python}
# Generate a dataset for 1kG of inverter, based on the power
inverter_per_kg = interpolated_act(
    "Inverter production, P kW per kg",
    inverter_2500W, 
    inverter_500kW,
    2.5, # FIXME : Wrong in original model should be 2.5 ?
    500,
    P,
    1 / weigth_2500W,
    1 / weigth_500kW, 
    unit="kilogram")
```

```{python}
# Add recycling 
recycling_rate = newFloatParam("recycling_rate", 0.3, description="Recycling rate for inverter")

scrap_alu = findTechAct("market for scrap aluminium", "Europe without Switzerland")
scrap_steel = findTechAct("market for scrap steel", "Europe without Switzerland")
scrap_coper = findTechAct("market for scrap copper", "Europe without Switzerland")
scrap_electronic = findTechAct("market for electronics scrap")

amount_alu = inverter_per_kg.get_amount('aluminium, cast alloy')
amount_copper = inverter_per_kg.get_amount('copper')
amount_steel = inverter_per_kg.get_amount('steel, low-alloyed, hot rolled')
amount_electronic = inverter_per_kg.get_amount(
    in_name=['capacitor', 'diode', 'integrated circuit', 'printed wiring', 'resistor', 'transitor'], 
    sum=True)

addExchanges(inverter_per_kg, {
    scrap_alu : amount_alu * recycling_rate,
    scrap_coper : amount_copper * recycling_rate,
    scrap_electronic : amount_electronic * recycling_rate,
    scrap_steel : amount_steel * recycling_rate})
```

```{python}
print_act(inverter_per_kg, P=500, recycling_rate=0.3)
```

# Metalization paste

This section replaces all the silver used in the metallization paste by copper. However, the adequate replacement will be accomplished in the following sections according to the conductivity.


```{python}
# Find root activities
metal_paste = findTechAct("metallization paste production, back side", "RER")
copper = findTechAct('copper production, primary', "RoW")

# Copy and update mateal paste with copper
metal_paste_copper = copyActivity(metal_paste, 'metal paste, copper')
updateExchanges(metal_paste_copper, {'silver' : dict(input=copper, name="copper")})
```

```{python}
print_act(metal_paste_copper)
```

# Silicon solar grade manufacturing

In this section, the main modification implemented is the change of the electrcity intensity used for the manufacturing of the solar grade.

```{python}
silicon_elec_intensity = newFloatParam("silicon_elec_intensity", 40, description="electrcity used for solar processing and casting ")
```

```{python}
silicon = findTechAct('silicon production, solar grade, modified Siemens process', 'RER')
```

```{python}
silicon_adjusted = copyActivity(silicon, "Silicon adjusted")
print_act(silicon)
```

```{python}
# Delete hydroelectricy, for not counting it twice
updateExchanges(silicon_adjusted, {'electricity, high voltage#RoW' : 0})

# Replace elec with elec switch, and update amount as a parameter
substituteWithDefault(silicon_adjusted, 'electricity, high voltage#RER', elec, silicon_elec_intensity)
```

```{python}
print_act(silicon_adjusted)
```

```{python}
multiLCAAlgebric([silicon, silicon_adjusted], impacts, elec_switch=None, silicon_elec_intensity=40)
```

```{python}

```
