---
jupyter:
  jupytext:
    formats: ipynb,Rmd
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.2'
      jupytext_version: 1.3.2
  kernelspec:
    display_name: Python 3
    language: python
    name: python3
---

# Imports

Besides external libraries, we import several function from the local file : `utils.py`

```{python}
# %load_ext autoreload
# %autoreload 2
# %matplotlib inline
import pandas as pd
import time
import matplotlib.pyplot as plt
import numpy as np
import brightway2 as bw
import SALib
from tabulate import tabulate
from sympy import *
from scipy.stats import binned_statistic
import seaborn as sns
from IPython.display import HTML, display

# Custom utils defined for inter-acv
from lib.utils import *

from IPython.core.display import display, HTML
display(HTML("<style>.container { width:70% !important; }</style>"))

pd.options.display.max_rows = 100
```

# Init brightway2 and databases

```{python}
# Setup bw2
bw.projects.set_current('acv-pv')
bw.bw2setup()

# Import Ecoinvent DB (if not already done)
# Update the PATH to suit your installation
#resetDb(ECOINVENT_DB_NAME)
importDb(ECOINVENT_DB_NAME, './ecoinvent 3.4_cutoff_ecoSpold02/datasets')

# We use a separate DB for defining our model, reset it beforehand
resetDb(ACV_DB_NAME)

# Parameters are stored at project level : reset them
resetParams()
```

# Select the impacts to consider

```{python}
# List of impacts to consider
impacts = [m for m in bw.methods if 'ILCD 1.0.8 2016' in str(m) and 'no LT' in str(m)]
```

# Electricity mix


```{python}
# Switch parameter for electricity mix
elec_switch = newEnumParam(
    'elec_switch',
    values=["us", "eu", "row", "cn", "fr" ], 
    default="eu",
    label='Electricty mix',
    label_fr='Mix électrique',
    group='manufacturing', 
    description="Switch on electricty mix")
```

```{python}
ELEC_NAME = 'market for electricity, medium voltage'
ELEC_GROUP_NAME = 'market group for electricity, medium voltage'
elec_us = findTechAct(ELEC_GROUP_NAME, "US")
elec_eu = findTechAct(ELEC_GROUP_NAME, "ENTSO-E")
elec_fr = findTechAct(ELEC_NAME, "FR")
elec_cn = findTechAct(ELEC_NAME, "CN-CSG")
elec_row = findTechAct(ELEC_NAME, "RoW")
```

```{python}
# Virtual activity corresponding to switch upon elec mixes
elec = newSwitchAct("elec", elec_switch, {
    "us" : elec_us,
    "eu" : elec_eu,
    "fr" : elec_fr,
    "cn" : elec_cn,
    "row" : elec_row})
```

```{python}
multiLCA([elec_us, elec_eu, elec_row, elec_cn, elec_fr], impacts)
```

# Aluminium 

```{python}
alu=findTechAct('aluminium alloy production, AlMg3', 'RER')
alu_scrap=findTechAct('aluminium scrap, new, Recycled Content cut-off')
alu_cast_amount = alu.getAmount('aluminium, cast alloy')
```

```{python}
share_recycled_aluminium = newFloatParam(
    'share_recycled_aluminium',  
    default=0.27, min=0, max=1,
    group='manufacturing',
    label='share of recycled aluminium',
    label_fr="part d'aluminium recyclé",
    unit="fraction")
```

```{python}
alu_adjusted = copyActivity(alu, "Alu adjusted")

alu_adjusted.updateExchanges( 
    {"aluminium, cast alloy": alu_cast_amount * (1 - share_recycled_aluminium)}) 
alu_adjusted.addExchanges( 
    {alu_scrap : alu_cast_amount * share_recycled_aluminium} )

alu_adjusted.substituteWithDefault(
    'electricity, high voltage, aluminium industry', 
    elec, elec_switch)
```

```{python}
printAct(alu, alu_adjusted, share_recycled_aluminium=0.3, elec_switch=None)
multiLCA([alu, alu_adjusted], impacts, share_recycled_aluminium=0.3, elec_switch=None)
```

# Mounting system

```{python}
is_roof_system = newBoolParam(
    "is_roof_system", 
    True,
    group="installation",
    label="roof system", 
    label_fr="toiture")

mounting_system_weight = newFloatParam(
    "mounting_system_weight", 
    default=0.45, min=0.1, max=0.45, 
    group="installation",
    label="mounting system weigth",
    label_fr="masse du systeme de montage",
    unit="kg/m²")

ground_coverage_ratio = newFloatParam(
    "ground_coverage_ratio", 
    default=0.45, min=0.1, max=0.45, 
    group="production",
    label="ground coverage ratio",
    label_fr="rtio de couverture au sol",
    unit="fraction")

pv_lifetime = newFloatParam(
    "pv_lifetime", 
    default=30, min=20, max=40, 
    group="production",
    label="pv lifetime",
    label_fr="durée de vie module",
    unit="year")

```

```{python}
# 2 Mounting system are identified (Aluminium and stainless steel based)
ground_system = findTechAct('photovoltaic mounting system production, for 570kWp open ground module')

# Extract original amounts 
alu_amount = ground_system.getAmount("aluminium, wrought alloy")
steel_amount = ground_system.getAmount("reinforcing steel")
scrap_steel_amount = ground_system.getAmount("scrap steel*", sum=True)
chromium_steel_amount = ground_system.getAmount("steel, chromium steel*")
section_bar_amount = ground_system.getAmount("section bar rolling*")
waste_concrete_amount =  ground_system.getAmount('waste reinforced concrete*', sum=True)
```

```{python}
mounting_system_modified = copyActivity(ground_system, "mounting system adjusted")

# Mounting system weight compared to original inventory
weight_ratio = mounting_system_weight / 11.5

#Deleting duplicate market for srapt steel, alu and concrete to keep only global market
mounting_system_modified.deleteExchanges("scrap*#!RoW", single=False)
mounting_system_modified.deleteExchanges("waste reinforced concrete*#!RoW", single=False)
mounting_system_modified.deleteExchanges("concrete, normal*#!RoW")

#Adjusting the amount of aluminium and steel related dataset
mounting_system_modified.updateExchanges({
    # Change both amount and dataset for aluminium
    'aluminium, wrought alloy' : dict(input=alu_adjusted, amount=alu_amount * weight_ratio), 
    'section bar extrusion, aluminium' : alu_amount * weight_ratio,
    'scrap aluminium': - alu_amount * weight_ratio,

    'reinforcing steel' : steel_amount * weight_ratio,
    'scrap steel' :  scrap_steel_amount * weight_ratio,                                 

    'steel, chromium steel*' : chromium_steel_amount * weight_ratio,
    'section bar rolling, steel' : section_bar_amount * weight_ratio})


# Adjusting land use 
not_roof = (1-is_roof_system)
land_use = 1 / ground_coverage_ratio * not_roof
mounting_system_modified.updateExchanges({
   'Transformation, to industrial area' : land_use,
   'Transformation, from pasture, man made' : land_use,
   'Occupation, industrial area' : land_use * pv_lifetime })

# Removing cement activities for roof installation and zinc 
mounting_system_modified.updateExchanges({
   'concrete, normal' : old_amount * not_roof,
   'waste reinforced concrete' : waste_concrete_amount * not_roof,
   'zinc coat, coils' : old_amount * not_roof,
   'zinc coat, pieces' : old_amount * not_roof})
```

```{python}
printAct(mounting_system_modified, 
         mounting_system_weight=11.5, 
         ground_coverage_ratio=0.4,
        is_roof_system=0,
        pv_lifetime=30)
```

```{python}
multiLCAAlgebric(
    mounting_system_modified, 
    impacts,
    mounting_system_weight=11.5, 
    pv_lifetime=30, 
    ground_coverage_ratio=0.4, 
    share_recycled_aluminium=0.3,
    elec_switch=None,
    is_roof_system=0)
```

# Electrical installation

```{python}
P = newFloatParam("P", 
    default=10, min=3, max=3000, 
    label="installed power", label_fr='puissance installée', 
    group="installation", unit="kWc")

electrical_installation_3kW = findTechAct('photovoltaics, electric installation for 3kWp module, at building', 'RoW')

# 3kW system weights 33 kg, 570kW system weight 1570kg
# We compute a formula computing the number of unit of 3kw electrical installation for given power, based on weigth
unit_3kW_equiv = interpolate(P, 3, 570, 1, 1570/33)
```

# Inverter

```{python}
inverter_500kW = findTechAct('inverter production, 500kW', 'RER')
inverter_2500W = findTechAct('inverter production, 2.5kW', 'RER')
weigth_2500W = 18.5
weigth_500kW = 3000
printAct(inverter_500kW, inverter_2500W)
```

```{python}
# Generate a dataset for 1kG of inverter, based on the power
inverter_per_kg = newInterpolatedAct(
    "Inverter production, P kW per kg",
    inverter_2500W, 
    inverter_500kW,
    2.5, # FIXME : Wrong in original model should be 2.5 ?
    500,
    P,
    1 / weigth_2500W,
    1 / weigth_500kW, 
    unit="kilogram")
```

```{python}
# Add recycling 
recycling_rate = newFloatParam(
    "recycling_rate", 
    default=0.9, min=0.75, max=1, 
    group="recycling", 
    label="recycling rate", 
    label_fr="taux de reyclage", unit="fraction")

scrap_alu = findTechAct("market for scrap aluminium", "Europe without Switzerland")
scrap_steel = findTechAct("market for scrap steel", "Europe without Switzerland")
scrap_coper = findTechAct("market for scrap copper", "Europe without Switzerland")
scrap_electronic = findTechAct("market for electronics scrap")

amount_alu = inverter_per_kg.getAmount('aluminium, cast alloy')
amount_copper = inverter_per_kg.getAmount('copper')
amount_steel = inverter_per_kg.getAmount('steel, low-alloyed, hot rolled')
amount_electronic = inverter_per_kg.getAmount(
    ['capacitor*', 'diode*', 'integrated circuit*', 'printed wiring*', 'resistor*', 'transitor*'], 
    sum=True)

inverter_per_kg.addExchanges({
    scrap_alu : amount_alu * recycling_rate,
    scrap_coper : amount_copper * recycling_rate,
    scrap_electronic : amount_electronic * recycling_rate,
    scrap_steel : amount_steel * recycling_rate})
```

```{python}
printAct(inverter_per_kg, P=500, recycling_rate=0.3)
```

# Metalization paste

This section replaces all the silver used in the metallization paste by copper. However, the adequate replacement will be accomplished in the following sections according to the conductivity.


```{python}
# Find root activities
metal_paste = findTechAct("metallization paste production, back side", "RER")
copper = findTechAct('copper production, primary', "RoW")

# Copy and update mateal paste with copper
metal_paste_copper = copyActivity(metal_paste, 'metal paste, copper')
metal_paste_copper.updateExchanges({'silver' : dict(input=copper, name="copper")})
```

```{python}
printAct(metal_paste_copper)
```

# Silicon solar grade manufacturing

In this section, the main modification implemented is the change of the electrcity intensity used for the manufacturing of the solar grade.

```{python}
silicon_elec_intensity = newFloatParam(
    "silicon_elec_intensity", 
    default=30, min=11, max=110,  
    label="silicon electricity intensity", 
    label_fr="intensité électrique pour silicium", 
    group="manufacturing", 
    unit="kWh/kg")
```

```{python}
silicon = findTechAct('silicon production, solar grade, modified Siemens process', 'RER')
silicon_adjusted = copyActivity(silicon, "silicon production adjusted")

# Delete hydroelectricy, for not counting it twice
silicon_adjusted.updateExchanges(
    {
        'electricity, high voltage#RoW' : None,
        'electricity, high voltage#RER' : silicon_elec_intensity})
# Replace elec with elec switch, and update amount as a parameter
silicon_adjusted.substituteWithDefault('electricity, high voltage#RER', elec, elec_switch)
```

```{python}
printAct(silicon, silicon_adjusted, silicon_elec_intensity=40, elec_switch=None)
```

```{python}
multiLCAAlgebric([silicon, silicon_adjusted], impacts, elec_switch=None, silicon_elec_intensity=40)
```

# Casting Dataset 

Let's remove the use of silicon electronics grade (it was significant when the world silicon production was relatively low, nowadays this volume can be neglected compared to the level reached by the solar industry).
Let's remove also silicon solar grade as it is directly call by the wafer dataset and also electricity that is already accounted in the amount of electricity for solar grade manufacturing.
As a consequence, only chemicals, the factory and ceramic will be left and this dataset will complement the silicon solar grade dataset and both will be called for the wafer dataset.

```{python}
silicon_casting = findTechAct('silicon production, multi-Si, casted', 'RoW')

silicon_casting_adjusted = copyActivity(silicon_casting, 'silicon casting adjusted')

silicon_casting_adjusted.updateExchanges({
    'silicon,*' : None,
    'electricity, medium voltage*' : None})
```

```{python}
printAct(silicon_casting, silicon_casting_adjusted)
```

```{python}
multiLCAAlgebric([silicon_casting, silicon_casting_adjusted], impacts)
```

# Wafer manufacturing

In this section, some modifications were integrated by creating new datasets related mainly to the emerging practices in the cutting processes: 6 new datasets were created to serve this purpose.
On one hand, 2 of them (SiC recycled and TEG recycled) are related to the advancements of the traditional cutting process (loose abrasive slurry). The advancement of their recycling has resulted in the use of their recycled material recovered.
On another hand, the 4 new datasets are created to represent 1 meter of wire used in the emerging technology: the diamond wiring.


## Cutting Process

### SiC, Recycled

```{python}
silicon_carbide = findTechAct('silicon carbide production', 'RER')
silicon_carbide_recycled = copyActivity(silicon_carbide, 'silicon carbid adjusted', withExchanges=False)
silicon_carbide_recycled.addExchanges({
    findTechAct('market group for electricity, medium voltage', 'ENTSO-E') : 0.78571,
    findTechAct('market for transport, freight, lorry, unspecified', 'GLO') : 0.2625,
    findTechAct('market for silicone factory') : 1e-11,
    findBioAct('Heat, waste', categories=['air']) : 2.8286,
    findTechAct('market for waste, from silicon wafer production, inorganic') : -0.042857,
    findTechAct('treatment of spent antifreezer liquid, hazardous waste incineration', 'CH') : -0.071429,
    findTechAct('market for sludge, pig iron production', 'Europe without Switzerland') : -0.13571,
})
```

```{python}
printAct(silicon_carbide, silicon_carbide_recycled)
```

```{python}
multiLCAAlgebric([silicon_carbide, silicon_carbide_recycled], impacts)
```

### TEG, Recycled

FIXME : This model is wrong, it is a pure copy-paste of SiC recycled.

```{python}
teg = findTechAct(code='85c5a45f05a8e40c76aebf8a4dbdc3ad')
teg_recycled = copyActivity(teg, "TEG recycled", withExchanges=False)

teg_recycled.addExchanges({
    findTechAct('market group for electricity, medium voltage', 'ENTSO-E') : 0.78571,
    findTechAct('market for transport, freight, lorry, unspecified', 'GLO') : 0.2625,
    findTechAct('market for silicone factory') : 1e-11,
    findBioAct('Heat, waste', categories=['air']) : 2.8286,
    findTechAct('market for waste, from silicon wafer production, inorganic') : -0.042857,
    findTechAct('treatment of spent antifreezer liquid, hazardous waste incineration', 'CH') : -0.071429,
    findTechAct('market for sludge, pig iron production', 'Europe without Switzerland') : -0.13571,
})
```

```{python}
multiLCAAlgebric([teg, teg_recycled], impacts)
```

### Diamond Wiring

All the following datasets are based on Isabella Bianco thesis (2018) in which she analyzed the cutting processes in details. It was essential to integrate these datasets to elaborate the dataset of the wire which will be used for the cutting process according to the emerging diamond wiring technology.

#### Tungstene

```{python}
tungstene_carbide = copyActivity(silicon_carbide, "tungstene carbide", withExchanges=False)

tungstene_carbide.addExchanges({
    findTechAct('market for sodium hydroxide*') : 1.49,
    findTechAct('aluminium sulfate production, powder', 'RER') : 0.071,
    findTechAct('sodium sulfide production') : 0.044,
    findTechAct('magnesium sulfate production', 'RER') : 0.027,
    findTechAct('market for ammonia, liquid', 'RER') : 0.106,
    findTechAct('market for soda ash, dense') : 1.21,
    findTechAct('sulfuric acid production', 'RER') : 1.24,
    findTechAct('market group for electricity, medium voltage', 'ENTSO-E') : 111.16,
    findTechAct('hydrogen sulfide production', 'RER') : 0.0076,
    findTechAct('market for nitrogen, liquid', 'RER') : 1.65,
    findTechAct('market for hydrogen, liquid', 'RER') : 0.32,
    findTechAct('market for tap water', 'RoW') : 2.84,
    findTechAct('carbon black production') : 0.13,
})
    
```

```{python}
multiLCAAlgebric(tungstene_carbide, impacts)
```

```{python}
printAct(tungstene_carbide)
```

```{python}
multiLCAAlgebric(tungstene_carbide, impacts)
```

#### Diamond powder

```{python}
diamond_powder_ori = findTechAct('sodium percarbonate production, powder', 'RER')
diamond_powder = copyActivity(diamond_powder_ori, "Diamond powder",  withExchanges=False)
diamond_powder.addExchanges({
    findTechAct("market for electricity, medium voltage", "RoW") : 840,
    findTechAct("graphite production", "RER") : 1,
    findTechAct("transport, freight, sea, transoceanic ship") : 170,
    findTechAct("transport, freight, lorry 16-32 metric ton, EURO4", "RER") : 0.53,
})
```

```{python}
printAct(diamond_powder)
```

```{python}
multiLCAAlgebric(diamond_powder, impacts)
```

#### Sintered diamond bead

```{python}
sintered_diamond_ori = findTechAct("polymethyl methacrylate production, beads", "RER")

sintered_diamond = copyActivity(sintered_diamond_ori, "sintered diamond bead, for quarrying", withExchanges=False)
sintered_diamond.addExchanges({
    findTechAct("market group for electricity, medium voltage", "ENTSO-E") : 0.1,
    findTechAct("market for steel, unalloyed") : 0.003,
    findTechAct("market for cobalt") : 7e-08,
    findTechAct("market for copper") : 2.1e-07,
    findTechAct("market for pig iron") : 3.5e-07,
    findTechAct("market for nickel, 99.5%") : 2.1e-08,
    tungstene_carbide : 3.5e-08,
    diamond_powder : 2e-05,
    findTechAct('polymethyl methacrylate production, beads', "RER") :  2e-05,
    findTechAct("cobalt production") : 5e-05,
    findTechAct("market for silver") : 2.1e-04,
    findTechAct("market for nitrogen, liquid", "RER") : 0.0323, 
    findTechAct("market for hydrogen, liquid", "RER") : 9e-04, 
})

sintered_diamond.setOutputAmount(0.004)
```

```{python}
printAct(sintered_diamond)
```

```{python}
multiLCAAlgebric(sintered_diamond, impacts)
```

#### sintered diamond wire, steel

```{python}
act_ori = findTechAct('wire drawing, steel', 'RER')
sintered_diamond_wire = copyActivity(act_ori, "sintered diamond wire, steel", withExchanges=False)

sintered_diamond_wire.addExchanges({
    sintered_diamond : 0.0427,
    findTechAct("market group for electricity, medium voltage", "ENTSO-E") : 0.9, 
    findTechAct("wire drawing, steel", "RER") : 0.095, 
    findTechAct("wire drawing, steel", "RER") : 0.095, 
    findTechAct("polyurethane production, flexible foam", "RER") : 0.15, 
    findTechAct("transport, freight, lorry 16-32 metric ton, EURO4", "RER") : 0.003, 
    findTechAct("market for waste plastic, mixture", "Europe without Switzerland") : 0.045, 
})
```

```{python}
printAct(sintered_diamond_wire)
```

```{python}
multiLCAAlgebric(sintered_diamond_wire, impacts)
```

## Wafer 

This function generates an inventory of 1 m² of wafer production. 
    The initial amount of electricity (8 kWh/m²) is adjusted (to 20 kWh/m2 as per KBOB:2016) considering the possibility 
    to be improved (by using less) using manufacturing_efficiency_gains parameter (expressed in fraction/percentage).
    The electricity dataset can be also controlled using the elec_dataset parameter.
    The wafer solar grade used is the wafer solar grade adjusted (that considered the progress in solar grade wafer production),
    the amount of wafer is also adjusted considering the wafer thickness decreasing with the technical progress and evolution 
    of cutting processes with less kerf loss. manufacturing_efficiency_gains and kerf loss are expressed in fraction.
    wafer thickness is expressed in micrometer.
    SiC amount is adjusted from 2.63 kg (Ecoinvent 3.4) to 2.02988 kg (KBOB:2016) in total of which a certain amount (69.4%) 
    is produced from a recycled process with the possibility to modify it. SiC_recycled_share is the amount of recycled SiC
    expressed in fraction/percentage.
    TEG amount is adjusted from 2.71 kg (Ecoinvent 3.4) to 2.16548 kg (KBOB:2016) in total of which a certain amount (89.9%) 
    is produced from a recycled process with the possibility to modify it. TEG_recycled_share is the amount of recycled TEG
    expressed in fraction/percentage.
    Since the Diamond wiring technology is emerging, hence an added boolean parameter is added related to the added/omitted
    amount of SiC, TEG, diamond wire, and water.

```{python}
# Parameters
diamond_wiring = newBoolParam(
    "diamond_wiring", False, 
    group="manufacturing",
    label="diamond wiring",
    label_fr="sciage diamant") 

wafer_thickness = newFloatParam(
    "wafer_thickness", 
    default=190, min=128, max=190,
    group="manufacturing",
    label="wafer tickness", 
    label_fr="épaisseur wafer",
    unit="µm")

kerf_loss = newFloatParam(
    "kerf_loss", 0.44, min=0.20, max=0.50,
    group="manufacturing", 
    label="kerf loss", 
    label_fr="perte de découpe", 
    unit="fraction")

sic_recycled_share = newFloatParam(
    "sic_recycled_share", 
    0.694, min=0.6, max=0.9, 
    group="manufacturing",
    label="recycled SiC", 
    label_fr="part de SiC recyclé", 
    unit="fraction")

teg_recycled_share = newFloatParam(
    "teg_recycled_share", 
    0.899, min=0.528, max=0.9, 
    group="manufacturing",
    label="recycled TEG", 
    label_fr="part de TEG recyclé", 
    unit="fraction")

manufacturing_efficiency = newFloatParam(
    "manufacturing_efficiency", 
    0, min=0, max=1, 
    group="manufacturing",
    label="wafer efficiency gain",
    label_fr="gain d'efficacité wafer", 
    description="Manufacturing efficiency gain (elec for wafer)", unit="fraction")

# Root activities
natural_gas = findTechAct(in_name="heat production, natural gas, at industrial furnace >100kW", loc="Europe without Switzerland")

# Formulas 
sili_casting_amount = wafer_thickness * 1e-6 * 2328 / (1 - kerf_loss)
non_diamond_wiring = 1 - diamond_wiring


# Copy Wafer
wafer = findTechAct("multi-Si wafer production", "RER")
wafer_adjusted = copyActivity(wafer, "Wafer adjusted")

# Update wafer
wafer_adjusted.updateExchanges({
    'silicon, multi-Si, casted' : dict(
        input = silicon_adjusted, 
        amount = sili_casting_amount, 
        name='silicon production, adjusted'),  
    'tap water' : old_amount + diamond_wiring * 98.94,
    'silicon carbide' : non_diamond_wiring * 2.02988 * (1 - sic_recycled_share),
    'triethylene glycol' : non_diamond_wiring * 2.16548 * (1 - teg_recycled_share),
})

wafer_adjusted.addExchanges({
    # Diamond wiring (see also Tap water updated above)
    # sintered_diamond : diamond_wiring * 0.0006075,
    sintered_diamond_wire :  diamond_wiring * 0.0006075,
    
    # Non -diamond wiring
    silicon_carbide_recycled : non_diamond_wiring * 2.02988 * sic_recycled_share,
    teg_recycled : non_diamond_wiring * 2.16548 * teg_recycled_share,
    
    silicon_casting_adjusted : sili_casting_amount,
    
    # Adding the 4 MJ natural gas used for the wafer as proposed by KBOB
    natural_gas : 4 
})

# Adjusting the amount of electricity used
wafer_adjusted.substituteWithDefault(
    'electricity, medium voltage', 
    elec, elec_switch,
    amount=20 * (1 - manufacturing_efficiency))
```

```{python}
#printAct(wafer_adjusted, 
#         sic_recycled_share=0.4,
#        teg_recycled_share=0.3,
#        diamond_wiring=1,
#        manufacturing_efficiency=0.2,
#        kerf_loss=0.50,
#        wafer_thickness=240,
#        elec_switch=None,
#        silicon_elec_intensity=40)

printAct(wafer, wafer_adjusted, 
         sic_recycled_share=0,
        teg_recycled_share=0,
        diamond_wiring=1,
        manufacturing_efficiency=0,
        kerf_loss=0.50,
        wafer_thickness=240,
        elec_switch=None,
        silicon_elec_intensity=40)
```

```{python}
multiLCAAlgebric([wafer, wafer_adjusted, silicon_casting_adjusted, silicon_carbide_recycled, silicon_adjusted], 
        impacts, 
        sic_recycled_share=0,
        teg_recycled_share=0,
       diamond_wiring=1,
        manufacturing_efficiency=0,
        kerf_loss=0.50,
        wafer_thickness=240,
        elec_switch=None,
        silicon_elec_intensity=40)
```

```{python}
multiLCAAlgebric([wafer, wafer_adjusted], 
        impacts, 
        sic_recycled_share=0.694,
        teg_recycled_share=0.899,
        diamond_wiring=0,
        manufacturing_efficiency=0,
        kerf_loss=0.44,
        wafer_thickness=200,
        elec_switch=None,
        silicon_elec_intensity=40)
```

```{python}
printAct(wafer, wafer_adjusted,
         sic_recycled_share=0.694,
        teg_recycled_share=0.899,
        diamond_wiring=0,
        manufacturing_efficiency=0,
        kerf_loss=0.44,
        wafer_thickness=200,
        elec_switch=None,
        silicon_elec_intensity=40)
```

# PV Cell manufacturing

```{python}
# Params

silver_amount = newFloatParam(
    "silver_amount", 
    9.6, min=2, max=9.6, 
    group="manufacturing",
    label="silver amount",
    label_fr="teneur en argent",
    description="Silver amount for PV cell", unit="g/m²")

cell_init = findTechAct('photovoltaic cell production, multi-Si wafer', 'RER')
cell_adjusted = copyActivity(cell_init, 'photovoltaic cell production, multi-Si wafer - adjusted')

#Adapting the amount of Silver used for the metallic contact
#By default, for the front side : 7.4 g/m² Silver based paste corresponding to 6.2 g/m² of Ag (84% Silver)
#By default, for the back side : 4.9 g/m² Silver based paste corresponding to 3.3 g/m² of Ag (67% Silver)
#An additional 0.7 g of Ag is used is anyway considered for the panel.
    
#Adding copper paste used to substitute the amount of Silver used.
#The amount of copper is calculated considering the difference of conductivity between Ag and Cu
#Conductiviy of Ag = 6.3e7 S/m, Cu = 5.96e7 S/m at 20°C

# Define Max with abs() for later vector processing in numpy (sympy.Max is badly transformed)
def Max(a, b) :
    return (a + b + abs(a - b)) / 2


front_silver_amount = Max(7.4e-3 * (silver_amount - 0.7)  / (6.2 + 3.3), 0)
new_front_silver_amount = 0.84 * front_silver_amount

back_silver_amount = Max(4.9e-3 * (silver_amount - 0.7)  / (6.2 + 3.3), 0)
new_back_silver_amount = 0.67 * back_silver_amount

copper_amount = Max(1/0.67 * 6.3e7 / 5.96e7 * ( 9.6e-3 -(new_front_silver_amount + new_back_silver_amount)), 0)

new_copper_amount = 0.67 * copper_amount

cell_adjusted.updateExchanges({
    'metallization paste, front side' : front_silver_amount,
    'metallization paste, back side': back_silver_amount,
    # 'metallization paste production, back side, copper' : copper_amount, # FIXME ! Was bugged in current model, not added at all
    'multi-Si wafer' : dict(input=wafer_adjusted)
})

cell_adjusted.substituteWithDefault(
    'electricity, medium voltage', 
    elec, elec_switch,
    amount=30.243 * (1 - manufacturing_efficiency))
```

```{python}
printAct(
    cell_adjusted, 
    sic_recycled_share=0,
    teg_recycled_share = 0,
    diamond_wiring = 1,
    manufacturing_efficiency = 0,
    kerf_loss = 0.5, 
    wafer_thickness = 240,
    silver_amount = 11.2,
    silicon_elec_intensity = 110+19.5,
    elec_switch = None)
```

```{python}
multiLCAAlgebric(
    [cell_init, cell_adjusted], 
    impacts,
    sic_recycled_share=0,
    teg_recycled_share = 0,
    diamond_wiring = 1,
    manufacturing_efficiency = 0,
    kerf_loss = 0.5, 
    wafer_thickness = 240,
    silver_amount = 11.2,
    silicon_elec_intensity = 110+19.5,
    elec_switch = None)
```

# PV panel 

```{python}
# Params 
recycling_rate_alu = newFloatParam(
    "recycling_rate_alu", 
    0.92, min=0.56, max=1, 
    group="recycling",
    label="recycling rate for aluminium",
    label_fr="taux de recyclage aluminium",

    unit="fraction")

recycling_rate_cu = newFloatParam(
    "recycling_rate_cu", 
    0.75, min=0.44, max=1, 
    group="recycling",
    label="recycling rate for copper",
    label_fr="taux de recyclage cuivre",
    unit="fraction")

recycling_rate_glass = newFloatParam(
    "recycling_rate_glass", 
    0.9, min=0.6, max=1, 
    group="recycling",
    label="recycling rate for glass",
    label_fr="taux de recyclage verre",
    unit="fraction")

electricity_recycling = newFloatParam(
    "electricity_recycling", 
    50, min=50, max=100, 
    group="recycling",
    label="electricity recycling",
    label_fr="électricité recyclage",
    description="elec used for recycling", unit="kWh/t")

heat_recycling = newFloatParam(
    "heat_recycling",
    76, min=75, max=150, 
    group="recycling",
    label="heat for recycling",
    label_fr="chaleur recyclage",
    description="Heat for recycling", unit="MJ/t")

glass_thickness = newFloatParam(
    "glass_thickness", 
    4, min=2, max=4,
    group="manufacturing",
    label="glass tickness",
    label_fr="épaisseur de verre",
    unit="mm") 

# Activities
scrapGlass = findTechAct('market for waste glass sheet', 'Europe without Switzerland')
scrapAlu = findTechAct('market for scrap alu*', 'Europe without Switzerland')
scrapCopper = findTechAct('market for scrap copper*', 'Europe without Switzerland')
heat_for_recycling = findTechAct('heat and power co-generation, biogas, gas engine', 'RoW', unit='megajoule')

# Base activity
panel_init = findTechAct('photovoltaic panel production, multi-Si wafer', 'RER')

# Amount to recycle
amount_copper = new_copper_amount + panel_init.getAmount('copper')
amount_glass = panel_init.getAmount('solar glass, low-iron')
amount_alu =  cell_adjusted.getAmount('Aluminium') + panel_init.getAmount('aluminium alloy, AlMg3')

# Copy / update activity
panel_adjusted = copyActivity(panel_init, 'photovoltaic panel production, multi-Si wafer - adjusted')

panel_adjusted.addExchanges({
    scrapAlu : amount_alu * recycling_rate_alu,
    scrapCopper : amount_copper * recycling_rate_cu,
    scrapGlass : amount_glass * recycling_rate_glass,
    elec : dict(name='elec for recycling', amount = electricity_recycling * (20e-3/1.6)),
    heat_for_recycling : heat_recycling * (20e-3/1.6) / 3.6,
})

panel_adjusted.updateExchanges({
    'aluminium alloy, AlMg3' : alu_adjusted,
    'solar glass, low-iron' : glass_thickness * 2.5 * 1,
    'tempering, flat glass' : glass_thickness * 2.5 * 1,
    'photovoltaic cell, multi-Si wafer' : cell_adjusted,
})

panel_adjusted.substituteWithDefault('electricity, medium voltage', elec, elec_switch)

```

```{python}
multiLCAAlgebric(
    [panel_init, panel_adjusted, alu_adjusted, wafer_adjusted], 
    impacts,
    sic_recycled_share=0,
    teg_recycled_share = 0,
    diamond_wiring = 1, 
    glass_thickness = 4, 
    elec_switch = None,
    manufacturing_efficiency = 0, 
    kerf_loss = 0.44 - 0.15,
    wafer_thickness = 200, 
    silver_amount = 9.6,
    silicon_elec_intensity = 40, 
    recycling_rate_alu = 0.96, 
    recycling_rate_cu = 0.75, 
    recycling_rate_glass = 0.9,
    electricity_recycling = 50, 
    heat_recycling = 76,
    share_recycled_aluminium=0.3)
```

```{python}
printAct(
    panel_init,
    panel_adjusted,
    sic_recycled_share=0,
    teg_recycled_share = 0,
    diamond_wiring = 1, 
    glass_thickness = 4, 
    elec_switch = None,
    manufacturing_efficiency = 0, 
    kerf_loss = 0.5,
    wafer_thickness = 240, 
    silver_amount = 11.2,
    silicon_elec_intensity = 40, 
    recycling_rate_alu = 0, 
    recycling_rate_cu = 0, 
    recycling_rate_glass = 0,
    electricity_recycling = 0, 
    heat_recycling = 0,
    share_recycled_aluminium=0.3)

```

# Full PV installation

```{python}
# Tech datasets
diesel = findTechAct('market for diesel, burned in building machine')

# Transport datasets
transport_car = findTechAct('transport, passenger car, large size, petrol, EURO 5', 'RER')
transport_van = findTechAct('transport, freight, light commercial vehicle', 'Europe without Switzerland')
transport_lorry = findTechAct('lorry, all sizes, EURO6*', 'RER')
transport_train = findTechAct('transport, freight train, electricity', 'RoW')
transport_sea = findTechAct('transport, freight, sea, transoceanic ship')
```

```{python}
# New params
module_efficiency =  newFloatParam(
    "module_efficiency", 
    default=0.175, min=0.15, max=0.22,
    group="installation", 
    label="module efficiency",
    label_fr="efficacité module",
    unit="kWp/m²")

inverter_lifetime = newFloatParam(
    "inverter_lifetime", 
    group="production",
    label="inverter lifetime",
    label_fr="durée de vie onduleur",
    default=15, min=10, max=30,
    unit="year")

inverter_weight_per_p = newFloatParam(
    "inverter_weight_per_p", 
    default=2, min=1, max=6, 
    group="installation",
    label="inverter weight per P",
    label_fr="poids onduleur par puissance",
    unit="kg/kWp")

d_lorry = newFloatParam(
    "d_lorry", 
    default=1020, min=40, max=2000, 
    unit="km",
    group="transport", 
    label="distance by lorry",
    label_fr="distance en camion")

d_train = newFloatParam(
    "d_train", 
    default=350, min=0, max=600,
    unit="km",
    group="transport", 
    label="distance by train",
    label_fr="distance en train")

d_sea = newFloatParam(
    "d_sea", 
    default=4000, min=0, max=6000,
    unit="km",
    group="transport", 
    label="distance by ships",
    label_fr="distance en bateau")

# Alias for ground system
is_ground_system = 1 - is_roof_system
```

```{python}
surface_module = 1.6 #Module surface in m²
P_module = module_efficiency * surface_module * 1000
surface  = P*1e3 / P_module * surface_module
```

```{python}
pvInstall = newActivity("Full pv installation", "unit")

inverter_weight = inverter_weight_per_p * P

# PV panel weigths 20kg 
total_mass_tons = 1e-3 * ((surface / surface_module) * 20 + unit_3kW_equiv * 33 + inverter_weight * pv_lifetime / inverter_lifetime)

pvInstall.addExchanges({
    mounting_system_modified :  surface,
    
    # Adding diesel burned in machine for site preparation
    # 7673 MJ were accounted for the 570 kWp power plant
    diesel : is_ground_system * P/570 * 7673, 
    
    # Number of equivalent unit of 3kW elec install
    electrical_installation_3kW : unit_3kW_equiv, 
    
    
    inverter_per_kg : inverter_weight * pv_lifetime / inverter_lifetime,
    panel_adjusted : surface,
    
    #for engineers for feasability study (100 - 200 km)
    transport_car : 150,
    
    #for maintenance
    transport_van : 1e-3 * (inverter_weight) * 100 * pv_lifetime / inverter_lifetime,
    
    transport_lorry : total_mass_tons * d_lorry,
    transport_sea : total_mass_tons * d_sea,
    transport_train : total_mass_tons * d_train
})
```

```{python}
printAct(pvInstall, 
        P = 10, 
        module_efficiency = 0.125, 
        is_roof_system = 1,
        share_recycled_aluminium = 0.27, 
        elec_switch = None, 
        inverter_weight_per_p = 2,   
        inverter_lifetime = 15,
        pv_lifetime = 30,
        glass_thickness = 4,
        recycling_rate = 0,
        manufacturing_efficiency = 0,
        kerf_loss = 0.44, 
        wafer_thickness = 200, 
        silver_amount = 9.6, 
        silicon_elec_intensity = 30+10,
        sic_recycled_share=0.694, 
        teg_recycled_share = 0.899, 
        diamond_wiring=False, 
        d_lorry = 1020, 
        d_train = 350, 
        d_sea = 4000,
        recycling_rate_alu = 0.96, 
        recycling_rate_cu = 0.75,
        recycling_rate_glass = 0.9,
        electricity_recycling = 50,
        heat_recycling = 76)
```

```{python}
multiLCAAlgebric(
    [pvInstall, panel_adjusted, wafer_adjusted], 
    impacts,
    P = 10, 
    module_efficiency = 0.125, # 0.125 corresponds to 200 kWc per module (1.6 m2) 
    is_roof_system = 1,
    share_recycled_aluminium = 0.27, 
    elec_switch = None, 
    inverter_weight_per_p = 2, # Default value in PARASOL model
    inverter_lifetime = 15,
    pv_lifetime = 30,
    glass_thickness = 4,
    recycling_rate = 0,
    manufacturing_efficiency = 0,
    kerf_loss = 0.44, 
    wafer_thickness = 200, 
    silver_amount = 9.6, 
    silicon_elec_intensity = 30+10,
    sic_recycled_share=0.694, 
    teg_recycled_share = 0.899, 
    diamond_wiring=0, 
    d_lorry = 1020, 
    d_train = 350, 
    d_sea = 4000,
    recycling_rate_alu = 0.96, 
    recycling_rate_cu = 0.75,
    recycling_rate_glass = 0.9,
    electricity_recycling = 50,
    heat_recycling = 76,
    mounting_system_weight=5,
    ground_coverage_ratio=0.4)
```

```{python}
printAct(
    wafer, wafer_adjusted,
        P = 10, 
        module_efficiency = 0.125, 
        is_roof_system = 1,
        share_recycled_aluminium = 0.27, 
        elec_switch = None, 
        inverter_weight_per_p = 2,   
        inverter_lifetime = 15,
        pv_lifetime = 30,
        glass_thickness = 4,
        recycling_rate = 0,
        manufacturing_efficiency = 0,
        kerf_loss = 0.44, 
        wafer_thickness = 200, 
        silver_amount = 9.6, 
        silicon_elec_intensity = 30+10,
        sic_recycled_share=0.694, 
        teg_recycled_share = 0.899, 
        diamond_wiring=0, 
        d_lorry = 1020, 
        d_train = 350, 
        d_sea = 4000,
        recycling_rate_alu = 0.96, 
        recycling_rate_cu = 0.75,
        recycling_rate_glass = 0.9,
        electricity_recycling = 50,
        heat_recycling = 76)
```

# Comparison with Ecoinvent model

```{python}
# Impact model, per kWp
impact_model_per_kWp = newActivity("impact model per kWp installed", unit="unit per kWh", exchanges={
    pvInstall: 1 / P
})
```

```{python}
pv_roof_init = findTechAct('photovoltaic slanted-roof installation, 3kWp, multi-Si, panel, mounted, on roof', 'RoW')
```

```{python}
res=multiLCAAlgebric(
    [(pvInstall, 1/3), (pv_roof_init, 1/3)], 
    impacts, 
        P = 3, 
        module_efficiency = 0.1312, # Corresponds to module of 210 w 
        is_roof_system = 1,
        share_recycled_aluminium = 0, 
        elec_switch = "row", 
        inverter_weight_per_p = 6.16, # 18.5 Kg for 3 kWp   
        inverter_lifetime = 12.5,
        pv_lifetime = 30,
        glass_thickness = 4,
        recycling_rate = 0,
        manufacturing_efficiency = 0,
        kerf_loss = 0.5, 
        wafer_thickness = 240, 
        silver_amount = 11.2, 
        silicon_elec_intensity = 110+19.5,
        sic_recycled_share=0, 
        teg_recycled_share = 0, 
        diamond_wiring=0, 
        d_lorry = 0, 
        d_train = 0, 
        d_sea = 0,
        recycling_rate_alu = 0, 
        recycling_rate_cu = 0,
        recycling_rate_glass = 0,
        electricity_recycling = 0,
        heat_recycling = 0)
res.transpose()
```

```{python}
res=printAct(
    pvInstall,
        P = 3, 
        module_efficiency = 0.1312, # Corresponds to module of 210 w 
        is_roof_system = 1,
        share_recycled_aluminium = 0, 
        elec_switch = "row", 
        inverter_weight_per_p = 6.16, # 18.5 Kg for 3 kWp   
        inverter_lifetime = 12.5,
        pv_lifetime = 30,
        glass_thickness = 4,
        recycling_rate = 0,
        manufacturing_efficiency = 0,
        kerf_loss = 0.5, 
        wafer_thickness = 240, 
        silver_amount = 11.2, 
        silicon_elec_intensity = 110+19.5,
        sic_recycled_share=0, 
        teg_recycled_share = 0, 
        diamond_wiring=0, 
        d_lorry = 0, 
        d_train = 0, 
        d_sea = 0,
        recycling_rate_alu = 0, 
        recycling_rate_cu = 0,
        recycling_rate_glass = 0,
        electricity_recycling = 0,
        heat_recycling = 0)
```

# PV Production

We do not compute PV production here. Just take it as a parameter, together with performance factor of the panel.


```{python}
productible = newFloatParam(
    "productible", 
    default=1200, min=800, max=1600, 
    group="production",
    label="productible per year",
    label_fr="productible par an ",
    unit="kWh/kWp/year")

degradation_rate = newFloatParam(
    "degradation_rate", 
    default=0.005, min=0.005, max=0.008, 
    group="production",
    label="degratation rate", 
    label_fr="taux de dégradation",
    unit="fraction/year")

# productible over lifetime
productible_life = productible * (1 - (1-degradation_rate)**pv_lifetime) / degradation_rate

impact_model_per_kWh = newActivity("impact model per kWh produced over lifetime", unit="unit per kWh", exchanges={
    pvInstall: 1 / (performance_ratio * productible * P * pv_lifetime)
})


```

# List of all parameters

Display a table of all parameters defined above

```{python}
params = [[param.group, param.label_fr, param.default, param.min, param.max, param.unit] for param in param_registry().values()]
groups=['manufacturing', 'transport', 'installation', 'production', 'recycling']
sorted_params=sorted(params, key=lambda p : groups.index(p[0]))
HTML((tabulate(sorted_params, tablefmt="html", headers=["Phase", "param", "default", "min", "max", "unit"])))

```

# Statistics : One at a time

```{python}
oat_dashboard_interact(impact_model_per_kWp, impacts)
```

```{python}
params = [[param.group, param.name, param.default, param.min, param.max, param.unit] for param in param_registry().values()]
groups=['manufacturing', 'transport', 'installation', 'production', 'recycling']
sorted_params=sorted(params, key=lambda p : groups.index(p[0]))
HTML((tabulate(sorted_params, tablefmt
               ="html", headers=["Phase", "param", "default", "min", "max", "unit"])))

```

```{python}
multiLCAAlgebric(impact_model_per_kWp, impacts, **{'elec_switch': 'row', 'share_recycled_aluminium': 0.27, 'P': 10, 'recycling_rate': 0.9, 'silicon_elec_intensity': 40, 'diamond_wiring': False, 'wafer_thickness': 200, 'kerf_loss': 0.44, 'sic_recycled_share': 0.694, 'teg_recycled_share': 0.899, 'manufacturing_efficiency': 0, 'silver_amount': 9.6, 'recycling_rate_alu': 0.92, 'recycling_rate_cu': 0.75, 'recycling_rate_glass': 0.9, 'electricity_recycling': 50, 'heat_recycling': 76, 'glass_thickness': 4, 'module_efficiency': 0.175, 'is_roof_system': 0, 'pv_lifetime': 30, 'inverter_lifetime': 15, 'inverter_weight_per_p': 2, 'd_lorry': 1020, 'd_train': 350, 'd_sea': 4000, 'productible': 1200, 'performance_ratio': 0.8})
```

```{python}
oat_matrix(impact_model_per_kWh, impacts)
```

# Statistics : Stochastics

```{python}
incer_stochastic_dasboard(impact_model_per_kWp, impacts)
```

```{python}
X, Y = res
median = binned_statistic(X[:, 4], Y, 'median', bins=10)
q10 = binned_statistic(X[:, 4], Y, lambda x : np.percentile(x, 10), bins=10)
q30 = binned_statistic(X[:, 4], Y, lambda x : np.percentile(x, 30), bins=10)
q70 = binned_statistic(X[:, 4], Y, lambda x : np.percentile(x, 70), bins=10)
q90 = binned_statistic(X[:, 4], Y, lambda x : np.percentile(x, 90), bins=10)

bincenters = np.mean(np.vstack([std.bin_edges[0:-1],std.bin_edges[1:]]), axis=0)

plt.fill_between(bincenters, q10.statistic, q90.statistic, color="blue", alpha=0.2)
plt.fill_between(bincenters, q30.statistic, q70.statistic, color="blue", alpha=0.3)
plt.plot(bincenters, median.statistic)
```

```{python}
import lib.utils as utils
problem, X, Y = utils._stochastics(impact_model_per_kWp, impacts, 1000)

```

```{python}
y = Y[Y.columns[2]]
```

```{python}
sob = sobol.analyze(problem, y.to_numpy(), calc_second_order=True)
```

```{python}
param_names=problem['names']
plt.figure(num=None, figsize=(12, 6), dpi=80, facecolor='w', edgecolor='k')
plt.bar(np.arange(len(param_names)), sob["ST"], 0.8)
plt.bar(np.arange(len(param_names)), sob["S1"], 0.8)
plt.xticks(np.arange(len(param_names)), param_names, rotation=90);
```

```{python}
utils._incer_stochastic_variations(impacts, Y)
```

```{python}

```
