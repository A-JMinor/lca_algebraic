---
jupyter:
  jupytext:
    formats: ipynb,Rmd
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.2'
      jupytext_version: 1.3.2
  kernelspec:
    display_name: Python 3
    language: python
    name: python3
---

```{python}
#pandas is a library for data manipulation and analysis.
import pandas as pd
#matplotlib is a plotting library and its numerical mathematics extension NumPy;
#matplotlib.pyplot is mainly intended for interactive plots and simple cases of programmatic plot
import matplotlib.pyplot as plt
import numpy as np
#brightway2 is a open source framework for life cycle assessment (LCA). 
import brightway2 as bw
#SciPy contains modules for optimization, linear algebra, integration, interpolation,
#special functions, FFT, signal and image processing, ODE solvers and other tasks.
from scipy.interpolate import InterpolatedUnivariateSpline
#there are a number of pre-defined styles provided by matplotlib: ggplot is one of them.
plt.style.use('ggplot')
#auto is to display the figures in an independant tab;
#it can be changed to inline to represent in the notebook itself
# %matplotlib inline
```

```{python}
bw.projects.current
```

```{python}
bw.projects.set_current('B_Publication')
bw.bw2setup()
bw.databases
```

```{python}
# Ecoinvent Db is loaded once and saved locally
fpei34 =  r'./ecoinvent 3.4_cutoff_ecoSpold02/datasets'
if 'ecoinvent 3.4 cut off' in bw.databases:
    print("Database has already been imported")
else:
    ei34 = bw.SingleOutputEcospold2Importer(fpei34, 'ecoinvent 3.4 cut off')
    ei34.apply_strategies()
    ei34.statistics()
    ei34.write_database()
```

```{python}
#this is where the current project is set and the databases are defined
eidb = bw.Database('ecoinvent 3.4 cut off')
bio3 = bw.Database('biosphere3')
```

```{python}
#to know the number of items in each databases
#should be 4246 when executed for the first time
len(bio3)
```

```{python}
#ecoinvent 3.4 database should be 14889 items at first
len(eidb)
```

The following model represents a cradle-to-grave parameterized model for the PV systems. It can be divided into 3 parts: 

1 - The first part entitled /Photovoltaic System/:
It is where all the suggested modifications and the set of parameters are created and executed
to change and update the original Ecoinvent 3.4 datasets. 
This part includes numerous subsections: each is related to a certain component or aspect
to finally end up with the last section entitled /final function generating inventories/
which defines the inventory of the system that will be analyzed.
Be careful when executing this part (should be line by line) to avoid duplication and matrix error!

2 - The second part entitled /Impact Analysis/:
It is where all the chosen methods are defined and prepared to calculate the environmental impacts
of the system.
N.B: if the user wants to check the results shown in part 1, he/she should execute part 2 before part 1 in order to get the results in the first part.

3- The third part entitled /PV Production/:
It is where the production of the system is calculated. This part includes all the operational and geographical parameters such as the irradiation, the performance ratio, the degradation rate, etc.

The others sections analyze different scenarios and simulations. 


As a recap, it must be noted that the purpose of this project is to conduct a Life Cycle Assessment (LCA) study of energy systems. In particular, the PV systems were modeled as an example on which to be based other applications and sectors.

The LCA stages include the raw material extraction, the manufactuing and assembly, the use, and the end-of-life including the transportation all the way. The list of parameters which were defined and modeled contribute to each of these stages.
The user will explore them gradually throughout the model and they are listed in the following paragraph.


########################################## Print #################################################

These 2 functions are created to display the datasets clearly

```{python}
############################## PRINT ###########################
#it displays the datasets in a dataframe (similarly to Simapro)
def print_data(act):
    print(act)
    df = pd.DataFrame(index = ['amount','unit','key'])
    for exc in act.exchanges():
        if exc['name'] in df.columns:
            df[exc['name']].loc['amount'] += exc.amount
        else:
            df[exc['name']] = [exc.amount, exc.unit, exc.input.key]
    return df.T
```

```{python}
def print_data2(act) :
    df = pd.DataFrame(index = ['amount','unit','key','type'])
    for (i,exc) in enumerate(act.exchanges()):
        df[str(bw.get_activity(exc.input.key))] = [exc.amount, exc.unit, exc.input.key,exc['type']]
    return df.T
```

# Part_1: Photovoltaic System


In this part, all the modifications are adopted according to the latest technological advancements and recommendations.
To ensure flexibility and consistency, the created functions are monitored by a set of input variables. These variables englobe both the technological and geographical parameters. It must be noted that the last 4 parameters are used in Part_3 of this notebook. The 30 paramaters can be listed as follows (the definition of each will be developed in the subsections):
- P
- P_module
  or module_efficiency
- roof
- share_recycled_aluminium
- elec_dataset
- inverter_weight
- inverter_lifetime
- PV_lifetime
- glass_thickness
- manufacturing_efficiency_gains
- kerf_loss
- wafer_thickness 
- silver_amount 
- Silicon_electricity_intensity
- d_lorry
- d_train
- d_sea
- recycling_rate
- electricity_recycling
- heat_recycling
- SiC_recycled_share
- TEG_recycled_share
- DW
- recycling_rate_alu
- recycling_rate_cu
- recycling_rate_gl
- irradiation
- PR
- degradation_rate
- orientation

All these parameters have a set default value defined in the following functions. 
These default values serve as an estimation for typical cases when there is lack of data / no knowledge.


## Electricity dataset


Because the case study is set in a European context, this parameter allow to unify the dataset used for some components/processes, if needed. Otherwise the user can stick to the one defined in Ecoinvent 3.4 database. 5 electricity mix choices were proposed as follows:

```{python}
elec_dataset_us = [act for act in eidb if 'market group for electricity, medium voltage' == act['name'] and 'US' in act['location']][0]
elec_dataset_us
```

```{python}
elec_dataset_eu = [act for act in eidb if 'market group for electricity, medium voltage' == act['name'] and 'ENTSO-E' == act['location']][0]
elec_dataset_eu
```

```{python}
elec_dataset_row = [act for act in eidb if 'market for electricity, medium voltage' == act['name'] and 'RoW' in act['location']][0]
elec_dataset_row
```

```{python}
elec_dataset_cn = [act for act in eidb if 'market for electricity, medium voltage' == act['name'] and 'CN-CSG' in act['location']][0]
elec_dataset_cn
```

```{python}
elec_dataset_fr = [act for act in eidb if 'market for electricity, medium voltage' == act['name'] and 'FR' == act['location']][0]
elec_dataset_fr
```

For a rest of the world study, use RoW dataset

```{python}
elec_dataset = elec_dataset_row
```

```{python}
#ATTENTION: In order to execute this cell, the first 2 cells of Part_2 should be executed
bw.calculation_setups['B_electricity_mix'] = {'inv': [{elec_dataset_us:1}, {elec_dataset_eu:1}, {elec_dataset_row:1}, {elec_dataset_cn:1}, {elec_dataset_fr:1}], 'ia': list_methods}
myMultiLCA = bw.MultiLCA('B_electricity_mix')
df_impact = pd.DataFrame(columns = list_methods, data = myMultiLCA.results)
df_impact
```

## Aluminium dataset


The aluminium dataset used for the mounting system and the PV panel frame is adjusted to account for the latest market practices of which the use of secondary/recycled aluminium has an important impact. The user has the flexibility to adjust the share of secondary aluminium according to his/her system.

```{python code_folding=c()}
#the original dataset is the one presented below
alu_original = [act for act in eidb if 'aluminium alloy production, AlMg3' == act['name']and 'RER' in act['location']][0]
alu_original
```

```{python code_folding=c()}
def generate_aluminium_alloy_dataset(share_recycled_aluminium = 0.27,
                                     elec_dataset = None):
    '''
    This function generates a dataset for aluminium alloy that will be used for mounting system and PV panel frame.
    The electricity and the amount of recycled aluminium can be adjusted using 
    the share_recycled_aluminium (expressed as a fraction/percentage) 
    and elec_dataset(representing a dataset) respectively.
    '''
    initial_dataset = 'aluminium alloy production, AlMg3'
    alu_adjusted = [act for act in eidb if 'aluminium alloy production, AlMg3 adjusted' == act['name']]
    
    if alu_adjusted == []:
        alu = [act for act in eidb if 'aluminium alloy production, AlMg3' in act['name']and 'RER' in act['location']][0]
        alu_adjusted = alu.copy()
        alu_adjusted['name'] = initial_dataset + ' adjusted'
        alu_adjusted['authors'] = 'Romain Besseau'
        alu_adjusted['comment'] = 'Dataset adjusted with the share of secondary aluminium used and the electricity mix used'
        
        #Adding secondary aluminium
        aluminium_scrap = [act for act in eidb if 'aluminium scrap, new, Recycled Content cut-off' in act['name']][0]

        new_exc = alu_adjusted.new_exchange(input = aluminium_scrap.key, name = aluminium_scrap['name'], 
                                            amount = 0, unit = 'kg', categories = '', type = 'technosphere')
        new_exc.save()
        
        for exc in alu_adjusted.exchanges():
            exc['output'] = alu_adjusted.key
            exc.save()
        
        alu_adjusted.save()        
        
    else:
        alu = [act for act in eidb if initial_dataset == act['name']][0]
        alu_adjusted = [act for act in eidb if initial_dataset + ' adjusted' == act['name']][0]
        
    # Amount of aluminium considered
    for exc in alu.exchanges():
        if exc['name'] == 'aluminium, cast alloy':
            aluminium_amount = exc.amount
            
    is_elec_ds = (elec_dataset != None)
    
    #Adjusting the amount of primary and secondary aluminium
    for exc in alu_adjusted.exchanges():
        if exc['name'] == 'aluminium, cast alloy':
            exc['amount'] = aluminium_amount * (1 - share_recycled_aluminium)
            exc.save()
        if exc['name'] == 'aluminium scrap, new, Recycled Content cut-off':
            exc['amount'] = aluminium_amount * (share_recycled_aluminium)
            exc.save()
        #Adjusting the electricity used for manufacturing
        if is_elec_ds:
            if exc['name'] == 'electricity, high voltage, aluminium industry':
                exc['input'] = elec_dataset.key
                exc.save()
        
    #alu_adjusted.save() 
                
    return alu_adjusted
```

```{python}
alu_adjusted = generate_aluminium_alloy_dataset(share_recycled_aluminium = 0.3,
                                     elec_dataset = None)
```

```{python}
alu_adjusted = [act for act in eidb if 'aluminium alloy production, AlMg3 adjusted' in act['name']][0]
alu_adjusted
```

```{python}
DF = pd.concat([print_data(alu_original),print_data(alu_adjusted)], axis = 1, keys = ['original', 'adjusted'])
DF
```

```{python}
#ATTENTION: In order to execute this cell, the first 2 cells of Part_2 should be executed
bw.calculation_setups['B_aluminium_dataset'] = {'inv': [{alu_original:1}, {alu_adjusted:1}], 'ia': list_methods}
myMultiLCA = bw.MultiLCA('B_aluminium_dataset')
df_impact = pd.DataFrame(columns = list_methods, data = myMultiLCA.results)
df_impact
```

```{python}
(5.73-4.44)/5.73*100
```

A share of secondary aluminium has been introduced. Secondary aluminium is much less energy intensive than the primary aluminium.


## Mounting system


The mounting structure can vary from one application to another: integrated to the building, concentrated systems, etc. Hence, the mounting systems were analyzed and compared in this section. The corresponding datasets include the integration of the adjusted aluminium as well.

```{python}
# 2 Mounting system are identified (Aluminium and stainless steel based)
ground_system = [act for act in eidb if 'photovoltaic mounting system production, for 570kWp open ground module' == act['name']][0]
print(ground_system)
roof_system = [act for act in eidb if 'photovoltaic mounting system production, for slanted-roof installation' == act['name'] and 'RER' in act['location']][0]
print(roof_system)
```

```{python}
# To check the difference between the roof-integrated and ground-mounted systems:
bw.calculation_setups['B_mounting_system'] = {'inv': [{ground_system:1}, {roof_system:1}], 'ia': list_methods}
#bw.calculation_setups[act['name']]
myMultiLCA = bw.MultiLCA('B_mounting_system')
myMultiLCA.results
df_impact = pd.DataFrame(columns = list_methods, data = myMultiLCA.results)
df_impact
```

```{python}
(100.54-60.58)/100.54*100
```

```{python}
#To ensure a uniform analysis, recycling should be added to the roof system like it was done for the ground system
#Let's start by adding recycling to the photovoltaic mounting system production, for slanted-roof installation
roof_system_with_recycling = [act for act in eidb if 'photovoltaic mounting system production, for slanted-roof installation with recycling' == act['name']]

if roof_system_with_recycling == []:
    roof_system =  [act for act in eidb if 'photovoltaic mounting system production, for slanted-roof installation' == act['name'] and 'RER' in act['location']][0]
    roof_system_with_recycling = roof_system.copy()
    roof_system_with_recycling['name'] = 'photovoltaic mounting system production, for slanted-roof installation with recycling'
    roof_system_with_recycling['authors'] = 'Romain Besseau'
    roof_system_with_recycling['comment'] = 'Copy of photovoltaic mounting system production, for slanted-roof installation with recycling activites added (scrap steel and scrap aluminium)'
    
    for exc in roof_system_with_recycling.exchanges():
        if exc['name'] == 'aluminium, wrought alloy':
            aluminium_amout = exc.amount
            scrap_aluminium = [act for act in eidb if 'market for scrap aluminium' in act['name'] and 'Europe' in act['location']][0]  
        
            new_exc = roof_system_with_recycling.new_exchange(input = scrap_aluminium.key, name = scrap_aluminium['name'], amount =  - aluminium_amout, unit = scrap_aluminium['unit'], type = 'technosphere')
            new_exc.save()
        
        if exc['name'] == 'steel, low-alloyed, hot rolled':
            steel_amout = exc.amount
            scrap_steel = [act for act in eidb if 'market for scrap steel' in act['name'] and 'Europe' in act['location']][0]  
        
            new_exc = roof_system_with_recycling.new_exchange(input = scrap_steel.key, name = scrap_steel['name'], amount =  - steel_amout, unit = scrap_steel['unit'], type = 'technosphere')
            new_exc.save()
        
    roof_system_with_recycling.save()

roof_system_with_recycling = [act for act in eidb if 'photovoltaic mounting system production, for slanted-roof installation with recycling' == act['name']][0]
roof_system_with_recycling
```

```{python}
roof_system_with_recycling = [act for act in eidb if 'photovoltaic mounting system production, for slanted-roof installation with recycling' == act['name']][0]
roof_system_with_recycling
```

```{python}

```

```{python}
print(roof_system['database'])
print_data(roof_system)
```

```{python}
list_methods = methods_no_LT
bw.calculation_setups['B_ground_mounting_systems'] = {'inv': [{roof_system:1},{roof_system_with_recycling:1}], 'ia': list_methods}
#bw.calculation_setups[act['name']]
myMultiLCA = bw.MultiLCA('B_ground_mounting_systems')
B_df_impact = pd.DataFrame(columns = list_methods, data = myMultiLCA.results)
B_df_impact
```

```{python}
def generate_mounting_system_dataset(aluminium_dataset = alu_adjusted, 
                                     initial_dataset = 'photovoltaic mounting system production, for slanted-roof installation with recycling'):
    '''
    This function generates an inventorie for 1 m² of mounting system either open ground or roof installed.
    The aluminium alloy adjusted dataset is used and the recycling rate can be adjusted.
    '''
    system_adjusted = [act for act in eidb if initial_dataset + ' adjusted' == act['name']]
    
    if system_adjusted == []: 
        system = [act for act in eidb if initial_dataset == act['name'] ][0]
        system_adjusted = system.copy()
        system_adjusted['name'] = initial_dataset + ' adjusted'
        system_adjusted['authors'] = 'Romain Besseau'
        system_adjusted['comment'] = 'Dataset adjusted with the share of secondary aluminium used and the recycling rate'
        
        #Changing the aluminium dataset to the adjusted one.
        for exc in system_adjusted.exchanges():
            if exc['name'] == 'aluminium, wrought alloy':
                exc['name'] = aluminium_dataset['name']
                exc['input'] = aluminium_dataset.key
                exc.save()           
        
        for exc in system_adjusted.exchanges():
            exc['output'] = system_adjusted.key
            exc.save()
        
        system_adjusted.save()        
        
    else:
        #system = [act for act in eidb if initial_dataset == act['name'] and 'RER' in act['location']][0]
        system_adjusted = [act for act in eidb if initial_dataset + ' adjusted' == act['name']][0]
            
    return system_adjusted
```

```{python}
roof_system_adjusted = generate_mounting_system_dataset(aluminium_dataset = alu_adjusted, 
                                     initial_dataset = 'photovoltaic mounting system production, for slanted-roof installation with recycling')
ground_system_adjusted = generate_mounting_system_dataset(aluminium_dataset = alu_adjusted, 
                                     initial_dataset = 'photovoltaic mounting system production, for 570kWp open ground module')
```

```{python}
roof_system_adjusted = [act for act in eidb if 'photovoltaic mounting system production, for slanted-roof installation with recycling adjusted' in act['name']][0]
print_data2(roof_system_adjusted)
```

```{python}
ground_system_adjusted = [act for act in eidb if 'photovoltaic mounting system production, for 570kWp open ground module adjusted' in act['name']][0]
print_data2(ground_system_adjusted)
```

```{python}
print_data(alu_adjusted)
```

```{python}
list_methods = methods_no_LT
bw.calculation_setups['B_roof_mounting_systems'] = {'inv': [{roof_system_adjusted:1},{ground_system_adjusted:1}], 'ia': list_methods}
#bw.calculation_setups[act['name']]
myMultiLCA = bw.MultiLCA('B_roof_mounting_systems')
B_df_impact = pd.DataFrame(columns = list_methods, data = myMultiLCA.results)
B_df_impact
```

After unifying the datasets and adding the adjusted aluminium for both, it can be seen that the roof_system (represented by the index 0) has less environmental impacts that the ground_system (represented by the index 1).


## Electrical installation


The datasets of the electrical installation (which represents the cables, fuse box, etc.) were compared in order to simplify the modeling of the system. The results show that one dataset can be used and interpolated according to the considered systems.

```{python}
#all the electrical installation datasets are represented below
act = [act for act in eidb if 'photovoltaics, electric installation' in act['name']]
act
```

```{python}
#Electric installation (cables, fuse box, lightning protection...) without the inverter
electrical_installation_3kW = [act for act in eidb if 'photovoltaics, electric installation for 3kWp module, at building' == act['name'] and 'RoW' in act['location']][0]
print(electrical_installation_3kW)
electrical_installation_570kW = [act for act in eidb if 'photovoltaics, electric installation for 570kWp module, open ground' == act['name']][0]
print(electrical_installation_570kW)
```

```{python}
#Creating a dataframe for input-output flow
df_ei3kW = print_data(electrical_installation_3kW)
df_ei3kW
```

```{python}
#Creating a dataframe for input-output flow
df_ei570kW = print_data(electrical_installation_570kW)
df_ei570kW 
```

```{python}
#In order to compare the datasets, the dataframes are concatenated
df_ei = pd.concat([df_ei3kW, df_ei570kW], axis = 1, keys = ['3 kW','570 kW'])
df_ei = df_ei.dropna()
df_ei
```

```{python}
# Analysing share ratio
df = df_ei.xs( 'amount', level = 1, axis = 1)
df = df.drop('wire drawing, copper')
df.loc['Total weight'] = df[df > 0].sum()
df['3 kW share'] = df['3 kW'] / df['3 kW'].loc['Total weight']
df['570 kW share'] = df['570 kW'] / df['570 kW'].loc['Total weight']
df
```

There is no significant evolution in the share of materials used for the system. The inventories will be extrapolated from  the 3 kW inventories and proportionaly to the weight of the electrical installation as calculated below.

```{python}
#Extrapolation of the electrical installation weight from 3kVA and 570kVA inventories
# 3 kW electrical installation weighs 33 kg, 570 kW electrical installation weighs 1570 kg
electrical_installation_weight = InterpolatedUnivariateSpline([3, 570], [33, 1570], k=1)
electrical_installation_weight(10)/33

unit_of_equivalent_3kW_electrical_installation = InterpolatedUnivariateSpline([3, 570], [33/33, 1570/33], k=1)

P = 10
unit_of_equivalent_3kW_electrical_installation(570)

```

This means that 1.575 unit of 3 kW electrical installation will be used as an equivalence of 10 kW power (which represents the power of the system).


## Inverter


Because many technological advancements were accomplished at the level of the inverter, this part compares the original datasets available in Ecoinvent 3.4 database, adapt industrial data based on SMA solar technology, and modify the datasets accordingly to meet the current trends and market specs.


### Creating and saving inventories

```{python}
#For information: Typical inverter outputs are 5 kW for private home rooftop plants, 
#10 – 20 kW for commercial plants (e.g., factory or barn roofs) 
#and 500 – 800 kW for use in PV power stations.
```

```{python}
list_act = [act for act in eidb if 'inverter production' in act['name'] and not 'car' in act['name']]
list_act
```

```{python}
#to know the old weight: the weight of 2500W inverter is 18.5 kg (Ecoinvent 3.4)
act = [act for act in eidb if 'inverter production, 2.5kW' in act['name'] and 'RER' in act['location']][0]
act['comment']
```

It can be seen that the total weight is 18.5 kg for a 2.5kW inverter based on ecoinvent datasets

```{python}
#Let's compare the environmental impacts (for instance, the climate change impact) among all the inverters.
CC_method = [m for m in bw.methods if 'IPCC 2013' in str(m) and  'climate change' in str(m) and 'GWP 100a' in str(m) and not 'no LT' in str(m) ][0]

def create_dictionary(act, value = 1):
    dict_activities={}
    dict_activities[act] = value
    return dict_activities
```

```{python}
# Importance of production location ?
list_inv = [create_dictionary(act, value = 1) for act in list_act]
list_inv

bw.calculation_setups['multiLCA'] = {'inv': list_inv, 'ia': [CC_method]}
bw.calculation_setups['multiLCA']
myMultiLCA = bw.MultiLCA('multiLCA')
myMultiLCA.results
df_impact = pd.DataFrame(columns = [CC_method], data = myMultiLCA.results)
df_impact.index = [act['name'] + ' ' + act['location'] for act in list_act]
df_impact
```

```{python}
df_impact.to_excel('Inverter_per_country.xls')
```

It can be noticed that the country where the inverter is manufactured does not have significant impact.
The electricity dataset can be used as well to control the origin of the electricity mix used for more personalization.

```{python}
# %matplotlib inline
```

```{python}
# Weight (kg) evolution with rated Power (kW)
# Use of data from SMA inverter products.
df = pd.DataFrame()
oldx = [2.5, 500]
oldy = [18.5, 1500]
df['Weight (kg)'] = [77, 75, 84, 60, 37, 55, 16,  9.2, 3400, 1900]
df['Power (kW)'] =  [75, 60, 75, 27,  9, 30, 6.5, 4,   2000, 1000]
df['Normalised Weight (kg/kW)'] = df['Weight (kg)'] / df['Power (kW)']
df.plot(kind = 'scatter', x = 'Power (kW)', y = 'Weight (kg)')
#df.plot(kind = 'scatter', x = 'oldx', y = 'oldy', color='r')
#df.plot(kind = 'scatter', x = 'Power (kW)', y = 'Normalised Weight (kg/kW)')
fig, ax = plt.subplots()
df['Normalised Weight (kg/kW)'].plot(kind = 'box', ax = ax)

ii = np.argsort(df['Power (kW)'])
plt.figure()
plt.plot(df['Power (kW)'][ii], df['Weight (kg)'][ii])
plt.plot(oldx, oldy)

plt.figure()
plt.plot(df['Power (kW)'][ii], df['Normalised Weight (kg/kW)'][ii])
```

Let's consider a typical value of 2 kg per kW. This value is considered conservative as new products tend to be lighter with the development of new technologies.

```{python}
# Evolution of the share of material with rated power ?
list_act = [act for act in eidb if 'inverter production' in act['name'] and not 'car' in act['name'] and 'RER' in act['location']]
list_act
```

```{python}
#Creating a dataframe for input-output flow
act = [act for act in eidb if 'inverter production, 500kW' == act['name'] and not 'car' in act['name'] and 'RER' in act['location']][0]
print(act)

df = pd.DataFrame(index = ['amount','unit','key'])
for exc in act.exchanges():
    if exc['name'] in df.columns:
        df[exc['name']].loc['amount'] += exc.amount
    else:
        df[exc['name']] = [exc.amount, exc.unit, exc.input.key]
df_inverter_500kW = df.T
df_inverter_500kW
```

```{python}
act = [act for act in eidb if 'inverter production, 2.5kW' == act['name'] and not 'car' in act['name'] and 'RER' in act['location']][0]
print(act)

df = pd.DataFrame(index = ['amount','unit','key'])
for exc in act.exchanges():
    if exc['name'] in df.columns:
        df[exc['name']].loc['amount'] += exc.amount
    else:
        df[exc['name']] = [exc.amount, exc.unit, exc.input.key]
df_inverter_3kW = df.T
df_inverter_3kW
```

```{python}
df_inverter = pd.concat([df_inverter_3kW, df_inverter_500kW], axis = 1, keys = ['3 kW', '500 kW'])
df_inverter = df_inverter.drop(['inverter, 2.5kW', 'inverter, 500kW'])
df_inverter
```

```{python}
# Merging unit
def merge_unit(row):
    if row['Valid']:
        unit = row['3 kW']
    else :
        unit = row['500 kW']
    return unit

df_unit = df_inverter.xs('unit', level = 1, axis = 1)
df_unit['Valid'] = df_unit['3 kW'].notnull()
df_unit['unit']  = df_unit.apply(merge_unit , axis = 1)
```

```{python}
# Merging key
def merge_key(row):
    if row['Valid']:
        key = row['3 kW']
    else :
        key = row['500 kW']
    return key

df_key = df_inverter.xs('key', level = 1, axis = 1)
df_key['Valid'] = df_key['3 kW'].notnull()
df_key['key']  = df_key.apply(merge_key , axis = 1)
```

```{python}
# Analysing share ratio
df = df_inverter.xs('amount', level = 1, axis = 1)
df = df.replace(np.nan, 0)
df['unit'] = df_unit['unit']
df.loc['Total weight'] = [18.5, 3000, 'kilogram']
df['key'] = df_key['key']

df['3 kW share'] = df['3 kW'] / df['3 kW'].loc['Total weight']
df['500 kW share'] = df['500 kW'] / df['500 kW'].loc['Total weight']
df
```

the 2.5kW weighs 18.5 kg and the 500kW weighs 3000 kg.


Between a 3 kVA inverter and a 500 kVA inverter, there is a significant evolution in the share material used. 
The inventory will be calculated based on the weight of the inverter multiplied by the share of the different material involved interpolated between the 3 KVA and 500 kVA inventories.

```{python}
df.to_pickle('inverter_inventories.pkl')
```

### Loading inventories

```{python}
df_inverter = pd.read_pickle('inverter_inventories.pkl')
df_inverter_share = df_inverter[['3 kW share', '500 kW share']]
df_inverter
```

```{python}
# Activities present in the 3 kW inverter (but not in the 500 kW)
PVC = [act for act in eidb if 'polyvinylchloride, suspension polymerised' in act['name'] ][0]
Styrene = [act for act in eidb if 'market for styrene-acrylonitrile copolymer' == act['name'] and 'GLO' in act['location']][0]
print(PVC)
print(Styrene)
```

```{python}
# Recycling activities
scrap_aluminium = [act for act in eidb if 'market for scrap alu' in act['name'] and 'Europe' in act['location']][0]
print(scrap_aluminium)
scrap_steel = [act for act in eidb if 'market for scrap steel' in act['name'] and 'Europe' in act['location']][0]
print(scrap_steel)
scrap_copper = [act for act in eidb if 'market for scrap copper' in act['name'] and 'Europe' in act['location']][0]
print(scrap_copper)
scrap_electronic = [act for act in eidb if 'market for electronics scrap' == act['name']][0]
print(scrap_electronic)
```

```{python}
def generate_inverter_dataset(P = 10, elec_dataset = None, recycling_rate = 0):
    '''
    This function generates an inventorie of 1 kg of inverter depending of the power output 
    (P expressed in kW)
    (based on the interpolation between 3 kW and 500 kW inverters' inventory)
    '''   
    
    if [act for act in eidb if 'Inverter production, P kW per kg' == act['name']] == []: 
        inverter_500kW = [act for act in eidb if 'inverter production, 500kW' in act['name'] and not 'car' in act['name'] and 'RER' in act['location']][0]
        inverter_P_per_kg = inverter_500kW.copy()
        inverter_P_per_kg['name'] = 'Inverter production, P kW per kg'
        inverter_P_per_kg['unit'] = 'kilogram'
        inverter_P_per_kg['authors'] = 'Romain Besseau'
        inverter_P_per_kg['comment'] = 'Dataset based on the inventories of 3 kVA and 500 kVA PV inverters. It gives the inventory per inverter kilogram depending on the rated power P and considering a linear extrapolation between 3 kVA and 500 kVA inventories that do not have the same material ratio. The impact per kW will then be calculated considering 2 kg of inverter per kW (based on the analysis of ABB PV inverters). PS: With technical improvements the ratio weight power tends to decrease.'
        inverter_P_per_kg.as_dict()
        inverter_P_per_kg.save()
    else:
        inverter_P_per_kg = [act for act in eidb if 'Inverter production, P kW per kg' == act['name']][0]

    #Removing all data
    for exc in inverter_P_per_kg.exchanges():
        exc.delete()
    inverter_P_per_kg.save()

    #New Output
    new_exc = inverter_P_per_kg.new_exchange(input = inverter_P_per_kg.key, name = 'Inverter production, P kW per kg',
                                             amount = 1, unit = 'kg', categories = '', type = 'production')
    new_exc.save()
    inverter_P_per_kg.save()

    #New Inputs
    for exc in df_inverter[df_inverter.key.notnull()].index:
        #print(exc)
        value = np.interp(P, [3, 500], df_inverter_share.loc[exc][['3 kW share', '500 kW share']].values)
        #print(value)
        new_exc = inverter_P_per_kg.new_exchange(input = df_inverter.loc[exc].key, name = exc, amount = value,
                                                 unit = df_inverter.loc[exc].unit, type = 'technosphere')
        new_exc.save()
        
    inverter_P_per_kg.save()
    
    #Adjusting the electricity used for manufacturing
    if elec_dataset != None:
        for exc in inverter_P_per_kg.exchanges():
            if exc['name'] == 'electricity, medium voltage':
                exc['input'] = elec_dataset.key
                exc.save()

    inverter_P_per_kg.save()
    
    #Adding recycling for aluminium
    #amount to recycle
    m_aluminium = 0
    m_copper = 0
    m_steel = 0
    m_electronic = 0

    for exc in inverter_P_per_kg.exchanges():
        if exc['name'] == 'aluminium, cast alloy':
             m_aluminium += exc['amount']
        if exc['name'] == 'copper':
            m_copper += exc['amount']
        if exc['name'] == 'steel, low-alloyed, hot rolled':
            m_steel += exc['amount']
        if ('capacitor' in exc['name']) or ('diode' in exc['name']) or ('integrated circuit' in exc['name']) or ('printed wiring' in exc['name']) or ('resistor' in exc['name']) or ('transistor' in exc['name']):
            m_electronic += exc['amount']
            
    #Adding aluminium recycling
    new_exc = inverter_P_per_kg.new_exchange(input = scrap_aluminium.key, name = scrap_aluminium['name'], amount = m_aluminium*recycling_rate, unit = scrap_aluminium['unit'], type = 'technosphere')
    new_exc.save() 
    
    #Adding copper recycling
    new_exc = inverter_P_per_kg.new_exchange(input = scrap_copper.key, name = scrap_copper['name'], amount = m_copper*recycling_rate, unit = scrap_copper['unit'], type = 'technosphere')
    new_exc.save()
    
    #Adding steel recycling
    new_exc = inverter_P_per_kg.new_exchange(input = scrap_steel.key, name = scrap_steel['name'], amount = m_steel*recycling_rate, unit = scrap_steel['unit'], type = 'technosphere')
    new_exc.save()
    
    #Adding electroning recycling
    new_exc = inverter_P_per_kg.new_exchange(input = scrap_electronic.key, name = scrap_electronic['name'], amount = m_electronic*recycling_rate, unit = scrap_electronic['unit'], type = 'technosphere')
    new_exc.save()
    
    inverter_P_per_kg.save()
        
    return inverter_P_per_kg
```

```{python}
inverter_P_per_kg = generate_inverter_dataset(P = 500, elec_dataset = None, recycling_rate = 0.3)
inverter_P_per_kg
```

```{python}
inverter_P_per_kg = [act for act in eidb if 'Inverter production, P kW per kg' in act['name']][0]
inverter_P_per_kg
```

```{python}
print_data(inverter_P_per_kg)
```

```{python}
inverter_2_5 = [act for act in eidb if 'inverter production, 2.5kW' in act['name'] and 'RER' in act['location']][0]
inverter_2_5
```

2.5 kw * 2 kg / kW = 5 kg

```{python}
set_of_methods = list_methods
bw.calculation_setups['B_inverter_2.5kW'] = {'inv': [{inverter_2_5:1}, {inverter_P_per_kg:5}], 'ia': set_of_methods}
myMultiLCA = bw.MultiLCA('B_inverter_2.5kW')
df_impact = pd.DataFrame(columns = set_of_methods, data = myMultiLCA.results)
df_impact
```

```{python}
(232.46-62.83)/232.46*100
```

```{python}
b = df_impact.T.iloc[0]
b.plot(kind = 'bar')
```

```{python}
inverter_P_per_kg_500 = generate_inverter_dataset(P = 500, elec_dataset = None, recycling_rate = 0)
inverter_P_per_kg_500
```

```{python}
inverter_P_per_kg_500 = [act for act in eidb if 'Inverter production, P kW per kg' in act['name']][0]
inverter_P_per_kg_500
```

```{python}
inverter_500 = [act for act in eidb if 'inverter production, 500kW' in act['name'] and 'RER' in act['location']][0]
inverter_500
```

500 kW * 2 kg / kW = 1000 kg

```{python}
set_of_methods = list_methods
bw.calculation_setups['B_inverter_500kW'] = {'inv': [{inverter_500:1}, {inverter_P_per_kg_500:1000}], 'ia': set_of_methods}
myMultiLCA = bw.MultiLCA('B_inverter_500kW')
df_impact = pd.DataFrame(columns = set_of_methods, data = myMultiLCA.results)
df_impact
```

```{python}
(13560-4517)/13560*100
```

```{python}
a = df_impact.T.iloc[0]
a.plot(kind = 'bar')
```

It can be seen that there is a reduction in the envrionmental impacts (~ 66-73% reduction for the climate change). This results from the weight adjustment and the material adjustment accordingly.


## Metallization paste


This section replaces all the silver used in the metallization paste by copper.
However, the adequate replacement will be accomplished in the following sections according to the conductivity.

```{python}
#Create a new metalization paste copper based
metal_paste_copper = [act for act in eidb if 'metallization paste production, back side, copper' == act['name'] and not 'aluminium' in act['name']]
    
if metal_paste_copper == []: 
    #SCA 'RER' added
    metal_paste = [act for act in eidb if 'metallization paste production, back side' == act['name'] and 'RER' in act['location'] and not 'aluminium' in act['name']][0]
    metal_paste_copper = metal_paste.copy()
    metal_paste_copper['name'] = 'metallization paste production, back side, copper'
    metal_paste_copper['authors'] = 'Romain Besseau'
    metal_paste_copper['comment'] = 'Dataset for metallization paste production where Silver is simply replaced by Copper'


    for exc in metal_paste_copper.exchanges():
        exc['output'] = metal_paste_copper.key
        exc.save()

    copper_dataset = [act for act in eidb if 'copper production, primary' == act['name'] and 'RoW'in act['location']][0]
    #Changing the silver dataset to copper.               
    for exc in metal_paste_copper.exchanges():
        if exc['name'] == 'silver':
            print('Activity to change:')
            print(exc['name'])
            exc['name'] = copper_dataset['name']
            exc['input'] = copper_dataset.key
            print('Activity changed:')
            print(exc['name'])
            exc.save()  
    metal_paste_copper.save()  

metal_paste_copper = [act for act in eidb if 'metallization paste production, back side, copper' in act['name'] ][0]
metal_paste_copper
```

```{python}
metallization_ori = [act for act in eidb if 'metallization paste production, back side' == act['name'] and not 'aluminium' in act['name']][0]
metallization_ori
```

```{python}
metallization_adj = [act for act in eidb if 'metallization paste production, back side, copper' == act['name']][0]
metallization_adj
```

```{python}
bw.calculation_setups['B_metallization_paste'] = {'inv': [{metallization_ori:1}, {metallization_adj:1}], 'ia': list_methods}
myMultiLCA = bw.MultiLCA('B_metallization_paste')
df_impact = pd.DataFrame(columns = list_methods, data = myMultiLCA.results)
df_impact
```

```{python}
(234.35-4.28)/234.35*100
```

This is a theoretical analysis, if all the silver is replaced by copper, the impact can be tremendously reduced. However, it is not the case because of the difference in conductivity, and, hence, the difference of amount needed accordingly.


## Silicon solar grade manufacturing


In this section, the main modification implemented is the change of the electrcity intensity used for the manufacturing of the solar grade.


It should be noted that the parameter Silicon_electricity_intensity englobes the electrcity used for solar processing and casting so 110 + 85 (for casting) kg / kWh in ecoinvent 3.4

```{python}
def generate_silicon_dataset(Silicon_electricity_intensity = 30+10, elec_dataset = None):
    '''
    This function generates an inventory of 1 kg of silicon solar grade with a variable amount of electricity
    used for the solar grade modified Siemens process.
    electricity_intensity is expressed in kWh/kg. The initial value was initally set at 110 + 85 kWh/kg.
    Using FBR, this value can go down to 30 + 15 kWh/kg (Task 12 report: Stolz et al. (2017))
    '''
    initial_dataset = 'silicon production, solar grade, modified Siemens process'
    Silicon_adjusted = [act for act in eidb if initial_dataset + ' adjusted' == act['name']]
    
    if Silicon_adjusted == []: 
        Silicon = [act for act in eidb if initial_dataset == act['name'] and 'RER' in act['location']][0]
        Silicon_adjusted = Silicon.copy()
        Silicon_adjusted['name'] = initial_dataset + ' adjusted'
        Silicon_adjusted['authors'] = 'Romain Besseau'
        Silicon_adjusted['comment'] = 'Dataset adjusted with the amount of electricity and the corresponding dataset'      
        
        for exc in Silicon_adjusted.exchanges():
            exc['output'] = Silicon_adjusted.key
            exc.save()
        
        #Deleting hydro dataset not to count two times electricity
        # Elec dataset to remove to avoid double amount of electricity
        elec_hydro = [act for act in eidb if 'electricity production, hydro, run-of-river' in act['name'] and 'RoW' in act['location']][0]

        for exc in Silicon_adjusted.exchanges():
            if exc['unit'] == 'kilowatt hour':
                if exc['activity'] == elec_hydro['activity']:
                    exc['amount'] = 0
                    exc.delete()
                    exc.save()
        
        Silicon_adjusted.save()        
        
    else:
        #Silicon = [act for act in eidb if initial_dataset in act['name'] and 'RER' in act['location']][0]
        Silicon_adjusted = [act for act in eidb if initial_dataset + ' adjusted' in act['name']][0]
        
    #Adjusting the amount of electricity used
    for exc in Silicon_adjusted.exchanges():
        if exc['name'] == 'electricity, high voltage':
            exc['amount'] = Silicon_electricity_intensity
            exc.save()
      
    #Adjusting the electricity used for manufacturing
    if elec_dataset != None:
        for exc in Silicon_adjusted.exchanges():
            if exc['name'] == 'electricity, high voltage':
                exc['input'] = elec_dataset.key
                exc.save()

    Silicon_adjusted.save()
    
    return Silicon_adjusted
```

```{python}
Silicon_adjusted = generate_silicon_dataset(Silicon_electricity_intensity = 30+10, elec_dataset = None)
Silicon_adjusted
```

```{python}
silicon_ori = [act for act in eidb if 'silicon production, solar grade, modified Siemens process' == act['name']
               and 'RER' in act['location']][0]
silicon_ori
```

```{python}
bw.calculation_setups['B_silicon_grade'] = {'inv': [{silicon_ori:1}, {Silicon_adjusted:1}], 'ia': list_methods}
myMultiLCA = bw.MultiLCA('B_silicon_grade')
df_impact = pd.DataFrame(columns = list_methods, data = myMultiLCA.results)
df_impact
```

```{python}
(44.68-42.23)/44.68*100
```

A correction was made here: in ecoinvent 3.4, 65 kWh / kg was considered produced by hydro-electricity which is not always the case in all the countries. Therefore, these 65 were added to the 45 kWh under 1 source of electricity (not hydro). Therefore, if we correct this value, the original dataset would have 72 kg-CO2-eq/kWh. Hence, this impact reduction are compensated by the less electricity needed going from 110 to 45 kWh / kg. This why, at the end, the significant difference is not noticed.


### Amount of electricity for the different processes ?

```{python}
list_act = [act for act in eidb if 'silicon production' in act['name'] and not 'treatment' in act['name'] and not 'ferro' in act['name'] and not 'market' in act['name']]
list_act
```

```{python}
DF = pd.DataFrame()
for act in list_act:
    df = pd.DataFrame(index = ['amount','unit','key'])
    for exc in act.exchanges():
        if exc['name'] in df.columns:
            df[exc['name']].loc['amount'] += exc.amount
        else:
            df[exc['name']] = [exc.amount, exc.unit, exc.input.key]
    df = df.T[['amount']]
    df.columns = [act['name'] +' '+ act['location']]
    DF = pd.concat([DF,df], axis = 1)
DF.T[['electricity, medium voltage','electricity, high voltage']]
```

```{python}
# %matplotlib inline
```

```{python}
fig, ax = plt.subplots(figsize = (9, 6))
DF.T[['electricity, medium voltage','electricity, high voltage']].plot(kind = 'barh', ax = ax)
plt.title('Electricity intensity of Silicon production')
plt.xlabel('Electricity content (kWh/kg)')
```

Based on the comparision of the electricity consumption of diffirent silicon processing steps, it can be noticed the following:
- Czochralski process - Energy intensive
- electronic grade with solar grade output consumes energy
- metallurgical - consumes less energy
- solar grade modified Siemens process
- silicon production, multi-Si casted 

```{python}
Silicon = [act for act in eidb if 'silicon production, solar grade, modified Siemens process' == act['name'] and 'RER' in act['location']][0]
Silicon
```

```{python}
DF = pd.concat([print_data(Silicon),print_data(Silicon_adjusted)], axis = 1, keys = ['original', 'adjusted'])
DF
```

## Silicon casting


### Analysis of existing silicon casting inventories

```{python}
list_act = [act for act in eidb if 'silicon production, multi-Si, casted' in act['name'] ]
list_act
```

```{python}
DF = pd.DataFrame()
for act in list_act:
    df = pd.DataFrame(index = ['amount','unit','key'])
    for exc in act.exchanges():
        if exc['name'] in df.columns:
            df[exc['name']].loc['amount'] += exc.amount
        else:
            df[exc['name']] = [exc.amount, exc.unit, exc.input.key]
    df = df.T[['amount']]
    df.columns = [act['name'] +' '+ act['location']]
    DF = pd.concat([DF,df], axis = 1)
display(DF)
```

```{python}
act = [act for act in eidb if 'silicon production, multi-Si, casted' in act['name'] and 'RoW' in act['location']][0]
act
```

```{python}
print_data(act)
```

Let's remove the use of silicon electronics grade (it was significant when the world silicon production was relatively low, nowadays this volume can be neglected compared to the level reached by the solar industry).
Let's remove also silicon solar grade as it is directly call by the wafer dataset and also electricity that is already accounted in the amount of electricity for solar grade manufacturing.
As a consequence, only chemicals, the factory and ceramic will be left and this dataset will complement the silicon solar grade dataset and both will be called for the wafer dataset.


### Creation of a new silicon casting dataset

```{python}
#Create a new dataset
casting_dataset = [act for act in eidb if 'silicon casting activity' in act['name'] and 'RoW' in act['location']]
    
if casting_dataset == []: 
    original_act = [act for act in eidb if 'silicon production, multi-Si, casted' in act['name'] and 'RoW' in act['location']][0]
    casting_act = original_act.copy()
    casting_act['name'] = 'silicon casting activity'
    casting_act['authors'] = 'Romain Besseau'
    casting_act['comment'] = 'Dataset for silicon casting constructed from silicon production, multi-Si casted removing the silicon that is directly called by the next process, removing the energy that is directly accounted in the silicon dataset. As a results, only chemicals and equipments required for casting remians in the dataset.'

    #Changing connexion to the output and output name
    for exc in casting_act.exchanges():
        exc['output'] = casting_act.key
        exc.save()
        if exc['type'] == 'production':
            exc['name'] = 'casting silicon'
            exc.save()
    casting_act.save()
    
    #Deleting silicon input
    for exc in casting_act.exchanges():
        if 'silicon,' in exc['name']:
            exc.delete()
            exc.save()
        if 'electricity, medium voltage' in exc['name']:
            exc.delete()
            exc.save()
    casting_act.save()
    

casting_act = [act for act in eidb if 'silicon casting activity' in act['name'] and 'RoW' in act['location']][0]
casting_act
```

```{python}
print_data(casting_act)
```

## Wafer manufacturing


In this section, some modifications were integrated by creating new datasets related mainly to the emerging practices in the cutting processes: 6 new datasets were created to serve this purpose.
On one hand, 2 of them (SiC recycled and TEG recycled) are related to the advancements of the traditional cutting process (loose abrasive slurry). The advancement of their recycling has resulted in the use of their recycled material recovered.
On another hand, the 4 new datasets are created to represent 1 meter of wire used in the emerging technology: the diamond wiring.


### Cutting Process


#### SiC, Recycled

```{python}
def generate_SiC_recycled_dataset():
    '''
    Since the recycling of Silicon carbide has been improving for the last past years, a dataset representing
    the silicon carbide produced from the recycling process is modeled according to the KBOB:2016 with 
    '''
    
    if [act for act in eidb if 'silicon carbide, recycled production' == act['name']] == []:
        act_original= [act for act in eidb if 'silicon carbide production' in act['name'] and 'RER' in act['location']][0]
        SiC_recycled=act_original.copy()
        SiC_recycled['name'] = 'silicon carbide, recycled production'
        SiC_recycled['unit'] = 'kilogram'
        SiC_recycled['author'] = 'ST based on KBOB:2016'
        SiC_recycled['location'] = 'RER'
        SiC_recycled['comment'] = 'Dataset corresponding to the Silicon carbide, recycling, at plant/kg/RER of the KBOB:2016'
        
        #Removing all data
        for exc in SiC_recycled.exchanges():
            exc.delete()
            exc.save()
        SiC_recycled.save()
        
        #Output
        act = [act for act in eidb if 'silicon carbide, recycled production' in act['name']][0]
        new_exc = SiC_recycled.new_exchange(input = act.key, amount = 1, unit = 'kilogram', type = 'production', name = act['name'])
        new_exc.save()
        SiC_recycled.save()
        
        #Electricity input
        act =[act for act in eidb if 'market group for electricity, medium voltage' in act['name'] and 'ENTSO' in act['location']][0]
        new_exc = SiC_recycled.new_exchange(input = act.key, amount = 0.78571, unit = 'kilowatt hour', type = 'technosphere', name = act['name'])
        new_exc.save()
        SiC_recycled.save()
        
        #Transport input
        act = [act for act in eidb if 'market for transport, freight, lorry, unspecified' in act['name'] and 'GLO' in act['location']][0]
        new_exc = SiC_recycled.new_exchange(input = act.key, amount = 0.2625, unit = 'ton kilometer', type = 'technosphere', name = act['name'])
        new_exc.save()
        SiC_recycled.save()
        
        #Silicon input
        act = [act for act in eidb if 'market for silicone factory' in act['name']][0]
        new_exc = SiC_recycled.new_exchange(input = act.key, amount = 1e-11, unit = 'unit', type = 'technosphere', name = act['name'])
        new_exc.save()
        SiC_recycled.save()
        
        #Emissions to air
        act = [act for act in bio3 if 'Heat, waste' == act['name'] and "air" in act['categories'] and len(act['categories'])==1][0]
        new_exc = SiC_recycled.new_exchange(input = act.key, amount = 2.8286, unit = 'megajoule', type = 'biosphere', name = act['name'])
        new_exc.save()
        SiC_recycled.save()
        
        #Disposal Si
        act = [act for act in eidb if 'market for waste, from silicon wafer production, inorganic' in act['name']][0]
        new_exc = SiC_recycled.new_exchange(input = act.key, amount = -0.042857, unit = 'unit', type = 'technosphere', name = act['name'])
        new_exc.save()
        SiC_recycled.save()
        
        #Disposal antifreezer
        #This had double impact:
        #act = [act for act in eidb if 'market for spent antifreezer liquid' in act['name'] and 'GLO' in act['location']][0]
        #This should be used because it is not CH only
        #act = [act for act in eidb if 'treatment of spent antifreezer liquid, hazardous waste incineration' in act['name'] and 'RoW' in act['location']][0]
        act = [act for act in eidb if 'treatment of spent antifreezer liquid, hazardous waste incineration' in act['name'] and 'CH' in act['location']][0]
        new_exc = SiC_recycled.new_exchange(input = act.key, amount = -0.071429, unit = 'unit', type = 'technosphere', name = act['name'])
        new_exc.save()
        SiC_recycled.save()
        
        #Disposal pig iron
        act = [act for act in eidb if 'market for sludge, pig iron production' in act['name'] and 'Europe' in act['location']][0] 
        new_exc = SiC_recycled.new_exchange(input = act.key, amount = -0.13571, unit = 'unit', type = 'technosphere', name = act['name'])
        new_exc.save()
        SiC_recycled.save()
        
        
    else:
        act_original= [act for act in eidb if 'silicon carbide production' in act['name'] and 'RER' in act['location']][0]
        SiC_recycled = [act for act in eidb if 'silicon carbide, recycled production' == act['name']][0]
                
    return SiC_recycled

SiC_recycled = generate_SiC_recycled_dataset()
SiC_recycled
```

```{python}
SiC_recycled = [act for act in eidb if 'silicon carbide, recycled production' in act['name'] and 'RER' in act['location']][0]
SiC_recycled
```

```{python}
SiC_ori = [act for act in eidb if 'silicon carbide production' in act['name'] and 'RER' in act['location']][0]
SiC_ori
```

```{python}
DF = pd.concat([print_data(SiC_ori),print_data(SiC_recycled)], axis = 1, keys = ['original', 'adjusted'])
DF
```

```{python}
bw.calculation_setups['B_SiC'] = {'inv': [{SiC_ori:1}, {SiC_recycled:1}], 'ia': list_methods}
myMultiLCA = bw.MultiLCA('B_SiC')
df_impact = pd.DataFrame(columns = list_methods, data = myMultiLCA.results)
df_impact
```

```{python}
(6.01-0.60)/6.01*100
```

#### TEG, Recycled

```{python}
#attention there are 3 datasets which have the same name and location, so they got differentiated by the code
TEG_original = [act for act in eidb if 'ethylene glycol production' == act['name'] and 'RER' == act['location'] and '85c5a45f05a8e40c76aebf8a4dbdc3ad' in act['code']][0]
TEG_original
```

```{python}
def generate_TEG_recycled_dataset():
    '''
    since the recycling of polyethylene glycol carbide, similarly to the silicon carbide, has been improving for the last past
    years, a dataset representing the polyethylene glycol produced from the recycling process is modeled according
    to the KBOB:2016.
    '''
    
    if [act for act in eidb if 'triethylene glycol, recycled production' == act['name']] == []:
        act_original = [act for act in eidb if 'ethylene glycol production' == act['name'] and 'RER' == act['location'] and '85c5a45f05a8e40c76aebf8a4dbdc3ad' in act['code']][0]
        TEG_recycled=act_original.copy()
        TEG_recycled['name'] = 'triethylene glycol, recycled production'
        TEG_recycled['unit'] = 'kilogram'
        TEG_recycled['author'] = 'ST based on KBOB:2016'
        TEG_recycled['location'] = 'RER'
        TEG_recycled['comment'] = 'Dataset corresponding to the Triethylene glycol, recycling, at plant/RER of the KBOB:2016'
        TEG_recycled.save()
        #Removing all data
        for exc in TEG_recycled.exchanges():
            exc.delete()
            exc.save()
        TEG_recycled.save()
        
        #Output
        act = [act for act in eidb if 'triethylene glycol, recycled production' in act['name']][0]
        new_exc = TEG_recycled.new_exchange(input = act.key, amount = 1, unit = 'kilogram', type = 'production', name = act['name'])
        new_exc.save()
        TEG_recycled.save()
        
        #Electricity input
        act =[act for act in eidb if 'market group for electricity, medium voltage' in act['name'] and 'ENTSO' in act['location']][0]
        new_exc = TEG_recycled.new_exchange(input = act.key, amount = 0.78571, unit = 'kilowatt hour', type = 'technosphere', name = act['name'])
        new_exc.save()
        TEG_recycled.save()
        
        #Transport input
        act = [act for act in eidb if 'market for transport, freight, lorry, unspecified' in act['name'] and 'GLO' in act['location']][0]
        new_exc = TEG_recycled.new_exchange(input = act.key, amount = 0.2625, unit = 'ton kilometer', type = 'technosphere', name = act['name'])
        new_exc.save()
        TEG_recycled.save()
        
        #Silicon input
        act = [act for act in eidb if 'market for silicone factory' in act['name']][0]
        new_exc = TEG_recycled.new_exchange(input = act.key, amount = 1e-11, unit = 'unit', type = 'technosphere', name = act['name'])
        new_exc.save()
        TEG_recycled.save()
        
        #Emissions to air
        act = [act for act in bio3 if 'Heat, waste' in act['name'] and "air" in act['categories'] and 'f2d84834-d0b3-42e5-b41a-f04cc80337a4' in act['code']][0]
        new_exc = TEG_recycled.new_exchange(input = act.key, amount = 2.8286, unit = 'megajoule', type = 'biosphere', name = act['name'])
        new_exc.save()
        TEG_recycled.save()
        
        #Disposal Si
        act = act = [act for act in eidb if 'market for waste, from silicon wafer production, inorganic' in act['name']][0]
        new_exc = TEG_recycled.new_exchange(input = act.key, amount = -0.042857, unit = 'unit', type = 'technosphere', name = act['name'])
        new_exc.save()
        TEG_recycled.save()
        
        #Disposal antifreezer
        #This had double impact:
        #act = [act for act in eidb if 'market for spent antifreezer liquid' in act['name'] and 'GLO' in act['location']][0]
        #This should be used because it is not CH only
        #act = [act for act in eidb if 'treatment of spent antifreezer liquid, hazardous waste incineration' in act['name'] and 'RoW' in act['location']][0]
        act = [act for act in eidb if 'treatment of spent antifreezer liquid, hazardous waste incineration' in act['name'] and 'CH' in act['location']][0]
        new_exc = TEG_recycled.new_exchange(input = act.key, amount = -0.071429, unit = 'unit', type = 'technosphere', name = act['name'])
        new_exc.save()
        TEG_recycled.save()
        
        #Disposal pig iron
        act = [act for act in eidb if 'market for sludge, pig iron production' in act['name'] and 'Europe' in act['location']][0] 
        new_exc = TEG_recycled.new_exchange(input = act.key, amount = -0.13571, unit = 'unit', type = 'technosphere', name = act['name'])
        new_exc.save()
        TEG_recycled.save()
        
        
    else:
        act_original= [act for act in eidb if 'ethylene glycol production' in act['name'] and 'RER' in act['location']][0]
        TEG_recycled = [act for act in eidb if 'triethylene glycol, recycled production' == act['name']][0]
                
    return TEG_recycled

TEG_recycled = generate_TEG_recycled_dataset()
TEG_recycled
```

```{python}
TEG_recycled = [act for act in eidb if 'triethylene glycol, recycled production' == act['name'] and 'RER' == act['location']][0]
TEG_recycled
```

```{python}
DF = pd.concat([print_data(TEG_original),print_data(TEG_recycled)], axis = 1, keys = ['original', 'adjusted'])
DF
```

```{python}
bw.calculation_setups['B_TEG'] = {'inv': [{TEG_original:1}, {TEG_recycled:1}], 'ia': list_methods}
myMultiLCA = bw.MultiLCA('B_TEG')
df_impact = pd.DataFrame(columns = list_methods, data = myMultiLCA.results)
df_impact
```

```{python}
(2.06-0.60)/2.06*100
```

#### Diamond Wiring


All the following datasets are based on Isabella Bianco thesis (2018) in which she analyzed the cutting processes in details. It was essential to integrate these datasets to elaborate the dataset of the wire which will be used for the cutting process according to the emerging diamond wiring technology.

```{python}
def generate_tungsten():
    '''
    This function generates a new dataset the tungsten carbide (expressed in kg) which is used for the wire later on.
    '''
    
    if [act for act in eidb if 'tungsten carbide production' == act['name']] == []:
        act_original=[act for act in eidb if 'silicon carbide production' == act['name'] and 'RER' in act['location']][0]
        tungsten_carbide=act_original.copy()
        tungsten_carbide['name'] = 'tungsten carbide production'
        tungsten_carbide['unit'] = 'kilogram'
        tungsten_carbide['location'] = 'RER'
        tungsten_carbide['author'] = 'ST based on Isabella Bianco dataset'
        tungsten_carbide['comment'] = 'Dataset corresponding to the LCI provided by Isabella Bianco(2018) thesis - Table 46'
        
        #Removing all data
        for exc in tungsten_carbide.exchanges():
            exc.delete()
            exc.save()
        tungsten_carbide.save()
        
        #Output
        act = [act for act in eidb if 'tungsten carbide production' in act['name']][0]
        new_exc = tungsten_carbide.new_exchange(input = act.key, amount = 1, unit = 'kilogram', type = 'production', name = act['name'])
        new_exc.save()
        tungsten_carbide.save()
        
        #input
        act = [act for act in eidb if 'market for sodium hydroxide, without water, in 50% solution state' in act['name'] and 'GLO' in act['location']][0]
        new_exc = tungsten_carbide.new_exchange(input = act.key, amount = 1.49, unit = 'kilogram', type = 'technosphere', name = act['name'])
        new_exc.save()
        tungsten_carbide.save()
        
        act = [act for act in eidb if 'aluminium sulfate production, powder' in act['name'] and 'RER' in act['location']][0]
        new_exc = tungsten_carbide.new_exchange(input = act.key, amount = 0.071, unit = 'kilogram', type = 'technosphere', name = act['name'])
        new_exc.save()
        tungsten_carbide.save()
        
        act = [act for act in eidb if 'sodium sulfide production' in act['name'] and 'GLO' in act['location']][0]
        new_exc = tungsten_carbide.new_exchange(input = act.key, amount = 0.044, unit = 'kilogram', type = 'technosphere', name = act['name'])
        new_exc.save()
        tungsten_carbide.save()
        
        act = [act for act in eidb if 'magnesium sulfate production' in act['name'] and 'RER' in act['location']][0]
        new_exc = tungsten_carbide.new_exchange(input = act.key, amount = 0.027, unit = 'kilogram', type = 'technosphere', name = act['name'])
        new_exc.save()
        tungsten_carbide.save()
        
        act = [act for act in eidb if 'market for ammonia, liquid' in act['name'] and 'RER' in act['location']][0]
        new_exc = tungsten_carbide.new_exchange(input = act.key, amount = 0.106, unit = 'kilogram', type = 'technosphere', name = act['name'])
        new_exc.save()
        tungsten_carbide.save()
        
        act = [act for act in eidb if 'market for soda ash, dense' in act['name'] and 'GLO' in act['location']][0]
        new_exc = tungsten_carbide.new_exchange(input = act.key, amount = 1.21, unit = 'kilogram', type = 'technosphere', name = act['name'])
        new_exc.save()
        tungsten_carbide.save()
        
        act = [act for act in eidb if 'sulfuric acid production' == act['name'] and 'RER' in act['location']][0]
        new_exc = tungsten_carbide.new_exchange(input = act.key, amount = 1.24, unit = 'kilogram', type = 'technosphere', name = act['name'])
        new_exc.save()
        tungsten_carbide.save()
        
        act = [act for act in eidb if 'market group for electricity, medium voltage' in act['name'] and 'ENTSO-E' in act['location']][0]
        new_exc = tungsten_carbide.new_exchange(input = act.key, amount = 111.16, unit = 'kilowatt hour', type = 'technosphere', name = act['name'])
        new_exc.save()
        tungsten_carbide.save()
        
        act = [act for act in eidb if 'hydrogen sulfide production' == act['name'] and 'RER' in act['location']][0]
        new_exc = tungsten_carbide.new_exchange(input = act.key, amount = 0.0076, unit = 'kilogram', type = 'technosphere', name = act['name'])
        new_exc.save()
        tungsten_carbide.save()
        
        act = [act for act in eidb if 'market for nitrogen, liquid' == act['name'] and 'RER' in act['location']][0]
        new_exc = tungsten_carbide.new_exchange(input = act.key, amount = 1.65, unit = 'kilogram', type = 'technosphere', name = act['name'])
        new_exc.save()
        tungsten_carbide.save()
        
        act = [act for act in eidb if 'market for hydrogen, liquid' in act['name'] and 'RER' in act['location']][0]
        new_exc = tungsten_carbide.new_exchange(input = act.key, amount = 0.32, unit = 'kilogram', type = 'technosphere', name = act['name'])
        new_exc.save()
        tungsten_carbide.save()        
        
        act = [act for act in eidb if 'market for tap water' in act['name'] and 'RoW' in act['location']][0]
        new_exc = tungsten_carbide.new_exchange(input = act.key, amount = 2.84, unit = 'kilogram', type = 'technosphere', name = act['name'])
        new_exc.save()
        tungsten_carbide.save()
        
        act = [act for act in eidb if 'carbon black production' == act['name'] and 'GLO' in act['location']][0]
        new_exc = tungsten_carbide.new_exchange(input = act.key, amount = 0.13, unit = 'kilogram', type = 'technosphere', name = act['name'])
        new_exc.save()
        tungsten_carbide.save()
        
    else:
        tungsten_carbide = [act for act in eidb if 'tungsten carbide production' == act['name']][0]
        tungsten_carbide.save()
        
    return tungsten_carbide  

tungsten_carbide = generate_tungsten()
tungsten_carbide
```

```{python}
tungsten_carbide = [act for act in eidb if 'tungsten carbide production' in act['name']][0]
tungsten_carbide
```

```{python}
#This shows the impact of the AMOUNT used later on in the diamond wire
bw.calculation_setups['B_tungsten_carbide'] = {'inv': [{tungsten_carbide:1}], 'ia': list_methods}
myMultiLCA = bw.MultiLCA('B_tungsten_carbide')
df_impact = pd.DataFrame(columns = list_methods, data = myMultiLCA.results)
df_impact
```

```{python}
(5.27*10e-07)
```

```{python}
#In order to check the list of materials of this dataset, the following table displays the new created inventory
print_data(tungsten_carbide)
```

```{python}
def generate_diamond_powder():
    '''
    This function generates a new dataset of diamond powder which is used for the wire later on.
    '''
    
    if [act for act in eidb if 'diamond powder, production' == act['name']] == []:
        act_original= [act for act in eidb if 'sodium percarbonate production, powder' in act['name'] and 'RER' in act['location']][0]
        diamond_powder=act_original.copy()
        diamond_powder['name'] = 'diamond powder, production'
        diamond_powder['unit'] = 'kilogram'
        diamond_powder['location'] = 'RER'
        diamond_powder['author'] = 'ST based on Isabella Bianco dataset'
        diamond_powder['comment'] = 'Dataset corresponding to the LCI provided by Isabella Bianco(2018) thesis - Table 51'
        
        #Removing all data
        for exc in diamond_powder.exchanges():
            exc.delete()
            exc.save()
        diamond_powder.save()
        
        #Output
        act = [act for act in eidb if 'diamond powder, production' in act['name']][0]
        new_exc = diamond_powder.new_exchange(input = act.key, amount = 1, unit = 'kilogram', type = 'production', name = act['name'])
        new_exc.save()
        diamond_powder.save()
        
        #input
        act = [act for act in eidb if 'market for electricity, medium voltage' in act['name'] and 'RoW' in act['location']][0]
        new_exc = diamond_powder.new_exchange(input = act.key, amount = 840, unit = 'kilowatt hour', type = 'technosphere', name = act['name'])
        new_exc.save()
        diamond_powder.save()
        
        act = [act for act in eidb if 'graphite production' in act['name'] and 'RER' in act['location']][0]
        new_exc = diamond_powder.new_exchange(input = act.key, amount = 1, unit = 'kilogram', type = 'technosphere', name = act['name'])
        new_exc.save()
        diamond_powder.save()
        
        #transport from China to Europe (Italy, for example)
        act = [act for act in eidb if 'transport, freight, sea, transoceanic ship' == act['name'] and 'GLO' in act['location']][0]
        new_exc = diamond_powder.new_exchange(input = act.key, amount = 170, unit = 'ton kilometer', type = 'technosphere', name = act['name'])
        new_exc.save()
        diamond_powder.save()
        
        act = [act for act in eidb if 'transport, freight, lorry 16-32 metric ton, EURO4' == act['name'] and 'RER' in act['location']][0]
        new_exc = diamond_powder.new_exchange(input = act.key, amount = 0.53, unit = 'ton kilometer', type = 'technosphere', name = act['name'])
        new_exc.save()
        diamond_powder.save()
        
    else:
        diamond_powder = [act for act in eidb if 'diamond powder, production' == act['name']][0]
        diamond_powder.save()
        
    return diamond_powder

diamond_powder = generate_diamond_powder()
diamond_powder
```

```{python}
diamond_powder = [act for act in eidb if 'diamond powder, production' in act['name']][0]
diamond_powder
```

```{python}
print_data(diamond_powder)
```

```{python}

bw.calculation_setups['B_diamond_powder'] = {'inv': [{diamond_powder:1}], 'ia': list_methods}
myMultiLCA = bw.MultiLCA('B_diamond_powder')
df_impact = pd.DataFrame(columns = list_methods, data = myMultiLCA.results)
df_impact
```

```{python}
0.011037
```

```{python code_folding=c()}
def generate_sintered_diamond_bead():
    
    '''
    This function generates a new dataset of sintered diamond which is used for the wire later on.
    The paramater elec_dataset permits the control of the electricity used for manufacturing.
    '''
    
    if [act for act in eidb if 'sintered diamond bead, for quarrying' == act['name']] == []:
        act_original= [act for act in eidb if  'polymethyl methacrylate production, beads' == act['name'] and 'RER' in act['location']][0]
        sintered_diamond_bead=act_original.copy()
        sintered_diamond_bead['name'] = 'sintered diamond bead, for quarrying'
        sintered_diamond_bead['unit'] = 'kilogram'
        sintered_diamond_bead['location'] = 'RER'
        sintered_diamond_bead['author'] = 'ST based on Isabella Bianco dataset'
        sintered_diamond_bead['comment'] = 'Dataset corresponding to the LCI provided by Isabella Bianco(2018) thesis - Table 50'
        
        #Removing all data
        for exc in sintered_diamond_bead.exchanges():
            exc.delete()
            exc.save()
        sintered_diamond_bead.save()
        
        #Output
        act = [act for act in eidb if 'sintered diamond bead, for quarrying' in act['name']][0]
        new_exc = sintered_diamond_bead.new_exchange(input = act.key, amount = 0.004, unit = 'kilogram', type = 'production', name = act['name'])
        new_exc.save()
        sintered_diamond_bead.save()
    
        #the input of the sintered diamond bead (table 50 of Isabella Bianco thesis) to be integrated to Table 45
        
        act = [act for act in eidb if 'market group for electricity, medium voltage' == act['name'] and 'ENTSO-E' == act['location']][0]
        new_exc = new_exc = sintered_diamond_bead.new_exchange(input = act.key, amount = 0.1, unit = 'kilowatt hour', type = 'technosphere', name = act['name'])
        new_exc.save()
        sintered_diamond_bead.save()
        
        act = [act for act in eidb if 'market for steel, unalloyed' in act['name'] and 'GLO' in act['location']][0]
        new_exc = new_exc = sintered_diamond_bead.new_exchange(input = act.key, amount = 0.003, unit = 'kilogram', type = 'technosphere', name = act['name'])
        new_exc.save()
        sintered_diamond_bead.save()
        
        act = [act for act in eidb if 'market for cobalt' in act['name'] and 'GLO' in act['location']][0]
        new_exc = new_exc = sintered_diamond_bead.new_exchange(input = act.key, amount = 7e-08, unit = 'kilogram', type = 'technosphere', name = act['name'])
        new_exc.save()
        sintered_diamond_bead.save()    
        
        act = [act for act in eidb if 'market for copper' == act['name']][0]
        new_exc = new_exc = sintered_diamond_bead.new_exchange(input = act.key, amount = 2.1e-07, unit = 'kilogram', type = 'technosphere', name = act['name'])
        new_exc.save()
        sintered_diamond_bead.save()
        
        act = [act for act in eidb if  'market for pig iron' == act['name']][0]
        new_exc = new_exc = sintered_diamond_bead.new_exchange(input = act.key, amount = 3.5e-07, unit = 'kilogram', type = 'technosphere', name = act['name'])
        new_exc.save()
        sintered_diamond_bead.save()
        
        act = [act for act in eidb if 'market for nickel, 99.5%' == act['name']][0]
        new_exc = new_exc = sintered_diamond_bead.new_exchange(input = act.key, amount = 2.1e-08, unit = 'kilogram', type = 'technosphere', name = act['name'])
        new_exc.save()
        sintered_diamond_bead.save()
        
        act = [act for act in eidb if 'tungsten carbide production' == act['name'] and 'RER' in act['location']][0]
        new_exc = new_exc = sintered_diamond_bead.new_exchange(input = act.key, amount = 3.5e-08, unit = 'kilogram', type = 'technosphere', name = act['name'])
        new_exc.save()
        sintered_diamond_bead.save()
        
        act = [act for act in eidb if 'diamond powder, production' == act['name']][0]
        new_exc = new_exc = sintered_diamond_bead.new_exchange(input = act.key, amount = 2e-05, unit = 'kilogram', type = 'technosphere', name = act['name'])
        new_exc.save()
        sintered_diamond_bead.save()
        
        act = [act for act in eidb if  'polymethyl methacrylate production, beads' == act['name'] and 'RER' in act['location']][0]
        new_exc = new_exc = sintered_diamond_bead.new_exchange(input = act.key, amount = 2e-05, unit = 'kilogram', type = 'technosphere', name = act['name'])
        new_exc.save()
        sintered_diamond_bead.save()
        
        act = [act for act in eidb if 'cobalt production' == act['name']][0]
        new_exc = new_exc = sintered_diamond_bead.new_exchange(input = act.key, amount = 5e-05, unit = 'kilogram', type = 'technosphere', name = act['name'])
        new_exc.save()
        sintered_diamond_bead.save()
        
        act = [act for act in eidb if 'market for silver' in act['name']][0]
        new_exc = new_exc = sintered_diamond_bead.new_exchange(input = act.key, amount = 2.1e-04, unit = 'kilogram', type = 'technosphere', name = act['name'])
        new_exc.save()
        sintered_diamond_bead.save()
        
        act = [act for act in eidb if 'market for nitrogen, liquid' in act['name'] and 'RER' in act['location']][0]
        new_exc = new_exc = sintered_diamond_bead.new_exchange(input = act.key, amount = 0.0323, unit = 'kilogram', type = 'technosphere', name = act['name'])
        new_exc.save()
        sintered_diamond_bead.save()
        
        act = [act for act in eidb if 'market for hydrogen, liquid' in act['name'] and 'RER' in act['location']][0]
        new_exc = new_exc = sintered_diamond_bead.new_exchange(input = act.key, amount = 9e-04, unit = 'kilogram', type = 'technosphere', name = act['name'])
        new_exc.save()
        sintered_diamond_bead.save()
    
    else:
        sintered_diamond_bead = [act for act in eidb if 'sintered diamond bead, for quarrying' == act['name']][0]
        sintered_diamond_bead.save()        
    return sintered_diamond_bead 

sintered_diamond_bead = generate_sintered_diamond_bead()
sintered_diamond_bead
```

```{python}
sintered_diamond_bead = [act for act in eidb if 'sintered diamond bead, for quarrying' in act['name']][0]
sintered_diamond_bead
```

```{python}
#To display the new dataset
print_data(sintered_diamond_bead)
```

```{python}
#To understand the impact of the amount of sintered bead used for the diamond wire at the end of this section
bw.calculation_setups['B_sintered_diamond_bead'] = {'inv': [{sintered_diamond_bead:1}], 'ia': list_methods}
myMultiLCA = bw.MultiLCA('B_sintered_diamond_bead')
df_impact = pd.DataFrame(columns = list_methods, data = myMultiLCA.results)
df_impact
```

```{python}
1.53
```

```{python}
def generate_DW_single_electroplated():
    
    '''
    This function generates a new dataset represented the electroplated diamond wire used for the cutting process of the wafer.
    The paramater elec_dataset permits the control of the electricity used for manufacturing.
    '''
    
    if [act for act in eidb if 'sintered diamond wire, steel' == act['name']] == []:
        act_original= [act for act in eidb if 'wire drawing, steel' in act['name'] and 'RER' in act['location']][0]
        sintered_DW=act_original.copy()
        sintered_DW['name'] = 'sintered diamond wire, steel'
        sintered_DW['unit'] = 'meter'
        sintered_DW['location'] = 'RER'
        sintered_DW['author'] = 'ST based on Isabella Bianco dataset'
        sintered_DW['comment'] = 'Dataset corresponding to the LCI provided by Isabella Bianco(2018) thesis - Table 47'
        
        #Removing all data
        for exc in sintered_DW.exchanges():
            exc.delete()
            exc.save()
        sintered_DW.save()
        
        #Output
        act = [act for act in eidb if 'sintered diamond wire, steel' in act['name']][0]
        new_exc = sintered_DW.new_exchange(input = act.key, amount = 1, unit = 'meter', type = 'production', name = act['name'])
        new_exc.save()
        sintered_DW.save()
        
        #the input of the sintered diamond wire for primapry cuttings (Table 47)
        act = [act for act in eidb if 'sintered diamond bead, for quarrying' in act['name']][0]
        new_exc =  sintered_DW.new_exchange(input = act.key, amount = 0.0427, unit = 'kilogram', type = 'technosphere', name = act['name'])
        new_exc.save()
        sintered_DW.save()
        
        act = [act for act in eidb if 'market group for electricity, medium voltage' == act['name'] and 'ENTSO-E' == act['location']][0]
        new_exc = sintered_DW.new_exchange(input = act.key, amount = 0.9, unit = 'kilowatt hour', type = 'technosphere', name = act['name'])
        new_exc.save()
        sintered_DW.save()
        
        act = [act for act in eidb if 'wire drawing, steel' == act['name'] and 'RER' in act['location']][0]
        new_exc =  sintered_DW.new_exchange(input = act.key, amount = 0.095, unit = 'kilogram', type = 'technosphere', name = act['name'])
        new_exc.save()
        sintered_DW.save()
        
        act = [act for act in eidb if 'polyurethane production, flexible foam' in act['name'] and 'RER' in act['location']][0]
        new_exc =  sintered_DW.new_exchange(input = act.key, amount = 0.15, unit = 'kilogram', type = 'technosphere', name = act['name'])
        new_exc.save()
        sintered_DW.save()
        
        act = [act for act in eidb if 'transport, freight, lorry 16-32 metric ton, EURO4' == act['name'] and 'RER' in act['location']][0]
        new_exc =  sintered_DW.new_exchange(input = act.key, amount = 0.003, unit = 'ton kilometer', type = 'technosphere', name = act['name'])
        new_exc.save()
        sintered_DW.save()
        
        act = [act for act in eidb if 'market for waste plastic, mixture' == act['name'] and 'Europe' in act['location']][0]
        new_exc =  sintered_DW.new_exchange(input = act.key, amount = 0.045, unit = 'kilogram', type = 'technosphere', name = act['name'])
        new_exc.save()
        sintered_DW.save()
        
        
    else:
        sintered_DW = [act for act in eidb if 'sintered diamond wire, steel' == act['name']][0]
        sintered_DW.save()
    return sintered_DW

sintered_DW = generate_DW_single_electroplated()
sintered_DW
```

```{python}
#To display
print_data(sintered_DW)
```

```{python}
#To calculate the impact of the wire used for cutting alone
bw.calculation_setups['B_sintered_DW'] = {'inv': [{sintered_DW:1}], 'ia': list_methods}
myMultiLCA = bw.MultiLCA('B_sintered_DW')
df_impact = pd.DataFrame(columns = list_methods, data = myMultiLCA.results)
df_impact
```

```{python}
0.001637
```

### Wafer 

```{python}
casting_act['name']
```

```{python}
def generate_wafer_dataset(SiC_recycled_share=0.694, TEG_recycled_share = 0.899, 
                           DW=False, manufacturing_efficiency_gains = 0, 
                           kerf_loss = 0.44, wafer_thickness = 200, 
                           elec_dataset = None, Silicon_dataset = None):
    '''
    This function generates an inventory of 1 m² of wafer production. 
    The initial amount of electricity (8 kWh/m²) is adjusted (to 20 kWh/m2 as per KBOB:2016) considering the possibility 
    to be improved (by using less) using manufacturing_efficiency_gains parameter (expressed in fraction/percentage).
    The electricity dataset can be also controlled using the elec_dataset parameter.
    The wafer solar grade used is the wafer solar grade adjusted (that considered the progress in solar grade wafer production),
    the amount of wafer is also adjusted considering the wafer thickness decreasing with the technical progress and evolution 
    of cutting processes with less kerf loss. manufacturing_efficiency_gains and kerf loss are expressed in fraction.
    wafer thickness is expressed in micrometer.
    SiC amount is adjusted from 2.63 kg (Ecoinvent 3.4) to 2.02988 kg (KBOB:2016) in total of which a certain amount (69.4%) 
    is produced from a recycled process with the possibility to modify it. SiC_recycled_share is the amount of recycled SiC
    expressed in fraction/percentage.
    TEG amount is adjusted from 2.71 kg (Ecoinvent 3.4) to 2.16548 kg (KBOB:2016) in total of which a certain amount (89.9%) 
    is produced from a recycled process with the possibility to modify it. TEG_recycled_share is the amount of recycled TEG
    expressed in fraction/percentage.
    Since the Diamond wiring technology is emerging, hence an added boolean parameter is added related to the added/omitted
    amount of SiC, TEG, diamond wire, and water.
    '''
    initial_dataset = 'multi-Si wafer production'
    wafer_adjusted = [act for act in eidb if initial_dataset + ' adjusted' == act['name']]
    
    if wafer_adjusted == []: 
        wafer = [act for act in eidb if initial_dataset == act['name'] and 'RER' in act['location']][0]
        wafer_adjusted = wafer.copy()
        wafer_adjusted['name'] = initial_dataset + ' adjusted'
        wafer_adjusted['authors'] = 'Romain Besseau and ST'
        wafer_adjusted['comment'] = 'Dataset adjusted with the adjustment of the amount of electricity, the corresponding dataset, the amount of Silicon and the corresponding Silicon solar grade dataset'      
        wafer_adjusted.save()
        
        for exc in wafer_adjusted.exchanges():
            exc['output'] = wafer_adjusted.key
            exc.save()
    
        for exc in wafer_adjusted.exchanges():
            if exc['name'] == 'silicon, multi-Si, casted':
                exc['name'] = 'silicon production, solar grade, modified Siemens process adjusted'
                exc.save()
                if Silicon_dataset != None:
                    exc['input'] = Silicon_dataset.key
                    exc.save()
        
        wafer_adjusted.save()  
        
        casting_act = [act for act in eidb if 'silicon casting activity' in act['name'] and 'RoW' in act['location']][0]
        new_exc = wafer_adjusted.new_exchange(input = casting_act.key, 
                                              name = casting_act['name'], 
                                              amount = 0, 
                                              unit = casting_act['unit'],
                                              type = 'technosphere')
        new_exc.save() 
        
        act = [act for act in eidb if 'sintered diamond wire, steel' in act['name'] and 'RER' in act['location']][0]
        new_exc = wafer_adjusted.new_exchange(input = act.key, amount = 0, unit = 'meter', type = 'technosphere', name = act['name'])
        new_exc.save()
        wafer_adjusted.save()

        SiC_recycled = generate_SiC_recycled_dataset()
        act = [act for act in eidb if 'silicon carbide, recycled production' in act['name'] and 'RER' in act['location']][0]
        new_exc = wafer_adjusted.new_exchange(input = act.key, amount = 0, unit = 'kilogram', type = 'technosphere', name = act['name'])
        new_exc.save()

        #Adjusting TEG recycled
        TEG_recycled = generate_TEG_recycled_dataset()
        act = [act for act in eidb if 'triethylene glycol, recycled production' in act['name'] and 'RER' in act['location']][0]
        new_exc = wafer_adjusted.new_exchange(input = act.key, amount = 0, unit = 'kilogram', type = 'technosphere', name = act['name'])
        new_exc.save()
          
        wafer_adjusted.save()        
        
    else:
        #wafer = [act for act in eidb if initial_dataset == act['name'] and 'RER' in act['location']][0]
        wafer_adjusted = [act for act in eidb if initial_dataset + ' adjusted' == act['name']][0]
        
    
    #Diamond Wiring for cutting process; TiC = 0, TEG is replaced by water with additional 98.94 tap water as per KBOB:2016
    if DW==True:
        for exc in wafer_adjusted.exchanges():
            SiC_recycled_share = 0
            TEG_recycled_share = 0
            if exc['name'] == 'triethylene glycol' :
                exc['amount'] = 0
                exc.save()
            
            if exc['name'] == 'silicon carbide' :
                exc['amount'] = 0
                exc.save()
            
            if exc['name'] == 'tap water' :
                exc['amount'] = exc['amount'] + 98.94
                exc.save()
                
            if exc['name'] == 'sintered diamond wire, steel' :
                exc['amount'] = 0.0006075
                exc.save()
        print("By selecting diamond wiring: it is advised to consider 15% less silicon used (translated into 15% less kerf loss) when compared to the traditional cutting process")
        
    elif DW==False:
        
        #Adjusting SiC, The data was extracted from KBOB:2016    
        #Adjusting TEG, The data was extracted from KBOB:2016 
        for exc in wafer_adjusted.exchanges():
            if exc['name'] == 'triethylene glycol' :
                exc['amount'] = 2.16548 * (1 - TEG_recycled_share) 
                exc.save()
            
            if exc['name'] == 'silicon carbide' :
                exc['amount'] = 2.02988 * (1 - SiC_recycled_share)
                exc.save()
            
            if exc['name'] == 'silicon carbide, recycled production':
                exc['amount'] = 2.02988 * SiC_recycled_share
                exc.save()
            
            if exc['name'] == 'triethylene glycol, recycled production':
                exc['amount'] = 2.16548 * TEG_recycled_share
                exc.save()
    
    #Adjusting the amount of electricity used
    for exc in wafer_adjusted.exchanges():
        if exc['name'] == 'electricity, medium voltage':
            exc['amount'] = 20 * (1 - manufacturing_efficiency_gains) # It was 8 but it was modified by ST to 20
            exc.save()
    #Adjusting the electricity used for manufacturing
    if elec_dataset != None:
        for exc in wafer_adjusted.exchanges():
            if exc['name'] == 'electricity, medium voltage':
                exc['input'] = elec_dataset.key
                exc.save()
                
    #Adding the 4 MJ natural gas used for the wafer as proposed by KBOB
    act = [act for act in eidb if 'at industrial furnace >100kW' in act['name'] and 'Europe' in act['location']][0]
    new_exc = wafer_adjusted.new_exchange(input = act.key, amount = 4, unit = 'megajoule', type = 'technosphere', name = act['name'])
    new_exc.save()
    
    #Adjusting the amount of solar grade silicon used
    #Amount calculated from wafer thickness and Silicon density (2328 kg/m3)
    for exc in wafer_adjusted.exchanges():
        if exc['name'] == 'silicon production, solar grade, modified Siemens process adjusted':
            exc['amount'] = wafer_thickness*1e-6 * 2328 / (1 - kerf_loss)
            if Silicon_dataset != None:
                exc['input'] = Silicon_dataset.key
                exc.save()
            exc.save()
        if exc['name'] == 'silicon casting activity':
            exc['amount'] = wafer_thickness*1e-6 * 2328 / (1 - kerf_loss)
            exc.save()
    
    wafer_adjusted.save()
    
    return wafer_adjusted
```

```{python}
wafer_adjusted = generate_wafer_dataset(SiC_recycled_share=0, 
                                        TEG_recycled_share = 0, 
                                        DW= False, manufacturing_efficiency_gains = 0, 
                                        kerf_loss = 0.50, wafer_thickness = 240, 
                                        elec_dataset = None,
                                        Silicon_dataset = None)
wafer_adjusted
```

```{python}
wafer_adjusted = [act for act in eidb if 'multi-Si wafer production adjusted' == act['name']][0]
wafer_adjusted
```

```{python}
wafer_ori = [act for act in eidb if 'multi-Si wafer production' == act['name'] and 'RER' in act['location']][0]
wafer_ori
```

```{python}
list_methods = set_of_methods
bw.calculation_setups['B_wafer_original'] = {'inv': [{wafer_ori:1} , {wafer_adjusted:1}], 'ia': list_methods}
myMultiLCA = bw.MultiLCA('B_wafer_original')
df_impact = pd.DataFrame(columns = list_methods, data = myMultiLCA.results)
df_impact
```

The wafer dataset is validated (126 kg-CO2-eq/m2 wafer) using a kerf loss of 0.55 and a wafer thickness of 240 micrometers as a standard scenario as proposed by Junglebeth et al. (2007)


The use of the DW cutting technique imposed less kerf loss. Hence, if DW = True and kerf_loss = 0.5-0.15 = 0.35. Hence, the impact of the wafer increases


At this level, there is a slight variation between 86 and 87 kg-CO2-eq / kWh caused by the DW parameter (! SOURCE OF THE ERROR NOT FOUND !). Yet, this error can be avoided by deleting the adjusted wafer each time before generating a new change.


The impact of the use of recycled SiC and recycled TEG is also contributing to a sligh reduction in the impacts


Thinner wafer is also important: by reducing wafer_thickness from 240 to 200 micrometers, the impacts are reduced by:

```{python}
wafer_adjusted = generate_wafer_dataset(SiC_recycled_share=0, 
                                        TEG_recycled_share = 0, 
                                        DW= True, 
                                        manufacturing_efficiency_gains = 0, 
                                        kerf_loss = 0.50-0.15,
                                        wafer_thickness = 200, 
                                        elec_dataset = None,
                                        Silicon_dataset = Silicon_adjusted)
wafer_adjusted
```

```{python}
list_methods = set_of_methods
bw.calculation_setups['B_wafer_original'] = {'inv': [{wafer_ori:1} , {wafer_adjusted:1}], 'ia': list_methods}
myMultiLCA = bw.MultiLCA('B_wafer_original')
df_impact = pd.DataFrame(columns = list_methods, data = myMultiLCA.results)
df_impact
```

```{python}
(126.61-47.61)/126.61*100
```

Comparing the 2 results: original dataset and same modified dataset + DW = True. It can be seen that there is an important reduction of the impact that can range between 60-65% approximately for the climate change. This reduction is even more important when the emerging cutting process is adapted where the diamond wire technique is used (around 20.5% reduction in comparision with DW=False as shown in the following cells).

```{python}
wafer_adjusted = generate_wafer_dataset(SiC_recycled_share=0.694, 
                                        TEG_recycled_share = 0.899, 
                                        DW= False, 
                                        manufacturing_efficiency_gains = 0, 
                                        kerf_loss = 0.44,
                                        wafer_thickness = 200, 
                                        elec_dataset = None,
                                        Silicon_dataset = Silicon_adjusted)
wafer_adjusted
```

```{python}
list_methods = set_of_methods
bw.calculation_setups['B_wafer_original'] = {'inv': [{wafer_ori:1} , {wafer_adjusted:1}], 'ia': list_methods}
myMultiLCA = bw.MultiLCA('B_wafer_original')
df_impact = pd.DataFrame(columns = list_methods, data = myMultiLCA.results)
df_impact
```

```{python}
(59.91-47.61)/59.91*100
```

## PV cell manufacturing


This section generates a PV cell dataset with the possibility to modify 9 parameters and adapt them accoding to the user's systems. These parameters are explained in the following cells.

```{python}
pv_cell = [act for act in eidb if 'photovoltaic cell production, multi-Si wafer' == act['name'] and 'RER' in act['location']][0]
pv_cell  
```

```{python}
#Let's start by adding copper dataset to the photovoltaic cell production
#The value is set to 0 copper based metallization paste but can be adjusted in the functions !
pv_cell_with_copper = [act for act in eidb if 'photovoltaic cell production, multi-Si wafer with copper' == act['name']]

if pv_cell_with_copper == []:
    pv_cell = [act for act in eidb if 'photovoltaic cell production, multi-Si wafer' == act['name'] and 'RER' in act['location']][0]
    pv_cell_with_copper = pv_cell.copy()
    pv_cell_with_copper['name'] = 'photovoltaic cell production, multi-Si wafer with copper'
    pv_cell_with_copper['authors'] = 'Romain Besseau'
    pv_cell_with_copper['comment'] = 'Copy of photovoltaic cell production, multi-Si wafer with the possibility to substitue Silver metal metallization paste by Copper metalization paste. The amount to Cu metal paste is initial set to 0.'
    
    metal_paste_copper = [act for act in eidb if 'metallization paste production, back side, copper' in act['name'] ][0]
    
    new_exc = pv_cell_with_copper.new_exchange(input = metal_paste_copper.key, name = metal_paste_copper['name'], amount = 0, unit = metal_paste_copper['unit'], type = 'technosphere')
    new_exc.save()
        
    pv_cell_with_copper.save()

pv_cell_with_copper = [act for act in eidb if 'photovoltaic cell production, multi-Si wafer with copper' == act['name']][0]
pv_cell_with_copper
```

```{python}
def generate_pv_cell_dataset(SiC_recycled_share=0.694, 
                             TEG_recycled_share = 0.899, 
                             DW = False,
                             manufacturing_efficiency_gains = 0, 
                             kerf_loss = 0.44, 
                             wafer_thickness = 200, 
                             silver_amount = 9.6, 
                             Silicon_electricity_intensity = 30+10, 
                             elec_dataset = None, 
                             print_steps = False):
    '''
    This function generates a PV cell dataset with the possibility to regulate the amount of silver used
    while the code automatically replaces the reduced amount of silver by copper based on the difference of conductivity.
    This done by controlling the silver_amount paramter expressed in g/m2.
    SiC_recycled_share is the amount of recycled SiC expressed in fraction/percentage.
    TEG_recycled_share is the amount of recycled TEG expressed in fraction/percentage.
    Diamond wiring technology represented by the boolean paramter DW (True/False).It affects the use of
    SiC, TEG, diamond wire, and water (and indirectly the kerf_loss parameter that should be modified by the user).
    manufacturing_efficiency_gains parameter is expressed in fraction/percentage.
    The amount of wafer is also adjusted considering the wafer_thickness parameter (expressed in micrometer)
    The kerf loss representing the losses resulted from the cutting process is expressed in a fraction/percentage 
    The Silicon_electricity_intensity is expressed in kWh/m2.    
    '''
    initial_dataset = 'photovoltaic cell production, multi-Si wafer with copper'
    pv_cell_adjusted = [act for act in eidb if initial_dataset + ' adjusted' == act['name'] and 'RER' in act['location']]
    
    if pv_cell_adjusted == []: 
        pv_cell = [act for act in eidb if initial_dataset in act['name'] and 'RER' in act['location']][0]
        pv_cell_adjusted = pv_cell.copy()
        pv_cell_adjusted['name'] = initial_dataset + ' adjusted'
        pv_cell_adjusted['authors'] = 'Romain Besseau'
        pv_cell_adjusted['comment'] = 'Dataset adjusted with the amount of silver, silicon and electricy adjusted and the corresponding datasets'
        
        #Changing output of flows        
        for exc in pv_cell_adjusted.exchanges():
            exc['output'] = pv_cell_adjusted.key
            exc.save()
            
        #Changing the silicon wafer name
        for exc in pv_cell_adjusted.exchanges():
            if exc['name'] == 'multi-Si wafer':
                exc['name'] = 'Silicon wafer adjusted'
                exc.save()
        
        pv_cell_adjusted.save()        
        
    else:
        pv_cell = [act for act in eidb if initial_dataset == act['name'] and 'RER' in act['location']][0]
        pv_cell_adjusted = [act for act in eidb if initial_dataset + ' adjusted' == act['name']][0]
        
    #Adapting the amount of Silver used for the metallic contact
    #By default, for the front side : 7.4 g/m² Silver based paste corresponding to 6.2 g/m² of Ag (84% Silver)
    #By default, for the back side : 4.9 g/m² Silver based paste corresponding to 3.3 g/m² of Ag (67% Silver)
    #An additional 0.7 g of Ag is used is anyway considered for the panel.

    #Changing the use of Silver metallization paste
    if print_steps :
        print('Changing metallization processes')
    for exc in pv_cell_adjusted.exchanges():
        if exc['name'] == 'metallization paste, front side':
            exc['amount'] = np.max([7.4e-3 * (silver_amount - 0.7)  / (6.2 + 3.3), 0])
            exc.save()
            new_front_silver_amount = 0.84 * exc['amount']
            if print_steps :
                print('Front silver amount: %s g/m²'%(1e3*new_front_silver_amount))
    for exc in pv_cell_adjusted.exchanges():
        if exc['name'] == 'metallization paste, back side' :
            exc['amount'] = np.max([4.9e-3 * (silver_amount - 0.7)  / (6.2 + 3.3), 0])
            exc.save()
            new_back_silver_amount = 0.67 * exc['amount']
            if print_steps :
                print('Back silver amount: %s g/m²'%(1e3*new_back_silver_amount))
    #Adding copper paste used to substitute the amount of Silver used.
    #The amount of copper is calculated considering the difference of conductivity between Ag and Cu
    #Conductiviy of Ag = 6.3e7 S/m, Cu = 5.96e7 S/m at 20°C
    for exc in pv_cell_adjusted.exchanges():
        if exc['name'] == 'metallization paste production, back side, copper' :
            exc['amount'] = np.max([1/0.67 * 6.3e7 / 5.96e7 * ( 9.6e-3 - (new_front_silver_amount + new_back_silver_amount) ) , 0])
            exc.save()
            new_copper_amount = 0.67 * exc['amount']
            if print_steps :
                print('Copper amount: %s g/m²'%(1e3*new_copper_amount))
    
    #Adjusting the electricity used for manufacturing
    #Initially, PV cell manufacturing require 30.243 kWh/m²
    if print_steps :
        print('Changing electricity processes')
    for exc in pv_cell_adjusted.exchanges():
        if exc['name'] == 'electricity, medium voltage':
            exc['amount'] = 30.243 * (1 - manufacturing_efficiency_gains)
            if elec_dataset != None:
                exc['input'] = elec_dataset.key
            exc.save()
    
    #Adjusting the wafer dataset used
    if print_steps :
        print('Changing Silicon processes')
    Silicon_adjusted = generate_silicon_dataset(Silicon_electricity_intensity = Silicon_electricity_intensity, elec_dataset = elec_dataset)
    if print_steps :
        print('Changing wafer processes')
    wafer_adjusted = generate_wafer_dataset(SiC_recycled_share = SiC_recycled_share, TEG_recycled_share = TEG_recycled_share, DW = DW, manufacturing_efficiency_gains = manufacturing_efficiency_gains, kerf_loss = kerf_loss, wafer_thickness = wafer_thickness, elec_dataset = elec_dataset, Silicon_dataset = Silicon_adjusted)
    
    for exc in pv_cell_adjusted.exchanges():
            if exc['name'] == 'Silicon wafer adjusted':
                exc['input'] = wafer_adjusted.key
                exc.save()
                
    #Metal content
    for exc in pv_cell_adjusted.exchanges():
        if exc['name'] == 'Tin':
            tin_amount = exc['amount']
        if exc['name'] == 'Aluminium':
            aluminium_amount = exc['amount']
    
    metal_content_dict = {'Silver': silver_amount*1e-3, 'Tin': tin_amount, 'Copper': new_copper_amount, 'Aluminium': aluminium_amount}
    return pv_cell_adjusted, metal_content_dict #output in m²
```

```{python}
pv_cell_adjusted, metal_dict = generate_pv_cell_dataset(SiC_recycled_share=0,
                                                        TEG_recycled_share = 0,
                                                        DW = False,
                                                        manufacturing_efficiency_gains = 0,
                                                        kerf_loss = 0.5, 
                                                        wafer_thickness = 240,
                                                        silver_amount = 11.2,
                                                        Silicon_electricity_intensity = 110+19.5,
                                                        elec_dataset = None, 
                                                        print_steps = True)
pv_cell_adjusted
```

```{python}
pv_cell = [act for act in eidb if 'photovoltaic cell production, multi-Si wafer with copper' == act['name']][0]
pv_cell
```

```{python}
pv_cell_adjusted = [act for act in eidb if 'photovoltaic cell production, multi-Si wafer with copper adjusted' in act['name']][0]
pv_cell_adjusted
```

```{python}
#The impacts of these 2 datasets: pv_cell and pv_cell_adjusted is as follows
list_methods = set_of_methods
bw.calculation_setups['B_pv_cell_validation'] = {'inv': [{pv_cell:1}, {pv_cell_adjusted:1}], 'ia': list_methods}
myMultiLCA = bw.MultiLCA('B_pv_cell_validation')
df_impact = pd.DataFrame(columns = list_methods, data = myMultiLCA.results)
df_impact
```

PARASOL_LCA wafer is validated when compared to the original ecoinvent 3.4 dataset with a less than 1% difference (161.6 and 162,8 kg-CO2-eq/m2)

```{python}
(161.59-162.85)/161.59*100
```

```{python}
pv_cell_adjusted, metal_dict = generate_pv_cell_dataset(SiC_recycled_share=0.694,
                                                        TEG_recycled_share = 0.899,
                                                        DW = False,
                                                        manufacturing_efficiency_gains = 0,
                                                        kerf_loss = 0.44, 
                                                        wafer_thickness = 200,
                                                        silver_amount = 9.6,
                                                        Silicon_electricity_intensity = 30+10,
                                                        elec_dataset = None, 
                                                        print_steps = True)
pv_cell_adjusted
```

```{python}
pv_cell_adjusted = [act for act in eidb if 'photovoltaic cell production, multi-Si wafer with copper adjusted' in act['name']][0]
pv_cell_adjusted
```

```{python}
#So let's compare the results, this is the original dataset with 0 copper 
pv_cell = [act for act in eidb if 'photovoltaic cell production, multi-Si wafer with copper' == act['name'] and 'RER' in act['location']][0]
pv_cell
```

```{python}
#and this is the adjusted pv cell with all the adapted modification in the function generate_pv_cell_dataset
DF = pd.concat([print_data(pv_cell),print_data(pv_cell_adjusted)], axis = 1, keys = ['original', 'adjusted'])
DF
```

```{python}
#The impacts of these 2 datasets: pv_cell and pv_cell_adjusted is as follows
list_methods = set_of_methods
bw.calculation_setups['B_pv_cell'] = {'inv': [{pv_cell:1}, {pv_cell_adjusted:1}], 'ia': list_methods}
myMultiLCA = bw.MultiLCA('B_pv_cell')
df_impact = pd.DataFrame(columns = list_methods, data = myMultiLCA.results)
df_impact
```

```{python}
(161.59-90.19)/161.59*100
```

There is a reduction of the 44 % of the climate change impact (kg-CO2-eq). This can go to lower values if DW is used.


## PV module manufacturing


This is where most of the modifications are accomplished to adjust the manufacturing of the wafer by controlling 16 parameters.
In addition the recycling activities were added to represent the cradle-to-grade aspect of the study.

```{python}
#Recycling activity for panel
scrap_glass = [act for act in eidb if 'market for waste glass sheet' in act['name'] and 'Europe' in act['location']][0]
print(scrap_glass)
scrap_aluminium = [act for act in eidb if 'market for scrap alu' in act['name'] and 'Europe' in act['location']][0]
print(scrap_aluminium)
scrap_copper = [act for act in eidb if 'market for scrap copper' in act['name'] and 'Europe' in act['location']][0]
print(scrap_copper)
```

```{python}
#Heat for recycling
heat_for_recycling = [act for act in eidb if 'heat and power co-generation, biogas, gas engine' in act['name'] and 'RoW' in act['location'] and act['unit'] == 'megajoule'][0]
heat_for_recycling
```

```{python}
def generate_panel_dataset(SiC_recycled_share=0.694,
                           TEG_recycled_share = 0.899,
                           DW = False,
                           glass_thickness = 4, 
                           aluminium_dataset = alu_adjusted,
                           elec_dataset = None,
                           manufacturing_efficiency_gains = 0,
                           kerf_loss = 0.44, 
                           wafer_thickness = 200, 
                           silver_amount = 9.6, 
                           Silicon_electricity_intensity = 30+10,
                           print_steps = True, 
                           recycling_rate_alu = 0.96, 
                           recycling_rate_cu = 0.75, 
                           recycling_rate_glass = 0.9,
                           electricity_recycling = 50,
                           heat_recycling = 76):
    
    #the 3 recycling rates can be substituted by 1 total recovery rate which ranges
    #between 0.75 and 0.92 according to Stolz et al.(2017) if not enough information is provided.
    
    '''
    This function generates 1 m2 PV panel dataset.
    SiC_recycled_share is the amount of recycled SiC expressed in fraction/percentage.
    TEG_recycled_share is the amount of recycled TEG expressed in fraction/percentage.
    Diamond wiring technology represented by the boolean paramter DW (True/False).I affects the use of
    SiC, TEG, diamond wire, and water.
    manufacturing_efficiency_gains parameter is expressed in fraction/percentage.
    The amount of wafer is also adjusted considering the wafer_thickness parameter (expressed in micrometer)
    The kerf loss representing the losses resulted from the cutting process is expressed in a fraction/percentage 
    The Silicon_electricity_intensity is expressed in kWh/m2.
    
    The recycling_rate_alu, recycling_rate_cu, recycling_rate_glass are the
    recycling rate of the aluminum, copper, and glass respectively expressed in a fraction/percentage.
    The electricity_recycling represents the amount of electricty used for recycling (expressed in kWh/ton)
    The heat_recycling represents the amount of heat used for recycling (expressed in MJ/ton)
    
    '''
    initial_dataset = 'photovoltaic panel production, multi-Si wafer'
    ##SCA changed it from RoW to RER
    panel_adjusted = [act for act in eidb if initial_dataset + ' adjusted' in act['name'] and 'RER' in act['location']]
    
    if panel_adjusted == []: 
        panel = [act for act in eidb if initial_dataset in act['name'] and 'RER' in act['location']][0]
        panel_adjusted = panel.copy()
        panel_adjusted['name'] = initial_dataset + ' adjusted'
        panel_adjusted['authors'] = 'Romain Besseau'
        panel_adjusted['comment'] = 'Dataset adjusted with the glassthickness, aluminium, electrciity, manufacturing efficienciy gains, kerf loss, wafer thickness, silver amount and Silicon electricity content'
        
                
        for exc in panel_adjusted.exchanges():
            exc['output'] = panel_adjusted.key
            exc.save()
            
        #Adding aluminium recycling
        new_exc = panel_adjusted.new_exchange(input = scrap_aluminium.key, name = scrap_aluminium['name'], amount = 0, unit = scrap_aluminium['unit'], type = 'technosphere')
        new_exc.save() 

        #Adding copper recycling
        new_exc = panel_adjusted.new_exchange(input = scrap_copper.key, name = scrap_copper['name'], amount = 0, unit = scrap_copper['unit'], type = 'technosphere')
        new_exc.save()

        #Adding glass recycling
        new_exc = panel_adjusted.new_exchange(input = scrap_glass.key, name = scrap_glass['name'], amount = 0, unit = scrap_glass['unit'], type = 'technosphere')
        new_exc.save()
        
        #Adding electricity for recycling
        if elec_dataset == None:
            elec_dataset = [act for act in eidb if 'market group for electricity, medium voltage' == act['name'] and 'ENTSO-E' == act['location']][0]
        new_exc = panel_adjusted.new_exchange(input = elec_dataset.key, name = 'electricity for recycling', amount = 0, unit = elec_dataset['unit'], type = 'technosphere')
        new_exc.save()

        #Heat for recycling
        heat_for_recycling = [act for act in eidb if 'heat and power co-generation, biogas, gas engine' in act['name'] and 'RoW' in act['location'] and act['unit'] == 'megajoule'][0]
        new_exc = panel_adjusted.new_exchange(input = heat_for_recycling.key, name = 'heat for recycling', amount = 0, unit = heat_for_recycling['unit'], type = 'technosphere')
        new_exc.save()
        
        panel_adjusted.save()        
        
    else:
        panel = [act for act in eidb if initial_dataset in act['name'] and 'RoW' in act['location']][0]
        panel_adjusted = [act for act in eidb if initial_dataset + ' adjusted' in act['name']][0]
        
    #Adjusting the aluminium dataset
    for exc in panel_adjusted.exchanges():
        if exc['name'] == 'aluminium alloy, AlMg3':
            exc['name'] = aluminium_dataset['name']
            exc['input'] = aluminium_dataset.key
            exc.save()
    
    #Adjusting the electricity used for manufacturing
    if elec_dataset != None:
        for exc in panel_adjusted.exchanges():
            if exc['name'] == 'electricity, medium voltage':
                exc['input'] = elec_dataset.key
                exc['name'] = elec_dataset['name']
                exc.save()
    
    #Adjusting the glass thickness
    #Glass density 2.5 kg/(m²*mm)
    for exc in panel_adjusted.exchanges():
        if exc['name'] == 'solar glass, low-iron' or exc['name'] == 'tempering, flat glass':
            exc['amount'] = glass_thickness * 2.5 * 1
            exc.save()
    
    #Adjusting photovoltaic cell, multi-Si wafer
    #Creating an adjusted dataset
    if print_steps:
        print('Changing cell production process')
    pv_cell_adjusted, metal_dict = generate_pv_cell_dataset(SiC_recycled_share=SiC_recycled_share, TEG_recycled_share = TEG_recycled_share,
                                                            DW=DW, manufacturing_efficiency_gains = manufacturing_efficiency_gains,
                                                            kerf_loss = kerf_loss, wafer_thickness = wafer_thickness, 
                                                            silver_amount = silver_amount, 
                                                            Silicon_electricity_intensity = Silicon_electricity_intensity,
                                                            elec_dataset = elec_dataset, print_steps = print_steps)

    for exc in panel_adjusted.exchanges():
        if exc['name'] == 'photovoltaic cell, multi-Si wafer':
            exc['input'] = pv_cell_adjusted.key
            exc['name'] = pv_cell_adjusted['name']
            exc.save()
    
    #Panel recycling
    #Amount contained in the pv cells
    m_aluminium = metal_dict['Aluminium']
    m_copper = metal_dict['Copper']
    m_silver = metal_dict['Silver']
    m_tin = metal_dict['Tin']
    m_glass = 0
    
    #Other recyclable product in pv panel
    for exc in panel_adjusted.exchanges():
        if exc['name'] == 'aluminium alloy, AlMg3':
            m_aluminium +=exc['amount']
        if exc['name'] == 'copper':
            m_copper +=exc['amount']
        if exc['name'] == 'solar glass, low-iron':
            m_glass += exc['amount']
            
    #Changing the amount of metal to recycle and heat and energy used
    for exc in panel_adjusted.exchanges():
        if exc['name'] == scrap_aluminium['name']:
            exc['amount'] = m_aluminium*recycling_rate_alu
            exc.save()
            
        if exc['name'] == scrap_copper['name']:
            exc['amount'] = m_copper*recycling_rate_cu
            exc.save()
        
        if exc['name'] == scrap_glass['name']:
            exc['amount'] = m_glass*recycling_rate_glass
            exc.save()
                   
        #Energy for recycling 
        #Life Cycle Inventory of Current Photovoltaic  Module Recycling Processes in Europe  PVPS task 12
        #50 kWh/t for the mechanical processes plus about 76 kWhequivalent of natural gas per ton
        #1.6 m² of pv panel weight around 20 kg  
        if exc['name'] == 'electricity for recycling':
            exc['amount'] = electricity_recycling * (20e-3/1.6)
            exc.save()
            if elec_dataset != None:
                exc['input'] = elec_dataset.key
                exc.save()
        
        if exc['name'] == 'heat for recycling':
            exc['amount'] = heat_recycling * (20e-3/1.6) / 3.6
            exc.save()
                    
    panel_adjusted.save()
                
    return panel_adjusted #output in m²
```

```{python}
panel_adjusted = generate_panel_dataset(SiC_recycled_share=0,
                                        TEG_recycled_share = 0,
                                        DW = False, 
                                        glass_thickness = 4, 
                                        aluminium_dataset = alu_original, 
                                        elec_dataset = None,
                                        manufacturing_efficiency_gains = 0, 
                                        kerf_loss = 0.5,
                                        wafer_thickness = 240, 
                                        silver_amount = 11.2,
                                        Silicon_electricity_intensity = 110+19.5, 
                                        print_steps = True, 
                                        recycling_rate_alu = 0, 
                                        recycling_rate_cu = 0, 
                                        recycling_rate_glass = 0,
                                        electricity_recycling = 0, 
                                        heat_recycling = 0)
```

```{python}
panel_adjusted = [act for act in eidb if 'photovoltaic panel production, multi-Si wafer adjusted' in act['name']][0]
panel_adjusted
```

```{python}
panel_ori = [act for act in eidb if 'photovoltaic panel production, multi-Si wafer' == act['name'] and 'RER' in act['location']][0]
panel_ori
```

```{python}
#The comparision of the original and the modified panel is represented as follows:
list_methods = set_of_methods
bw.calculation_setups['B_pv_panel'] = {'inv': [{panel_ori:1}, {panel_adjusted:1}], 'ia': list_methods}
myMultiLCA = bw.MultiLCA('B_pv_panel')
df_impact = pd.DataFrame(columns = list_methods, data = myMultiLCA.results)
df_impact
```

```{python}
(206.31-194.64)/206.31*100
```

There is a slight difference of 5% at the validation level, it can be from the transport or from dataset replacement. (SOURCE NOT FOUND)

```{python}
panel_adjusted = generate_panel_dataset(SiC_recycled_share=0, 
                                          TEG_recycled_share = 0,
                                          DW = True, 
                                          glass_thickness = 4,
                                          aluminium_dataset = alu_original,
                                          elec_dataset = None,
                                          manufacturing_efficiency_gains = 0, 
                                          kerf_loss = 0.44-0.15, 
                                          wafer_thickness = 200, 
                                          silver_amount = 9.6,
                                          Silicon_electricity_intensity = 30+10,
                                          print_steps = True, 
                                          recycling_rate_alu = 0.96, 
                                          recycling_rate_cu = 0.75,
                                          recycling_rate_glass = 0.9,
                                          electricity_recycling = 50, 
                                          heat_recycling = 76)
```

```{python}
#The comparision of the original and the modified panel is represented as follows:
list_methods = set_of_methods
bw.calculation_setups['B_pv_panel'] = {'inv': [{panel_ori:1}, {panel_adjusted:1}], 'ia': list_methods}
myMultiLCA = bw.MultiLCA('B_pv_panel')
df_impact = pd.DataFrame(columns = list_methods, data = myMultiLCA.results)
df_impact
```

```{python}
(206.32-113.42)/206.32*100
```

The adjusted panel has less CO2 emissions of 45.03% per m2 panel compared to an original ecoinvent 3.4 dataset.

```{python}
panel = [act for act in eidb if 'photovoltaic panel production, multi-Si wafer' == act['name'] and 'RoW' in act['location']][0]
panel_adjusted = [act for act in eidb if 'photovoltaic panel production, multi-Si wafer' + ' adjusted' == act['name']][0]
```

```{python}
DF = pd.concat([print_data(panel),print_data(panel_adjusted)], axis = 1, keys = ['original', 'adjusted'])
DF
```

## Final function generating inventories


This section calls for all the previously defined datasets to stock them in a dictionary and prepare them to be the system inventory that will be analyzed in the following section (Part_2). 

```{python}
def add_to_dict(dictionary, key, value):
    if key not in dictionary:
         dictionary[key] = value
    else:
         dictionary[key] = dictionary[key] + value
```

```{python}
#Select the electricity dataset of your choice (that will be used for manufacturing electricity intensive part of the PV system)
#For European context
#elec_dataset = [act for act in eidb if 'market group for electricity, medium voltage' == act['name'] and 'ENTSO-E' == act['location']][0]
#elec_dataset
```

```{python}
elec_dataset = [act for act in eidb if 'market for electricity, high voltage' == act['name'] and 'RoW' == act['location']][0]
elec_dataset
```

```{python}
#Dataset for diesel burned in buidling machine for site preparation of ground installed power plant.
diesel_burned = [act for act in eidb if 'market for diesel, burned in building machine' in act['name']][0]
diesel_burned
```

```{python}
#Dataset for transport
transport_car = [act for act in eidb if 'transport, passenger car, large size, petrol, EURO 5' in act['name'] and 'RER' in act['location']][0]
print(transport_car)
transport_van = [act for act in eidb if 'transport, freight, light commercial vehicle' in act['name'] and 'Europe' in act['location']][0]
print(transport_van)
transport_lorry = [act for act in eidb if 'transport, freight, lorry, all sizes, EURO6 to generic market for transport, freight, lorry, unspecified' in act['name'] and 'RER' in act['location']][0]
print(transport_lorry)
transport_train = [act for act in eidb if 'transport, freight train, electricity' in act['name'] and 'RoW' in act['location']][0]
print(transport_train)
transport_sea = [act for act in eidb if 'transport, freight, sea, transoceanic ship' == act['name'] and 'GLO' in act['location']][0]
print(transport_sea)
```

```{python}
def create_dictionary_PV_system(P = None, 
                                P_module = 200,
                                module_efficiency = None, 
                                roof = True,
                                share_recycled_aluminium = 0.27, 
                                elec_dataset = None, 
                                inverter_weight = None,  
                                print_steps = True, 
                                inverter_lifetime = 15,
                                PV_lifetime = 30,
                                glass_thickness = 4,
                                recycling_rate = 0,
                                manufacturing_efficiency_gains = 0,
                                kerf_loss = 0.44, 
                                wafer_thickness = 200, 
                                silver_amount = 9.6, 
                                Silicon_electricity_intensity = 30+10,
                                SiC_recycled_share=0.694, 
                                TEG_recycled_share = 0.899, 
                                DW=False, 
                                d_lorry = 1020, 
                                d_train = 350, 
                                d_sea = 4000,
                                recycling_rate_alu = 0.96, 
                                recycling_rate_cu = 0.75,
                                recycling_rate_glass = 0.9,
                                electricity_recycling = 50,
                                heat_recycling = 76):
    """
    This function generate a lifecycle inventory of a PV system
    List of parameters : P (system power) expressed in kWp,
    P_module (rated power) expressed in Wp, 
    module efficiency in %, 
    roof = True/False (True by default), share_recycled_aluminium in %,
    inverter_weight in kg, inverter_lifetime and PV_lifeytime in years,
    glass_thickness in mm, manufacturing_efficiency_gains in %, kerf_loss in%,
    wafer_thickness = 200 in micrometer, silver_amount in g/m2, 
    Silicon_electricity_intensity in kWh/kg, SiC_recycled_share and TEG_recycled_share in %, 
    DW = True/False (False by default), d_lorry , d_train , and d_sea in tkm,
    recycling_rate_alu, recycling_rate_cu, recycling_rate_glass in %,
    electricity_recycling in kWh/t, heat_recycling in MJ/t.
    """
    dict_activities={}
    
    #Adding activities for mounting system
    surface_module = 1.6 #Module surface in m²
    if P_module != None:
        module_efficiency = P_module / surface_module / 1000
    if module_efficiency != None:
        P_module = module_efficiency * surface_module * 1000
    if print_steps:
        print('System power: %s kWp'%P)
        print('PV module power: %s Wp'%P_module)
        print('Module efficiency: %s percent'%(module_efficiency*100))
    
    surface  = P*1e3 / P_module * surface_module
    
    if print_steps:
        print('Surface occupied: %s m²'%surface)
    if roof:
        mounting_system = 'photovoltaic mounting system production, for slanted-roof installation with recycling'
    else:       
        mounting_system = 'photovoltaic mounting system production, for 570kWp open ground module'
        #Adding diesel burned in machine for site preparation
        #7673 MJ were accounted for the 570 kWp power plant
        add_to_dict(dict_activities, key = diesel_burned, value = P/570 * 7673)
    
    #Creating an adjusted dataset for the aluminium alloy
    if print_steps:
        print('Creating aluminium dataset')
    alu_adjusted =  generate_aluminium_alloy_dataset(share_recycled_aluminium = share_recycled_aluminium, elec_dataset = elec_dataset) 
        
    #Creating an adjusted dataset for the mounting system
    if print_steps:
        print('Creating mounting system dataset')
    mounting_system_adjusted = generate_mounting_system_dataset(aluminium_dataset = alu_adjusted, initial_dataset = mounting_system)
    #Adding mounting system to the inventory
    add_to_dict(dict_activities, key = mounting_system_adjusted, value = surface)
    
    
    #Adding activities for electrical installation
    weight_of_electrical_installation = electrical_installation_weight(P)
    if print_steps:
        print('Electrical installation weight: %s kg'%weight_of_electrical_installation)     
    #Electrical installation for 3 kW system weight 33 kg                
    add_to_dict(dict_activities, key = electrical_installation_3kW, value = weight_of_electrical_installation/33)
    
    #Adding activities for inverter
    inverter_P_per_kg = generate_inverter_dataset(P = P, elec_dataset = elec_dataset, recycling_rate = recycling_rate)
    if inverter_weight == None:
        #By default 2 kg/kW (cf analysis of SMA data)
        inverter_weight = 2 * P
    if print_steps:
        print('Inverter weight: %s kg'%inverter_weight)     
    add_to_dict(dict_activities, key = inverter_P_per_kg, 
                value = inverter_weight * PV_lifetime /inverter_lifetime)
    
    
    #Adding pv panel adjusted
    alu_adjusted = [act for act in eidb if 'aluminium alloy production, AlMg3 adjusted' == act['name'] and 'RER' in act['location']][0]
    if print_steps:
        print('Creating panel production processes')
    panel_adjusted = generate_panel_dataset(SiC_recycled_share=SiC_recycled_share, TEG_recycled_share = TEG_recycled_share, DW= DW, 
                                            glass_thickness = glass_thickness, aluminium_dataset = alu_adjusted, elec_dataset = elec_dataset,
                                            manufacturing_efficiency_gains = manufacturing_efficiency_gains, kerf_loss = kerf_loss, wafer_thickness = wafer_thickness,
                                            silver_amount = silver_amount, Silicon_electricity_intensity = Silicon_electricity_intensity, print_steps = print_steps,
                                            recycling_rate_alu = recycling_rate_alu, recycling_rate_cu = recycling_rate_cu, recycling_rate_glass = recycling_rate_glass,
                                            electricity_recycling = electricity_recycling, heat_recycling = heat_recycling)
        

    add_to_dict(dict_activities, key = panel_adjusted, value = surface)
 
    #Adding transport 
    if print_steps:
        print('Adding transport activities')
    #for engineers for feasability study (100 - 200 km)
    add_to_dict(dict_activities, key = transport_car, value = 150)
    #for maintenance
    add_to_dict(dict_activities, key = transport_van, value = (inverter_weight*1e-3) * 100 * (PV_lifetime/inverter_lifetime))
    #for material
    #PV panel weiht around 20 kg, 
    m_total = ((surface / surface_module)*20 + weight_of_electrical_installation + inverter_weight * PV_lifetime / inverter_lifetime)*1e-3
    #by lorry
    add_to_dict(dict_activities, key = transport_lorry, value = m_total*d_lorry)
    #by train
    add_to_dict(dict_activities, key = transport_train, value = m_total*d_train)
    #by boat
    add_to_dict(dict_activities, key = transport_sea, value = m_total*d_sea)
      
    #Recycling activities already containted in the previously called dataset
    
    return dict_activities           
```

```{python}
   system_inv = create_dictionary_PV_system(P = 10, 
                                            P_module = 200,
                                            module_efficiency = None, 
                                            roof = True,
                                            share_recycled_aluminium = 0.27, 
                                            elec_dataset = None, 
                                            inverter_weight = None,  
                                            print_steps = True, 
                                            inverter_lifetime = 15,
                                            PV_lifetime = 30,
                                            glass_thickness = 4,
                                            recycling_rate = 0,
                                            manufacturing_efficiency_gains = 0,
                                            kerf_loss = 0.44, 
                                            wafer_thickness = 200, 
                                            silver_amount = 9.6, 
                                            Silicon_electricity_intensity = 30+10,
                                            SiC_recycled_share=0.694, 
                                            TEG_recycled_share = 0.899, 
                                            DW=False, 
                                            d_lorry = 1020, 
                                            d_train = 350, 
                                            d_sea = 4000,
                                            recycling_rate_alu = 0.96, 
                                            recycling_rate_cu = 0.75,
                                            recycling_rate_glass = 0.9,
                                            electricity_recycling = 50,
                                            heat_recycling = 76)
```

```{python}
#The system inventory can be summarized as follows:
system_inv
```

```{python}
def generate_PV_system_dataset(system_inv):
    if [act for act in eidb if 'photovoltaic installation, adjusted' == act['name']] == []:

        act_original=[act for act in eidb if 'photovoltaic slanted-roof installation, 3kWp, multi-Si, panel, mounted, on roof'
                      in act['name'] and 'RoW' in act['location']][0]

        new_act=act_original.copy()
        new_act['name'] = 'photovoltaic installation, adjusted'
        new_act['unit'] = 'unit'  
        new_act['location'] = 'GLO'
        new_act['comment'] = 'Dataset corresponding to a PV system without storage created from the dictionary \
                            created by the create_dictionary_PV_system() function'
        new_act.save()

        for exc in new_act.exchanges():
            exc.delete()
        new_act.save()

    act_to_adjust = [act for act in eidb if 'photovoltaic installation, adjusted' == act['name']][0]

    for exc in act_to_adjust.exchanges():
        exc.delete()
    act_to_adjust.save()

    for act in system_inv:
        new_exc = act_to_adjust.new_exchange(input = act.key, amount = system_inv[act], unit = act['unit'], type = 'technosphere', name = act['name'])
        new_exc.save()
    act_to_adjust.save()

    #output
    new_exc = act_to_adjust.new_exchange(input = act_to_adjust.key, amount = 1, unit = 'unit',categories='',type='production', name = act_to_adjust['name'])
    new_exc.save()
    act_to_adjust.save()
    
    act_to_adjust = [act for act in eidb if 'photovoltaic installation, adjusted' == act['name']][0]
    
    return act_to_adjust
```

```{python}
system_adjusted = generate_PV_system_dataset(system_inv)
system_adjusted
```

```{python}
act=system_adjusted
df = pd.DataFrame(index = ['amount','unit','key','type'])
for (i,exc) in enumerate(act.exchanges()):
    df[str(bw.get_activity(exc.input.key))] = [exc.amount, exc.unit, exc.input.key,exc['type']]
df.T
```

```{python}
system_adjusted
```

```{python}
list_methods = set_of_methods
bw.calculation_setups['B_system'] = {'inv': [{system_adjusted:1}], 'ia': list_methods}
myMultiLCA = bw.MultiLCA('B_system')
df_impact = pd.DataFrame(columns = list_methods, data = myMultiLCA.results)
df_impact 
```

```{python}
12878/10
```

```{python}
system_inv = create_dictionary_PV_system(P = 3, 
                                        P_module = 210,
                                        module_efficiency = None, 
                                        roof = True,
                                        share_recycled_aluminium = 0, 
                                        elec_dataset = None, 
                                        inverter_weight = None,  
                                        print_steps = False, 
                                        inverter_lifetime = 12.5,
                                        PV_lifetime = 30,
                                        glass_thickness = 4,
                                        recycling_rate = 0,
                                        manufacturing_efficiency_gains = 0,
                                        kerf_loss = 0.55, 
                                        wafer_thickness = 270, 
                                        silver_amount = 11.2, 
                                        Silicon_electricity_intensity = 110+10,
                                        SiC_recycled_share=0, 
                                        TEG_recycled_share = 0, 
                                        DW=False, 
                                        d_lorry = 1020, 
                                        d_train = 350, 
                                        d_sea = 4000,
                                        recycling_rate_alu = 0, 
                                        recycling_rate_cu = 0,
                                        recycling_rate_glass = 0,
                                        electricity_recycling = 0,
                                        heat_recycling = 0)
system_adjusted = generate_PV_system_dataset(system_inv)
list_methods = set_of_methods
bw.calculation_setups['B_system'] = {'inv': [{system_adjusted:1}], 'ia': list_methods}
myMultiLCA = bw.MultiLCA('B_system')
df_impact = pd.DataFrame(columns = list_methods, data = myMultiLCA.results)
df_impact / 3
```

# Part_2: Impact analysis


In this part of the code, a set of selected methods is chosen. The methods are extracted from bw.methods brightway library of methods. 1 scenario was illustrated as an example (it should not be considered as the only representative scenario). It is where all the scenarios can be developed and analyzed by modifying the 30 previously defined parameters. The flexiblity of this model allows the elaboration of various scenarios with a multi-criteria approach.

```{python}
methods_no_LT = [m for m in bw.methods if 'ILCD 1.0.8 2016' in str(m) and 'no LT' in str(m) ]
methods_no_LT
```

```{python}
len(methods_no_LT)
```

```{python}
list_methods = methods_all = methods_no_LT
```

```{python}
DF_impact = pd.DataFrame(index = methods_no_LT)
DF_impact
```

```{python}
act = [act for act in eidb if 'photovoltaic slanted-roof installation, 3kWp, multi-Si, panel, mounted, on roof' in act['name'] and act['unit'] =='unit' and 'RoW' in act['location']][0]
print(act)
bw.calculation_setups[act['name']] = {'inv': [{act:1}], 'ia': methods_all}
myMultiLCA = bw.MultiLCA(act['name'])
df_impact = pd.DataFrame(columns = methods_all, data = myMultiLCA.results)
DF_impact['Ecoinvent'] = df_impact.T / 3
df_impact /3 
```

```{python}
# to check the methods informations
# bw.Method(Ecotox_method).metadata
```

Numerous case studies can be executed by changing the parameters. We stop at this level. The representation and analyses of the results will be elaborated in further steps. It must be noted that this notebook calculate the environmental impacts resulted from the full system. 

In order to get results per kWp, the impacts shoud be divided by the assumed system power (a simple calculation).

In order to get results (in impacts/kWh), the set of calculations established in Part_3 which calculate the production of the system (in kWh) based on real data should be accompanied to the results obtained from this notebook (in impact).


# Part_3: PV Production


This part constitutes a complementary notebook to the Part_1 and Part_2.
In order to account for all the life stages of the system, the production phase should be calculated. 
This notebook calculate the production of the PV. The results obtained are expressed in kWh over the system's lifespan.

```{python}
#panda for data manipulation and data analysis
import pandas as pd
#numpy for multi-dimensional array, matrices, and high-level mathematical functions
import numpy as np
#request for making HTTP requests simpler and more human-friendly. 
import requests
#matplotlib is a numerical mathematics extension NumPy for 2D plotting
import matplotlib.pyplot as plt
plt.style.use('ggplot')
#mpld3 brings together Matplotlib, python, java, and D3.js
import mpld3
# %matplotlib inline
#pvlib provides a set of functions and classes for simulating the performance of photovoltaic energy systems.
#For the pvlib installation: 
#follow the intruction provided in https://pvlib-python.readthedocs.io/en/latest/installation.html
import pvlib
#workalender handles calendars, list legal / religious holidays and gives working-day-related computation functions.
import workalendar.europe
#can create heat and electrical profiles by scaling the BDEW profiles to your desired annual demand
import demandlib.bdew as bdew
import demandlib.particular_profiles as profiles
#datetime supplies classes for manipulating dates and times in both simple and complex ways. 
from datetime import time as settime
```

```{python}
#In order to calculate the production, the location should be chosen to upload the irradiation and meteorological data
#as explained in the following section
lat = 43.58
lon = 5.75
site_name = 'Antibes'
```

## Upload the data


In order to upload the required meteorological data, the user can check CAMS and soda-pro website, create a username, and dowload the data while respecting the format and the title mentioned below in the code. 
CAMS data can be found at: http://www.soda-pro.com/fr/web-services/radiation/cams-radiation-service
MERRA-2 data be found at: http://www.soda-pro.com/fr/web-services/meteo-data/merra.
CAMS provides the irradiation data and MERRA-2 provides the other required meteorological data.

ATTENTION: 
In order to have data code-compliant, the user should respect the set nomenclature of the file: CAMS_NAME and MERRA2_NAME;
For example, if the uploaded data is for Antibes city, the uploaded csv file should be called: CAMS_Antibes and MERRA2_Antibes
to ensure appropriate data upload.

```{python}
df_cams = pd.read_csv('CAMS_%s.csv'%site_name, header=42, decimal = '.', delimiter = ';' )
```

```{python}
df_cams.head()
```

```{python}
df_cams.index = df_cams['# Observation period'].apply(lambda x:x.split('/')[0])
```

```{python}
# CAMS data
df_cams = pd.read_csv('CAMS_%s.csv'%site_name, header = 42, decimal = '.', delimiter = ';' )
df_cams.index = df_cams['# Observation period'].apply(lambda x:x.split('/')[0])
df_cams.index = pd.to_datetime(df_cams.index)
del df_cams['# Observation period']
df_cams.head()
```

```{python}
# Merra2 données horaires
df_merra = pd.read_csv('MERRA2_%s.csv'%site_name, header = 22, decimal = '.', delimiter = ';' )
df_merra['# Time'] = df_merra['UT time'].apply(lambda x : str(np.int(x.split(':')[0]) - 1)+':'+ x.split(':')[1])
df_merra.index = pd.to_datetime(df_merra['# Date'] + ' ' + df_merra['# Time'])
df_merra = df_merra[['Temperature', 'Relative Humidity', 'Pressure',
                       'Wind speed', 'Wind direction', 'Rainfall', 'Snowfall', 'Snow depth']]
df_merra['Temperature'] = df_merra['Temperature'] - 273.15
df_merra.head()
```

```{python}
# Dataframe météo
weather = pd.concat([df_cams[['GHI', 'BNI', 'DHI']]*60/15, df_merra.resample('15min').first().interpolate('time')], axis = 1)
weather.columns = ['ghi', 'dni', 'dhi', 'temp_air', 'Relative Humidity', 'Pressure',
                   'wind_speed', 'Wind direction', 'Rainfall', 'Snowfall', 'Snow depth']
weather = weather.fillna(method = 'bfill')
weather.head()
```

## Observation  of the data


In order to ensure that the uploaded data is complete and representative and to have an insight about its variation, this section permits the observation of the meteorological data and irradiation data.


### Meteo Data

```{python}
#Observation du rayonnement solaire
df = weather[['ghi','dni','dhi']]['2017']

fig, ax = plt.subplots(sharex = True, sharey = True, figsize = (12,9))
df.resample('H').mean().plot(ax = ax)
df.resample('H').mean().resample('D').mean().plot(ax = ax)
plt.title('Valeurs moyennes horaires et journalières de rayonnement solaire')
plt.ylabel('Rayonnement solaire (W/m²)')

#mpld3.display(fig)
```

```{python}
#Observation de la température
df = weather.temp_air['2017']

fig, ax = plt.subplots(sharex = True, sharey = True, figsize = (12,9))
df.resample('H').mean().plot(ax = ax)
df.resample('D').mean().plot(ax = ax)
plt.title('Valeurs horaires et journalières de la température')
plt.ylabel('Temperature (°C)')

#mpld3.display(fig)
```

```{python}
#Observation des données de vent
df = weather.wind_speed['2017']

fig, ax = plt.subplots(sharex = True, sharey = True, figsize = (12,9))
df.resample('H').mean().plot(ax = ax)
df.resample('D').mean().plot(ax = ax)
plt.title('Valeurs moyennes horaires et journalières de vent')
plt.ylabel('Vent (m/s)')

#mpld3.display(fig)
```

### Irradiation Data

```{python}
print('Ressource annuelle GHI (kWh/m²/an):')
fig, ax = plt.subplots(figsize = (12, 6))
(weather[['ghi']]['2004':'2017'].resample('h').mean().resample('a').sum()/1e3).plot(kind = 'area', alpha = 0.4, ax = ax)
plt.title('Ressource annuelle GHI (kWh/m²/an)')
plt.ylabel('GHI (kWh/m²/an)')
```

## Modeling the PV Production


This is where the production function is defined. This function rely on a set of defined parameters that indicate the location, weahter (meteo and irradiation), the orientation, the performance ration (PR), and the degradation rate (DR).

```{python}
def assessed_PV_productivity(weather, latitude, longitude,
                             inclinaison, azimuth, name, PR = 0.85, altitude = 0,
                                          timezone = 'Europe/Paris', DR = 0.005, lifespan = 30,
                                          tracker = False, gcr = 0.3, backtrack = True, max_angle = 60):
    """
    This function generates the production over the lifespan of the system.
    Aside from the localisation parameters: latitude, longitude, and altitude, 4 important parameters are defined:
    - PR representing the performance ratio and expressed in fraction/percentage
    - DR representing the degradation rate and expressed in fraction/percentage
    - lifespan of the system expressed in years
    - inclinaison and the azimuth representing the orientation expressed in degrees
    - weather which includes the irradiation data
    
    """
    Ppv = 1
    #Localisation
    location = pvlib.location.Location(latitude = latitude, longitude = longitude, altitude = altitude, tz = timezone, name = name)
    
    #Chargement et choix de module polycristallin
    sandia_modules = pvlib.pvsystem.retrieve_sam('SandiaMod')
    sapm_inverters = pvlib.pvsystem.retrieve_sam('cecinverter')
    module = sandia_modules['SolarWorld_Sunmodule_250_Poly__2013_']
    inverter = sapm_inverters['ABB__MICRO_0_25_I_OUTD_US_208_208V__CEC_2014_']
    
    if not(tracker):
        #Orientation des panneaux
        system = pvlib.pvsystem.PVSystem(module_parameters=module,
                                   inverter_parameters=inverter,
                                   modules_per_string=1,
                                   strings_per_inverter=1, 
                                   surface_tilt = inclinaison,
                                   surface_azimuth = azimuth,
                                   racking_model = 'insulated_back_polymerback'
                                   )
    if tracker:
        system = pvlib.tracking.SingleAxisTracker(axis_tilt = 0,axis_azimuth = 180,max_angle = max_angle,backtrack = backtrack,
                                                  gcr = gcr, racking_model = 'insulated_back_polymerback', 
                                                  module_parameters=module,modules_per_string=1,
                                                  inverter_parameters=inverter, strings_per_inverter=1,)

    #Systeme PV
    mc = pvlib.modelchain.ModelChain(system, location)
    
    mc.run_model(times=weather.index, weather=weather)    
    
    df = pd.DataFrame()
    df['P'] = mc.ac / 0.250
    df['I'] = mc.effective_irradiance
    
    df['P'] = df['P']* PR/(df.resample('h').mean().resample('a').sum().P / df.resample('h').mean().resample('a').sum().I).mean()
    df['P'] = df['P']* Ppv / 1e3
    
    prod_year0 = df.resample('H').mean().resample('A').sum().P.mean()
    #Use a degradation rate of 0.5% per year until the end of life (30 years)
    #in a sensitivity analysis, resulting in an average reduction in 
    #the annual yield of 7.5%. 
    prod_lifetime =  prod_year0*((1.0-(1-DR)**(lifespan)))/(1-(1-DR))
    print("For an European optimally oriented panel, the average production is 975 kWh/kWp/year (Frischknecht et al., 2014)")
    
    return [prod_lifetime, prod_lifetime/lifespan]
```

```{python}
# def calc_impact_per_kWh(impacts_per_kWp, P, P_module, irradiance, PR, DR, lifespan):
#     prod_year0 = irradiance*((P*1e3*1.6)/P_module)*PR
#     print(prod_year0)
#     prod_lifetime =  prod_year0*lifespan*((1.0-(1-DR)**(lifespan)))/(1-(1-DR))
#     print(prod_lifetime)
#     #per year
#     kWh_per_kWp = (prod_lifetime/(P*lifespan))
#     print(kWh_per_kWp)
#     impacts_per_kWh = impacts_per_kWp / kWh_per_kWp
#     print(impacts_per_kWh)
#     return impacts_per_kWh*1000
```

```{python}
prod = assessed_PV_productivity(weather = weather['2017'], latitude = lat, longitude = lon, inclinaison = 30, azimuth = 180, name = 'Antibes_Production', PR = 0.85, altitude = 0, timezone = 'Europe/Paris', DR = 0.005, lifespan = 30, tracker = False, gcr = 0.3, backtrack = True, max_angle = 60) 
print('%s kWh/kWp/lifespan'%prod[0])
print('%s kWh/kWp/year'%prod[1])
```

# How to calculate the impact of the whole system?


Finally, in order to calculate the envrionmental performance, the results obtained from Part_2 and expressed in impacts (i.e. kg-CO2 eq) per the system should be divided over the result obtained from the Part_3 and expressed in kWh produced by the system over its lifespan.
Make sure to repsect the chosen lifespan in both Parts.
As a result, this final calculation is expressed in impacts/kWh.

```{python}
#the impacts of the systems of 30 years lifespan (expressed in kg-CO2-eq)
df_impact
```

```{python}
#the production of the system over the 30 years (expressed in kWh)
prod
```

```{python}
#Hence the environmental performance of the system (expressed in g-CO2-eq/kWh)
env_performance = (7000/(46027.6*3)*1000)
env_performance
```

# B-PUBLICATION RESULTS


In order to get better representation of the contribution analysis results, sankey diagram can be used. After the installation detailed in https://github.com/LCA-ActivityBrowser/activity-browser#contributing, type in the anaconda command:
- conda activate ab
- activity-browser


## Original PV Roof 3 kWp Installation

```{python}
#the panel chosen is RoW because the market GLO includes only the RoW and CH 
#so to better understand the inventories of the system the RoW is used
panel_RoW = [act for act in eidb if 'photovoltaic slanted-roof installation, 3kWp, multi-Si, panel, mounted, on roof' in act['name'] and 'RoW' in act['location']][0]
panel_RoW
```

```{python}
#Based on Ecoinvent description, the dataset relies on 2005 data
panel_RoW['comment']
```

```{python}
act = panel_RoW
print(act)

df = pd.DataFrame(index = ['amount','unit','key','type'])
for (i,exc) in enumerate(act.exchanges()):
    df[str(bw.get_activity(exc.input.key))] = [exc.amount, exc.unit, exc.input.key,exc['type']]
df.T
```

```{python}
#to represent the results using the 2 selected impact categories:
bw.calculation_setups[act['name']] = {'inv': [{panel_RoW:1}], 'ia': list_methods}
myMultiLCA = bw.MultiLCA(act['name'])
df_impact = pd.DataFrame(columns = list_methods, data = myMultiLCA.results)
df_impact 
```

```{python}
6960/3
```

```{python}
#For an European optimally oriented panel:
#the average production is 975 kWh/kWp/year (Frischknecht et al., 2014)
(6960/(1330*30*3))*1000
```

```{python}
from IPython.display import Image
Image(filename='key_parameters_Ecoinvent_Jungbluth_2008.png', width=800, height=800)
```

## Adjusted PV Roof 3 kWp Installation Scenariosn


### Simulations

```{python}
DF_impact = pd.DataFrame(index = methods_no_LT)
DF_impact
```

```{python}
act = [act for act in eidb if 'photovoltaic slanted-roof installation, 3kWp, multi-Si, panel, mounted, on roof' in act['name'] and act['unit'] =='unit' and 'RoW' in act['location']][0]
print(act)
bw.calculation_setups[act['name']] = {'inv': [{act:1}], 'ia': methods_all}
myMultiLCA = bw.MultiLCA(act['name'])
df_impact = pd.DataFrame(columns = methods_all, data = myMultiLCA.results)
DF_impact['Ecoinvent'] = df_impact.T / 3
df_impact /3 
```

```{python}
elec_dataset = elec_dataset_row
```

```{python}
P = 3
P_module = 210
elec_dataset = elec_dataset_row
roof = True
DW=False 
kerf_loss = 0.5
share_recycled_aluminium = 0
manufacturing_efficiency_gains = 0
mLCA_name = '%skWc_%sWc_roof%s_Europe_2018'%(P,P_module,roof)
print(mLCA_name)
system_inv = create_dictionary_PV_system(P = P,
                                         P_module = P_module, 
                                         module_efficiency = None, 
                                         roof = roof,
                                         share_recycled_aluminium = share_recycled_aluminium, 
                                         elec_dataset = elec_dataset,
                                         inverter_weight = 18.5,  
                                         print_steps = True, 
                                         inverter_lifetime = 12.5, 
                                         PV_lifetime = 30, 
                                         glass_thickness = 4, 
                                         manufacturing_efficiency_gains = 0,
                                         kerf_loss = kerf_loss,
                                         wafer_thickness = 240, 
                                         silver_amount = 11.2, 
                                         Silicon_electricity_intensity = 110+19.5,
                                         d_lorry = 0, 
                                         d_train = 0, 
                                         d_sea = 0,
                                         recycling_rate_alu = 0, 
                                         recycling_rate_cu = 0, 
                                         recycling_rate_glass = 0,
                                         recycling_rate = 0,
                                         electricity_recycling = 0, 
                                         heat_recycling = 0,
                                         SiC_recycled_share=0, 
                                         TEG_recycled_share = 0,
                                         DW=DW)

act = generate_PV_system_dataset(system_inv)
act = [act for act in eidb if 'photovoltaic installation, adjusted' == act['name']][0]

bw.calculation_setups[act['name']] = {'inv': [{act:1}], 'ia': list_methods}
myMultiLCA = bw.MultiLCA(act['name'])
df_impact = pd.DataFrame(columns = list_methods, data = myMultiLCA.results)

DF_impact['3 kW PV system, 210 Wp panel'] = df_impact.T / 3
DF_impact
```

```{python}
P = 3
P_module = 280
elec_dataset = elec_dataset_row
roof = True
DW=False 
kerf_loss = 0.5
share_recycled_aluminium = 0
manufacturing_efficiency_gains = 0
mLCA_name = '%skWc_%sWc_roof%s_Europe_2018'%(P,P_module,roof)
print(mLCA_name)
system_inv = create_dictionary_PV_system(P = P,
                                         P_module = P_module, 
                                         module_efficiency = None, 
                                         roof = roof,
                                         share_recycled_aluminium = share_recycled_aluminium, 
                                         elec_dataset = elec_dataset,
                                         inverter_weight = 18.5,  
                                         print_steps = True, 
                                         inverter_lifetime = 12.5, 
                                         PV_lifetime = 30, 
                                         glass_thickness = 4, 
                                         manufacturing_efficiency_gains = 0,
                                         kerf_loss = kerf_loss,
                                         wafer_thickness = 240, 
                                         silver_amount = 11.2, 
                                         Silicon_electricity_intensity = 110+19.5,
                                         d_lorry = 0, 
                                         d_train = 0, 
                                         d_sea = 0,
                                         recycling_rate_alu = 0, 
                                         recycling_rate_cu = 0, 
                                         recycling_rate_glass = 0,
                                         recycling_rate = 0,
                                         electricity_recycling = 0, 
                                         heat_recycling = 0,
                                         SiC_recycled_share=0, 
                                         TEG_recycled_share = 0,
                                         DW=DW)

act = generate_PV_system_dataset(system_inv)
act = [act for act in eidb if 'photovoltaic installation, adjusted' == act['name']][0]

bw.calculation_setups[act['name']] = {'inv': [{act:1}], 'ia': list_methods}
myMultiLCA = bw.MultiLCA(act['name'])
df_impact = pd.DataFrame(columns = list_methods, data = myMultiLCA.results)

DF_impact['3 kW PV system, 280 Wp panel \n(better panel efficiency of 17.5%)'] = df_impact.T / 3
DF_impact
```

```{python}
P = 3
P_module = 280
elec_dataset = elec_dataset_row
roof = True
DW=False 
kerf_loss = 0.5
share_recycled_aluminium = 0
manufacturing_efficiency_gains = 0
mLCA_name = '%skWc_%sWc_roof%s_Europe_2018'%(P,P_module,roof)
print(mLCA_name)
system_inv = create_dictionary_PV_system(P = P,
                                         P_module = P_module, 
                                         module_efficiency = None, 
                                         roof = roof,
                                         share_recycled_aluminium = share_recycled_aluminium, 
                                         elec_dataset = elec_dataset,
                                         inverter_weight = 18.5,  
                                         print_steps = True, 
                                         inverter_lifetime = 12.5, 
                                         PV_lifetime = 30, 
                                         glass_thickness = 4, 
                                         manufacturing_efficiency_gains = 0,
                                         kerf_loss = kerf_loss,
                                         wafer_thickness = 240, 
                                         silver_amount = 11.2, 
                                         Silicon_electricity_intensity = 30+10,
                                         d_lorry = 0, 
                                         d_train = 0, 
                                         d_sea = 0,
                                         recycling_rate_alu = 0, 
                                         recycling_rate_cu = 0, 
                                         recycling_rate_glass = 0,
                                         recycling_rate = 0,
                                         electricity_recycling = 0, 
                                         heat_recycling = 0,
                                         SiC_recycled_share=0, 
                                         TEG_recycled_share = 0,
                                         DW=DW)

act = generate_PV_system_dataset(system_inv)
act = [act for act in eidb if 'photovoltaic installation, adjusted' == act['name']][0]

bw.calculation_setups[act['name']] = {'inv': [{act:1}], 'ia': list_methods}
myMultiLCA = bw.MultiLCA(act['name'])
df_impact = pd.DataFrame(columns = list_methods, data = myMultiLCA.results)

DF_impact['+ Fluidized Bed Reactor (FBR) process'] = df_impact.T / 3
DF_impact
```

```{python}
P = 3
P_module = 280
elec_dataset = elec_dataset_row
roof = True
DW=False 
kerf_loss = 0.5
share_recycled_aluminium = 0
manufacturing_efficiency_gains = 0
mLCA_name = '%skWc_%sWc_roof%s_Europe_2018'%(P,P_module,roof)
print(mLCA_name)
system_inv = create_dictionary_PV_system(P = P,
                                         P_module = P_module, 
                                         module_efficiency = None, 
                                         roof = roof,
                                         share_recycled_aluminium = share_recycled_aluminium, 
                                         elec_dataset = elec_dataset,
                                         inverter_weight = 18.5,  
                                         print_steps = True, 
                                         inverter_lifetime = 12.5, 
                                         PV_lifetime = 30, 
                                         glass_thickness = 4, 
                                         manufacturing_efficiency_gains = 0,
                                         kerf_loss = kerf_loss,
                                         wafer_thickness = 200, 
                                         silver_amount = 11.2, 
                                         Silicon_electricity_intensity = 30+10,
                                         d_lorry = 0, 
                                         d_train = 0, 
                                         d_sea = 0,
                                         recycling_rate_alu = 0, 
                                         recycling_rate_cu = 0, 
                                         recycling_rate_glass = 0,
                                         recycling_rate = 0,
                                         electricity_recycling = 0, 
                                         heat_recycling = 0,
                                         SiC_recycled_share=0, 
                                         TEG_recycled_share = 0,
                                         DW=DW)

act = generate_PV_system_dataset(system_inv)
act = [act for act in eidb if 'photovoltaic installation, adjusted' == act['name']][0]

bw.calculation_setups[act['name']] = {'inv': [{act:1}], 'ia': list_methods}
myMultiLCA = bw.MultiLCA(act['name'])
df_impact = pd.DataFrame(columns = list_methods, data = myMultiLCA.results)

DF_impact['+ Thinner wafer'] = df_impact.T / 3
DF_impact
```

```{python}
P = 3
P_module = 280
elec_dataset = elec_dataset_row
roof = True
DW=False 
kerf_loss = 0.5
share_recycled_aluminium = 0
manufacturing_efficiency_gains = 0
mLCA_name = '%skWc_%sWc_roof%s_Europe_2018'%(P,P_module,roof)
print(mLCA_name)
system_inv = create_dictionary_PV_system(P = P,
                                         P_module = P_module, 
                                         module_efficiency = None, 
                                         roof = roof,
                                         share_recycled_aluminium = share_recycled_aluminium, 
                                         elec_dataset = elec_dataset,
                                         inverter_weight = 18.5,  
                                         print_steps = True, 
                                         inverter_lifetime = 12.5, 
                                         PV_lifetime = 30, 
                                         glass_thickness = 4, 
                                         manufacturing_efficiency_gains = 0,
                                         kerf_loss = kerf_loss,
                                         wafer_thickness = 200, 
                                         silver_amount = 11.2, 
                                         Silicon_electricity_intensity = 30+10,
                                         d_lorry = 0, 
                                         d_train = 0, 
                                         d_sea = 0,
                                         recycling_rate_alu = 0, 
                                         recycling_rate_cu = 0, 
                                         recycling_rate_glass = 0,
                                         recycling_rate = 0,
                                         electricity_recycling = 0, 
                                         heat_recycling = 0,
                                         SiC_recycled_share=0.694, 
                                         TEG_recycled_share = 0.899,
                                         DW=DW)

act = generate_PV_system_dataset(system_inv)
act = [act for act in eidb if 'photovoltaic installation, adjusted' == act['name']][0]

bw.calculation_setups[act['name']] = {'inv': [{act:1}], 'ia': list_methods}
myMultiLCA = bw.MultiLCA(act['name'])
df_impact = pd.DataFrame(columns = list_methods, data = myMultiLCA.results)

DF_impact['+ Secondary SiC (69%) and TEG (89%)'] = df_impact.T / 3
DF_impact
```

```{python}
P = 3
P_module = 280
elec_dataset = elec_dataset_row
roof = True
DW= True 
kerf_loss = 0.5-0.15
share_recycled_aluminium = 0
manufacturing_efficiency_gains = 0
mLCA_name = '%skWc_%sWc_roof%s_Europe_2018'%(P,P_module,roof)
print(mLCA_name)
system_inv = create_dictionary_PV_system(P = P,
                                         P_module = P_module, 
                                         module_efficiency = None, 
                                         roof = roof,
                                         share_recycled_aluminium = share_recycled_aluminium, 
                                         elec_dataset = elec_dataset,
                                         inverter_weight = 18.5,  
                                         print_steps = True, 
                                         inverter_lifetime = 12.5, 
                                         PV_lifetime = 30, 
                                         glass_thickness = 4, 
                                         manufacturing_efficiency_gains = 0,
                                         kerf_loss = kerf_loss,
                                         wafer_thickness = 200, 
                                         silver_amount = 11.2, 
                                         Silicon_electricity_intensity = 30+10,
                                         d_lorry = 0, 
                                         d_train = 0, 
                                         d_sea = 0,
                                         recycling_rate_alu = 0, 
                                         recycling_rate_cu = 0, 
                                         recycling_rate_glass = 0,
                                         recycling_rate = 0,
                                         electricity_recycling = 0, 
                                         heat_recycling = 0,
                                         SiC_recycled_share=0.694, 
                                         TEG_recycled_share = 0.899,
                                         DW=DW)

act = generate_PV_system_dataset(system_inv)
act = [act for act in eidb if 'photovoltaic installation, adjusted' == act['name']][0]

bw.calculation_setups[act['name']] = {'inv': [{act:1}], 'ia': list_methods}
myMultiLCA = bw.MultiLCA(act['name'])
df_impact = pd.DataFrame(columns = list_methods, data = myMultiLCA.results)

DF_impact['+ DW cutting process \nand reduced kerf loss'] = df_impact.T / 3
DF_impact
```

```{python}
P = 3
P_module = 280
elec_dataset = elec_dataset_row
roof = True
DW= True 
kerf_loss = 0.5-0.15
share_recycled_aluminium = 0.27
manufacturing_efficiency_gains = 0
mLCA_name = '%skWc_%sWc_roof%s_Europe_2018'%(P,P_module,roof)
print(mLCA_name)
system_inv = create_dictionary_PV_system(P = P,
                                         P_module = P_module, 
                                         module_efficiency = None, 
                                         roof = roof,
                                         share_recycled_aluminium = share_recycled_aluminium, 
                                         elec_dataset = elec_dataset,
                                         inverter_weight = 18.5,  
                                         print_steps = True, 
                                         inverter_lifetime = 12.5, 
                                         PV_lifetime = 30, 
                                         glass_thickness = 4, 
                                         manufacturing_efficiency_gains = 0,
                                         kerf_loss = kerf_loss,
                                         wafer_thickness = 200, 
                                         silver_amount = 11.2, 
                                         Silicon_electricity_intensity = 30+10,
                                         d_lorry = 0, 
                                         d_train = 0, 
                                         d_sea = 0,
                                         recycling_rate_alu = 0, 
                                         recycling_rate_cu = 0, 
                                         recycling_rate_glass = 0,
                                         recycling_rate = 0,
                                         electricity_recycling = 0, 
                                         heat_recycling = 0,
                                         SiC_recycled_share=0.694, 
                                         TEG_recycled_share = 0.899,
                                         DW=DW)

act = generate_PV_system_dataset(system_inv)
act = [act for act in eidb if 'photovoltaic installation, adjusted' == act['name']][0]

bw.calculation_setups[act['name']] = {'inv': [{act:1}], 'ia': list_methods}
myMultiLCA = bw.MultiLCA(act['name'])
df_impact = pd.DataFrame(columns = list_methods, data = myMultiLCA.results)

DF_impact['+ Secondary aluminum'] = df_impact.T / 3
DF_impact
```

```{python}
P = 3
P_module = 280
elec_dataset = elec_dataset_row
roof = True
DW= True 
kerf_loss = 0.5-0.15
share_recycled_aluminium = 0.27
manufacturing_efficiency_gains = 0
mLCA_name = '%skWc_%sWc_roof%s_Europe_2018'%(P,P_module,roof)
print(mLCA_name)
system_inv = create_dictionary_PV_system(P = P,
                                         P_module = P_module, 
                                         module_efficiency = None, 
                                         roof = roof,
                                         share_recycled_aluminium = share_recycled_aluminium, 
                                         elec_dataset = elec_dataset,
                                         inverter_weight = None,  
                                         print_steps = True, 
                                         inverter_lifetime = 12.5, 
                                         PV_lifetime = 30, 
                                         glass_thickness = 4, 
                                         manufacturing_efficiency_gains = 0,
                                         kerf_loss = kerf_loss,
                                         wafer_thickness = 200, 
                                         silver_amount = 11.2, 
                                         Silicon_electricity_intensity = 30+10,
                                         d_lorry = 0, 
                                         d_train = 0, 
                                         d_sea = 0,
                                         recycling_rate_alu = 0, 
                                         recycling_rate_cu = 0, 
                                         recycling_rate_glass = 0,
                                         recycling_rate = 0,
                                         electricity_recycling = 0, 
                                         heat_recycling = 0,
                                         SiC_recycled_share=0.694, 
                                         TEG_recycled_share = 0.899,
                                         DW=DW)

act = generate_PV_system_dataset(system_inv)
act = [act for act in eidb if 'photovoltaic installation, adjusted' == act['name']][0]

bw.calculation_setups[act['name']] = {'inv': [{act:1}], 'ia': list_methods}
myMultiLCA = bw.MultiLCA(act['name'])
df_impact = pd.DataFrame(columns = list_methods, data = myMultiLCA.results)

DF_impact['+ Adjusted inverter dataset'] = df_impact.T / 3
DF_impact
```

```{python}
P = 3
P_module = 320 #corresponding to 20% efficiency
elec_dataset = elec_dataset_row
roof = True
DW= True 
kerf_loss = 0.5-0.15
share_recycled_aluminium = 0.27
manufacturing_efficiency_gains = 0
mLCA_name = '%skWc_%sWc_roof%s_Europe_2018'%(P,P_module,roof)
print(mLCA_name)
system_inv = create_dictionary_PV_system(P = P,
                                         P_module = P_module, 
                                         module_efficiency = None, 
                                         roof = roof,
                                         share_recycled_aluminium = share_recycled_aluminium, 
                                         elec_dataset = elec_dataset,
                                         inverter_weight = None,  
                                         print_steps = True, 
                                         inverter_lifetime = 12.5, 
                                         PV_lifetime = 30, 
                                         glass_thickness = 4, 
                                         manufacturing_efficiency_gains = 0,
                                         kerf_loss = kerf_loss,
                                         wafer_thickness = 200, 
                                         silver_amount = 11.2, 
                                         Silicon_electricity_intensity = 30+10,
                                         d_lorry = 0, 
                                         d_train = 0, 
                                         d_sea = 0,
                                         recycling_rate_alu = 0, 
                                         recycling_rate_cu = 0, 
                                         recycling_rate_glass = 0,
                                         recycling_rate = 0,
                                         electricity_recycling = 0, 
                                         heat_recycling = 0,
                                         SiC_recycled_share=0.694, 
                                         TEG_recycled_share = 0.899,
                                         DW=DW)

act = generate_PV_system_dataset(system_inv)
act = [act for act in eidb if 'photovoltaic installation, adjusted' == act['name']][0]

bw.calculation_setups[act['name']] = {'inv': [{act:1}], 'ia': list_methods}
myMultiLCA = bw.MultiLCA(act['name'])
df_impact = pd.DataFrame(columns = list_methods, data = myMultiLCA.results)

DF_impact['+ Better panel efficiency of 20%'] = df_impact.T / 3
DF_impact
```

```{python}
P = 30
P_module = 320 #corresponding to 20% efficiency
elec_dataset = elec_dataset_row
roof = True
DW= True 
kerf_loss = 0.5-0.15
share_recycled_aluminium = 0.27
manufacturing_efficiency_gains = 0
mLCA_name = '%skWc_%sWc_roof%s_Europe_2018'%(P,P_module,roof)
print(mLCA_name)
system_inv = create_dictionary_PV_system(P = P,
                                         P_module = P_module, 
                                         module_efficiency = None, 
                                         roof = roof,
                                         share_recycled_aluminium = share_recycled_aluminium, 
                                         elec_dataset = elec_dataset,
                                         inverter_weight = None,  
                                         print_steps = True, 
                                         inverter_lifetime = 12.5, 
                                         PV_lifetime = 30, 
                                         glass_thickness = 4, 
                                         manufacturing_efficiency_gains = 0,
                                         kerf_loss = kerf_loss,
                                         wafer_thickness = 200, 
                                         silver_amount = 11.2, 
                                         Silicon_electricity_intensity = 30+10,
                                         d_lorry = 0, 
                                         d_train = 0, 
                                         d_sea = 0,
                                         recycling_rate_alu = 0, 
                                         recycling_rate_cu = 0, 
                                         recycling_rate_glass = 0,
                                         recycling_rate = 0,
                                         electricity_recycling = 0, 
                                         heat_recycling = 0,
                                         SiC_recycled_share=0.694, 
                                         TEG_recycled_share = 0.899,
                                         DW=DW)

act = generate_PV_system_dataset(system_inv)
act = [act for act in eidb if 'photovoltaic installation, adjusted' == act['name']][0]

bw.calculation_setups[act['name']] = {'inv': [{act:1}], 'ia': list_methods}
myMultiLCA = bw.MultiLCA(act['name'])
df_impact = pd.DataFrame(columns = list_methods, data = myMultiLCA.results)
df_impact/P

DF_impact['+ 30 kWp system'] = df_impact.T / P
DF_impact
```

```{python}
elec_dataset_eu = [act for act in eidb if 'market group for electricity, medium voltage' == act['name'] and 'ENTSO-E' == act['location']][0]
elec_dataset_eu
```

```{python}
P = 30
P_module = 320 #corresponding to 20% efficiency
elec_dataset = elec_dataset_eu
roof = True
DW= True 
kerf_loss = 0.5-0.15
share_recycled_aluminium = 0.27
manufacturing_efficiency_gains = 0
mLCA_name = '%skWc_%sWc_roof%s_Europe_2018'%(P,P_module,roof)
print(mLCA_name)
system_inv = create_dictionary_PV_system(P = P,
                                         P_module = P_module, 
                                         module_efficiency = None, 
                                         roof = roof,
                                         share_recycled_aluminium = share_recycled_aluminium, 
                                         elec_dataset = elec_dataset,
                                         inverter_weight = None,  
                                         print_steps = True, 
                                         inverter_lifetime = 12.5, 
                                         PV_lifetime = 30, 
                                         glass_thickness = 4, 
                                         manufacturing_efficiency_gains = 0,
                                         kerf_loss = kerf_loss,
                                         wafer_thickness = 200, 
                                         silver_amount = 11.2, 
                                         Silicon_electricity_intensity = 30+10,
                                         d_lorry = 0, 
                                         d_train = 0, 
                                         d_sea = 0,
                                         recycling_rate_alu = 0, 
                                         recycling_rate_cu = 0, 
                                         recycling_rate_glass = 0,
                                         recycling_rate = 0,
                                         electricity_recycling = 0, 
                                         heat_recycling = 0,
                                         SiC_recycled_share=0.694, 
                                         TEG_recycled_share = 0.899,
                                         DW=DW)

act = generate_PV_system_dataset(system_inv)
act = [act for act in eidb if 'photovoltaic installation, adjusted' == act['name']][0]

bw.calculation_setups[act['name']] = {'inv': [{act:1}], 'ia': list_methods}
myMultiLCA = bw.MultiLCA(act['name'])
df_impact = pd.DataFrame(columns = list_methods, data = myMultiLCA.results)
df_impact/P

DF_impact['+ EU electricity mix'] = df_impact.T / P
DF_impact
```

```{python}
elec_dataset_fr = [act for act in eidb if 'market for electricity, medium voltage' == act['name'] and 'FR' == act['location']][0]
elec_dataset_fr
```

```{python}
P = 30
P_module = 320 #corresponding to 20% efficiency
elec_dataset = elec_dataset_fr
roof = True
DW= True 
kerf_loss = 0.5-0.15
share_recycled_aluminium = 0.27
manufacturing_efficiency_gains = 0
mLCA_name = '%skWc_%sWc_roof%s_Europe_2018'%(P,P_module,roof)
print(mLCA_name)
system_inv = create_dictionary_PV_system(P = P,
                                         P_module = P_module, 
                                         module_efficiency = None, 
                                         roof = roof,
                                         share_recycled_aluminium = share_recycled_aluminium, 
                                         elec_dataset = elec_dataset,
                                         inverter_weight = None,  
                                         print_steps = True, 
                                         inverter_lifetime = 12.5, 
                                         PV_lifetime = 30, 
                                         glass_thickness = 4, 
                                         manufacturing_efficiency_gains = 0,
                                         kerf_loss = kerf_loss,
                                         wafer_thickness = 200, 
                                         silver_amount = 11.2, 
                                         Silicon_electricity_intensity = 30+10,
                                         d_lorry = 0, 
                                         d_train = 0, 
                                         d_sea = 0,
                                         recycling_rate_alu = 0, 
                                         recycling_rate_cu = 0, 
                                         recycling_rate_glass = 0,
                                         recycling_rate = 0,
                                         electricity_recycling = 0, 
                                         heat_recycling = 0,
                                         SiC_recycled_share=0.694, 
                                         TEG_recycled_share = 0.899,
                                         DW=DW)

act = generate_PV_system_dataset(system_inv)
act = [act for act in eidb if 'photovoltaic installation, adjusted' == act['name']][0]

bw.calculation_setups[act['name']] = {'inv': [{act:1}], 'ia': list_methods}
myMultiLCA = bw.MultiLCA(act['name'])
df_impact = pd.DataFrame(columns = list_methods, data = myMultiLCA.results)
df_impact/P

DF_impact['+ Low carbon (FR) electricity mix'] = df_impact.T / P
DF_impact
```

```{python}
elec_nw = [act for act in eidb if 'market for electricity, medium voltage' == act['name'] and 'NO' == act['location']][0]
elec_nw
```

```{python}
P = 30
P_module = 320 #corresponding to 20% efficiency
elec_dataset = elec_nw
roof = True
DW= True 
kerf_loss = 0.5-0.15
share_recycled_aluminium = 0.27
manufacturing_efficiency_gains = 0
mLCA_name = '%skWc_%sWc_roof%s_Europe_2018'%(P,P_module,roof)
print(mLCA_name)
system_inv = create_dictionary_PV_system(P = P,
                                         P_module = P_module, 
                                         module_efficiency = None, 
                                         roof = roof,
                                         share_recycled_aluminium = share_recycled_aluminium, 
                                         elec_dataset = elec_dataset,
                                         inverter_weight = None,  
                                         print_steps = True, 
                                         inverter_lifetime = 12.5, 
                                         PV_lifetime = 30, 
                                         glass_thickness = 4, 
                                         manufacturing_efficiency_gains = 0,
                                         kerf_loss = kerf_loss,
                                         wafer_thickness = 200, 
                                         silver_amount = 11.2, 
                                         Silicon_electricity_intensity = 30+10,
                                         d_lorry = 0, 
                                         d_train = 0, 
                                         d_sea = 0,
                                         recycling_rate_alu = 0, 
                                         recycling_rate_cu = 0, 
                                         recycling_rate_glass = 0,
                                         recycling_rate = 0,
                                         electricity_recycling = 0, 
                                         heat_recycling = 0,
                                         SiC_recycled_share=0.694, 
                                         TEG_recycled_share = 0.899,
                                         DW=DW)

act = generate_PV_system_dataset(system_inv)
act = [act for act in eidb if 'photovoltaic installation, adjusted' == act['name']][0]

bw.calculation_setups[act['name']] = {'inv': [{act:1}], 'ia': list_methods}
myMultiLCA = bw.MultiLCA(act['name'])
df_impact = pd.DataFrame(columns = list_methods, data = myMultiLCA.results)
df_impact/P

DF_impact['+ Low carbon (NO) electricity mix'] = df_impact.T / P
DF_impact
```

```{python}
DF_impact.to_pickle('FINAL_PV_IMPACT/Full_model_results.pkl')
```

### Visualization

```{python}
DF_impact = pd.read_pickle('FINAL_PV_IMPACT/Full_model_results.pkl')
```

```{python}
DF_impact = DF_impact.T
DF_impact
DF_impact = DF_impact.sort_values(by = DF_impact.columns[0], ascending= True)
DF_impact
```

```{python}
A = (DF_impact/ (30*1300))
A.columns = [m[1:] for m in A.columns] 
A
```

```{python}
ILCD_methods_unit = [bw.Method(m).metadata['unit'] for m in methods_no_LT]
ILCD_methods_unit
```

```{python}
ax[0]
```

```{python}
fig, ax = plt.subplots(nrows =5,ncols=3, figsize = (20,23))
A.plot(ax = ax,                           
        kind = 'barh', 
        subplots = True, 
        label = False, 
        legend = False, 
        sharey = True)
#plt.legend(bbox_to_anchor=(0.5, -0.05))
fig.suptitle('PV Impacts ILCD 2016 \n(productivity 1300 kWh/kWp, lifetime 30 years',
             fontsize = 18, y=1.03)
for j,axj in enumerate(ax):
    for i,axi in enumerate(axj):
        axi.set_xlabel('%s/kWh'%ILCD_methods_unit[3*j+i])
plt.tight_layout()
```

## Once-At-a-Time (OAT) Results

```{python}
ILCD_methods_unit = [bw.Method(m).metadata['unit'] for m in methods_no_LT]
ILCD_methods_unit
```

###  System Power

```{python}
DF_impact = pd.DataFrame(index = list_methods,)

for i in [3, 10, 36, 500, 3000]:
    print(i)
    system_inv = create_dictionary_PV_system(P = i,
                                             P_module = 280, 
                                             module_efficiency = None, 
                                             roof = True,
                                             share_recycled_aluminium = 0.27, 
                                             elec_dataset = elec_dataset_row,
                                             inverter_weight = None,  
                                             print_steps = False, 
                                             inverter_lifetime = 15, 
                                             PV_lifetime = 30, 
                                             glass_thickness = 4, 
                                             manufacturing_efficiency_gains = 0,
                                             kerf_loss = 0.44,
                                             wafer_thickness = 200, 
                                             silver_amount = 9.6, 
                                             Silicon_electricity_intensity = 30+10,
                                             d_lorry = 1020, 
                                             d_train = 350, 
                                             d_sea = 4000,
                                             recycling_rate_alu = 0.92, 
                                             recycling_rate_cu = 0.75, 
                                             recycling_rate_glass = 0.9,
                                             recycling_rate = 0.9,
                                             electricity_recycling = 50, 
                                             heat_recycling = 75,
                                             SiC_recycled_share=0.694, 
                                             TEG_recycled_share = 0.899,
                                             DW=False)
    
    bw.calculation_setups['SA'] = {'inv': [system_inv], 'ia': list_methods}
    myMultiLCA = bw.MultiLCA('SA')
    DF_impact[i] = myMultiLCA.results.T

DF_impact.to_pickle('FINAL_PV_IMPACT/SA_system_power.pkl')
DF_impact
```

```{python}
df_impact = pd.read_pickle('FINAL_PV_IMPACT/SA_system_power.pkl')
df_impact = df_impact.T
df_impact.index.name = 'System power'
```

```{python}
df_impact_kW = df_impact[methods_no_LT].divide(df_impact.index.values, axis = 0)
df_impact_kW.columns = [m[2] for m in df_impact_kW.columns]
```

```{python}
fig, ax = plt.subplots(5,3, figsize = (16,9))
df_impact_kW.plot(ax = ax, subplots= True, kind = 'area', alpha = 0.7)
for i,axi in enumerate(ax):
    for j, axj in enumerate(axi):
        axj.set_ylabel('%s'%ILCD_methods_unit[i*len(axi)+j])
plt.suptitle('Evolution of normalized impacts (impact per kWp installed) \n with the size of the PV installation', y = 0.95, fontsize = 20)
#plt.tight_layout()
```

```{python}
df_RC = pd.DataFrame(index = df_impact_kW.columns)
```

```{python}
df = (df_impact_kW.max() - df_impact_kW.min())/df_impact_kW.median() * 100
fig, ax = plt.subplots(figsize = (9, 6))
plt.title('Relative change between 3 kWp and 3000 kWp installation')
df.plot(kind = 'barh', rot = 30)
ax.set_xlabel('Relative change in percentage of the median value (%)')
plt.tight_layout()

df_RC[df_impact.index.name] = df
```

### Panel Efficiency


#### Panel Rated Power Parameter


The panel efficiency can be monitored either by 'P_module' parameter or by 'module efficiency' parameter since these two parameters are interlinked with the panel surface. Therefore they can be used interchangeably.

```{python}
DF_impact = pd.DataFrame(index = list_methods,)

for i in np.arange(150, 350, 10):
    print(i)
    system_inv = create_dictionary_PV_system(P = 10,
                                             P_module = i, 
                                             module_efficiency = None, 
                                             roof = True,
                                             share_recycled_aluminium = 0.27, 
                                             elec_dataset = elec_dataset_row,
                                             inverter_weight = None,  
                                             print_steps = False, 
                                             inverter_lifetime = 15, 
                                             PV_lifetime = 30, 
                                             glass_thickness = 4, 
                                             manufacturing_efficiency_gains = 0,
                                             kerf_loss = 0.44,
                                             wafer_thickness = 200, 
                                             silver_amount = 9.6, 
                                             Silicon_electricity_intensity = 30+10,
                                             d_lorry = 1020, 
                                             d_train = 350, 
                                             d_sea = 4000,
                                             recycling_rate_alu = 0.92, 
                                             recycling_rate_cu = 0.75, 
                                             recycling_rate_glass = 0.9,
                                             recycling_rate = 0.9,
                                             electricity_recycling = 50, 
                                             heat_recycling = 75,
                                             SiC_recycled_share=0.694, 
                                             TEG_recycled_share = 0.899,
                                             DW=False)
    
    bw.calculation_setups['SA'] = {'inv': [system_inv], 'ia': list_methods}
    myMultiLCA = bw.MultiLCA('SA')
    DF_impact[i] = myMultiLCA.results.T

DF_impact.to_pickle('FINAL_PV_IMPACT/SA_panel_power.pkl')
DF_impact
```

```{python}
df_impact = pd.read_pickle('FINAL_PV_IMPACT/SA_panel_power.pkl')
df_impact = df_impact.T
df_impact.index.name = 'Panel efficiency'

df_impact = df_impact[methods_no_LT]
df_impact.columns = [m[2] for m in df_impact.columns]
df_impact = df_impact / 10
df_impact
```

```{python}
fig, ax = plt.subplots(5,3, figsize = (16,9))
df_impact.plot(ax = ax, subplots= True, kind = 'area', alpha = 0.7)
for i,axi in enumerate(ax):
    for j, axj in enumerate(axi):
        axj.set_ylabel(ILCD_methods_unit[i*len(axi)+j])
plt.suptitle('Evolution of normalized impacts (impact per kWp installed) \n with the nominal power of PV modules', y = 0.95, fontsize = 20)
#plt.tight_layout()
```

```{python}
df = (df_impact.max() - df_impact.min())/df_impact.median() * 100
fig, ax = plt.subplots(figsize = (9, 6))
plt.title('Relative change with nominal power of PV modules')
df.plot(kind = 'barh', rot = 30)
ax.set_xlabel('Relative change in percentage of the median value (%)')
plt.tight_layout()
df_RC[df_impact.index.name] = df
```

#### Or Panel Efficiency Parameter


The panel efficiency can be monitored either by 'P_module' parameter or by 'module efficiency' parameter since these two parameters are interlinked with the panel surface. Therefore they can be used interchangeably

```{python}
DF_impact = pd.DataFrame(index = list_methods,)

for i in np.arange(0.15, 0.22, 0.01):
    print(i)
    system_inv = create_dictionary_PV_system(P = 10,
                                             P_module = None, #should be None
                                             module_efficiency = i, 
                                             roof = True,
                                             share_recycled_aluminium = 0.27, 
                                             elec_dataset = elec_dataset_row,
                                             inverter_weight = None,  
                                             print_steps = False, 
                                             inverter_lifetime = 15, 
                                             PV_lifetime = 30, 
                                             glass_thickness = 4, 
                                             manufacturing_efficiency_gains = 0,
                                             kerf_loss = 0.44,
                                             wafer_thickness = 200, 
                                             silver_amount = 9.6, 
                                             Silicon_electricity_intensity = 30+10,
                                             d_lorry = 1020, 
                                             d_train = 350, 
                                             d_sea = 4000,
                                             recycling_rate_alu = 0.92, 
                                             recycling_rate_cu = 0.75, 
                                             recycling_rate_glass = 0.9,
                                             recycling_rate = 0.9,
                                             electricity_recycling = 50, 
                                             heat_recycling = 75,
                                             SiC_recycled_share=0.694, 
                                             TEG_recycled_share = 0.899,
                                             DW=False)
    
    bw.calculation_setups['SA'] = {'inv': [system_inv], 'ia': list_methods}
    myMultiLCA = bw.MultiLCA('SA')
    DF_impact[i] = myMultiLCA.results.T

DF_impact.to_pickle('FINAL_PV_IMPACT/SA_panel_efficiency.pkl')
DF_impact
```

```{python}
df_impact = pd.read_pickle('FINAL_PV_IMPACT/SA_panel_efficiency.pkl')
df_impact = df_impact.T
df_impact.index.name = 'Panel efficieny 2'

df_impact = df_impact[methods_no_LT]
df_impact.columns = [m[2] for m in df_impact.columns]
df_impact = df_impact / 10
df_impact
```

```{python}
fig, ax = plt.subplots(5,3, figsize = (16,9))
df_impact.plot(ax = ax, subplots= True, kind = 'area', alpha = 0.7)
for i,axi in enumerate(ax):
    for j, axj in enumerate(axi):
        axj.set_ylabel(ILCD_methods_unit[i*len(axi)+j])
plt.suptitle('Evolution of normalized impacts (impact per kWp installed) \n with the nominal power of PV modules', y = 0.95, fontsize = 20)
#plt.tight_layout()
```

```{python}
df = (df_impact.max() - df_impact.min())/df_impact.median() * 100
fig, ax = plt.subplots(figsize = (9, 6))
plt.title('Relative change with nominal power of PV modules')
df.plot(kind = 'barh', rot = 30)
ax.set_xlabel('Relative change in percentage of the median value (%)')
plt.tight_layout()
df_RC[df_impact.index.name] = df
```

### Roof

```{python}
DF_impact = pd.DataFrame(index = list_methods,)

for i in [True, False]:
    print(i)
    system_inv = create_dictionary_PV_system(P = 10,
                                             P_module = 280, 
                                             module_efficiency = None, 
                                             roof = i,
                                             share_recycled_aluminium = 0.27, 
                                             elec_dataset = elec_dataset_row,
                                             inverter_weight = None,  
                                             print_steps = False, 
                                             inverter_lifetime = 15, 
                                             PV_lifetime = 30, 
                                             glass_thickness = 4, 
                                             manufacturing_efficiency_gains = 0,
                                             kerf_loss = 0.44,
                                             wafer_thickness = 200, 
                                             silver_amount = 9.6, 
                                             Silicon_electricity_intensity = 30+10,
                                             d_lorry = 1020, 
                                             d_train = 350, 
                                             d_sea = 4000,
                                             recycling_rate_alu = 0.92, 
                                             recycling_rate_cu = 0.75, 
                                             recycling_rate_glass = 0.9,
                                             recycling_rate = 0.9,
                                             electricity_recycling = 50, 
                                             heat_recycling = 75,
                                             SiC_recycled_share=0.694, 
                                             TEG_recycled_share = 0.899,
                                             DW=False)
    
    bw.calculation_setups['SA'] = {'inv': [system_inv], 'ia': list_methods}
    myMultiLCA = bw.MultiLCA('SA')
    DF_impact[i] = myMultiLCA.results.T

DF_impact.to_pickle('FINAL_PV_IMPACT/SA_roof_ground.pkl')
DF_impact
```

```{python}
df_impact = pd.read_pickle('FINAL_PV_IMPACT/SA_roof_ground.pkl')
df_impact = df_impact.T

df_impact = df_impact[methods_no_LT]
df_impact.columns = [m[2] for m in df_impact.columns]
df_impact.index = ['Roof','Ground']
df_impact = df_impact / 10
df_impact.index.name = 'Roof / Ground'
df_impact
```

```{python}
fig, ax = plt.subplots(5,3, figsize = (16,9))
df_impact.plot(ax = ax, subplots= True, kind = 'bar', alpha = 0.7, legend= True)
plt.legend(loc = 3)
for i,axi in enumerate(ax):
    for j, axj in enumerate(axi):
        axj.set_ylabel(ILCD_methods_unit[i*len(axi)+j])
        axj.set_title('')
plt.suptitle('Evolution of normalized impacts (impact per kWp installed) \n with the type of installation', y = 0.95, fontsize = 20)
#plt.tight_layout()
```

```{python}
df = (df_impact.max() - df_impact.min())/df_impact.loc['Ground'] * 100
fig, ax = plt.subplots(figsize = (16, 9))
plt.title('Relative change with type of installation')
df.plot(kind = 'barh', rot = 30)
ax.set_xlabel('Relative change in percentage of the ground value (%)')
plt.tight_layout()
df_RC[df_impact.index.name] = df
```

### Share of Recycled Aluminum

```{python}
DF_impact = pd.DataFrame(index = list_methods,)

for i in [0, 1.1,0.3]:
    print(i)
    system_inv = create_dictionary_PV_system(P = 10,
                                             P_module = 280, 
                                             module_efficiency = None, 
                                             roof = True,
                                             share_recycled_aluminium = i, 
                                             elec_dataset = elec_dataset_row,
                                             inverter_weight = None,  
                                             print_steps = False, 
                                             inverter_lifetime = 15, 
                                             PV_lifetime = 30, 
                                             glass_thickness = 4, 
                                             manufacturing_efficiency_gains = 0,
                                             kerf_loss = 0.44,
                                             wafer_thickness = 200, 
                                             silver_amount = 9.6, 
                                             Silicon_electricity_intensity = 30+10,
                                             d_lorry = 1020, 
                                             d_train = 350, 
                                             d_sea = 4000,
                                             recycling_rate_alu = 0.92, 
                                             recycling_rate_cu = 0.75, 
                                             recycling_rate_glass = 0.9,
                                             recycling_rate = 0.9,
                                             electricity_recycling = 50, 
                                             heat_recycling = 75,
                                             SiC_recycled_share=0.694, 
                                             TEG_recycled_share = 0.899,
                                             DW=False)
    
    bw.calculation_setups['SA'] = {'inv': [system_inv], 'ia': list_methods}
    myMultiLCA = bw.MultiLCA('SA')
    DF_impact[i] = myMultiLCA.results.T

DF_impact.to_pickle('FINAL_PV_IMPACT/SA_Aluminium_roof.pkl')
DF_impact
```

```{python}
df_impact = pd.read_pickle('FINAL_PV_IMPACT/SA_Aluminium_roof.pkl')
df_impact = df_impact.T
df_impact.index.name = 'Recycled share of aluminum'

df_impact = df_impact[methods_no_LT]
df_impact.columns = [m[2] for m in df_impact.columns]
df_impact = df_impact / 10
df_impact
```

```{python}
fig, ax = plt.subplots(5,3, figsize = (16,9))
df_impact.plot(ax = ax, subplots= True, kind = 'area', alpha = 0.7)
for i,axi in enumerate(ax):
    for j, axj in enumerate(axi):
        axj.set_ylabel(ILCD_methods_unit[i*len(axi)+j])
plt.suptitle('Evolution of normalized impacts (impact per kWp installed) \n with the share of recycled aluminium', y = 0.95, fontsize = 20)
#plt.tight_layout()
```

```{python}
df = (df_impact.max() - df_impact.min())/df_impact.median() * 100
fig, ax = plt.subplots(figsize = (9, 6))
plt.title('Relative change with the share of recycled aluminium')
df.plot(kind = 'barh', rot = 30)
ax.set_xlabel('Relative change in percentage of the median value (%)')
plt.tight_layout()
df_RC[df_impact.index.name] = df
```

### Electricity Mix

```{python}
A = [elec_dataset_row, elec_dataset_eu, elec_dataset_us, elec_dataset_cn, elec_dataset_fr]
```

```{python}
DF_impact = pd.DataFrame(index = list_methods,)

for i in A:
    print(i)
    system_inv = create_dictionary_PV_system(P = 10,
                                             P_module = 280, 
                                             module_efficiency = None, 
                                             roof = True,
                                             share_recycled_aluminium = 0.27, 
                                             elec_dataset = i,
                                             inverter_weight = None,  
                                             print_steps = False, 
                                             inverter_lifetime = 15, 
                                             PV_lifetime = 30, 
                                             glass_thickness = 4, 
                                             manufacturing_efficiency_gains = 0,
                                             kerf_loss = 0.44,
                                             wafer_thickness = 200, 
                                             silver_amount = 9.6, 
                                             Silicon_electricity_intensity = 30+10,
                                             d_lorry = 1020, 
                                             d_train = 350, 
                                             d_sea = 4000,
                                             recycling_rate_alu = 0.92, 
                                             recycling_rate_cu = 0.75, 
                                             recycling_rate_glass = 0.9,
                                             recycling_rate = 0.9,
                                             electricity_recycling = 50, 
                                             heat_recycling = 75,
                                             SiC_recycled_share=0.694, 
                                             TEG_recycled_share = 0.899,
                                             DW=False)
    
    bw.calculation_setups['SA'] = {'inv': [system_inv], 'ia': list_methods}
    myMultiLCA = bw.MultiLCA('SA')
    DF_impact[i['location']] = myMultiLCA.results.T

DF_impact.to_pickle('FINAL_PV_IMPACT/SA_electricity_mix.pkl')
DF_impact
```

```{python}
df_impact = pd.read_pickle('FINAL_PV_IMPACT/SA_electricity_mix.pkl')
df_impact = df_impact.T
df_impact.index.name = 'Electricity mix'

df_impact = df_impact[methods_no_LT]
df_impact.columns = [m[2] for m in df_impact.columns]
df_impact = df_impact / 10
df_impact
```

```{python}
fig, ax = plt.subplots(5,3, figsize = (16,9))
df_impact.plot(ax = ax, subplots= True, kind = 'bar', alpha = 0.7, rot = 0)
for i,axi in enumerate(ax):
    for j, axj in enumerate(axi):
        axj.set_ylabel(ILCD_methods_unit[i*len(axi)+j])
        axj.set_title('')
plt.suptitle('Evolution of normalized impacts (impact per kWp installed) \n with the electricity mix of manufacture', y = 0.95, fontsize = 20)
#plt.tight_layout()
```

```{python}
df = (df_impact.max() - df_impact.min())/df_impact.median() * 100
fig, ax = plt.subplots(figsize = (9, 6))
plt.title('Relative change with the electricity mix')
df.plot(kind = 'barh', rot = 30)
ax.set_xlabel('Relative change in percentage of the median value (%)')
plt.tight_layout()
df_RC[df_impact.index.name] = df
```

### Inverter Weight

```{python}
DF_impact = pd.DataFrame(index = list_methods,)

for i in np.arange(1,6.1,1):
    print(i)
    system_inv = create_dictionary_PV_system(P = 10,
                                             P_module = 280, 
                                             module_efficiency = None, 
                                             roof = True,
                                             share_recycled_aluminium = 0.27, 
                                             elec_dataset = None,
                                             inverter_weight = i*10,  
                                             print_steps = False, 
                                             inverter_lifetime = 15, 
                                             PV_lifetime = 30, 
                                             glass_thickness = 4, 
                                             manufacturing_efficiency_gains = 0,
                                             kerf_loss = 0.44,
                                             wafer_thickness = 200, 
                                             silver_amount = 9.6, 
                                             Silicon_electricity_intensity = 30+10,
                                             d_lorry = 1020, 
                                             d_train = 350, 
                                             d_sea = 4000,
                                             recycling_rate_alu = 0.92, 
                                             recycling_rate_cu = 0.75, 
                                             recycling_rate_glass = 0.9,
                                             recycling_rate = 0.9,
                                             electricity_recycling = 50, 
                                             heat_recycling = 75,
                                             SiC_recycled_share=0.694, 
                                             TEG_recycled_share = 0.899,
                                             DW=False)
    
    bw.calculation_setups['SA'] = {'inv': [system_inv], 'ia': list_methods}
    myMultiLCA = bw.MultiLCA('SA')
    DF_impact[i] = myMultiLCA.results.T

DF_impact.to_pickle('FINAL_PV_IMPACT/SA_Inverter_weight.pkl')
DF_impact
```

```{python}
df_impact = pd.read_pickle('FINAL_PV_IMPACT/SA_Inverter_weight.pkl')
df_impact = df_impact.T
df_impact.index.name = 'Inverter specific weight (kg/kW)'

df_impact = df_impact[methods_no_LT]
df_impact.columns = [m[2] for m in df_impact.columns]
df_impact = df_impact / 10
#df_impact[df_impact < 0] = 10e3
df_impact
```

```{python}
fig, ax = plt.subplots(5,3, figsize = (16,9))
df_impact.plot(ax = ax, subplots= True, kind = 'area', alpha = 0.7)
for i,axi in enumerate(ax):
    for j, axj in enumerate(axi):
        axj.set_ylabel(ILCD_methods_unit[i*len(axi)+j])
plt.suptitle('Evolution of normalized impacts (impact per kWp installed) \n with the specific weight of the inverter', y = 0.95, fontsize = 20)
#plt.tight_layout()
```

```{python}
df = (df_impact.max() - df_impact.min())/df_impact.median() * 100
fig, ax = plt.subplots(figsize = (9, 6))
plt.title('Relative change with the inverter specific weight')
df.plot(kind = 'barh', rot = 30)
ax.set_xlabel('Relative change in percentage of the median value (%)')
plt.tight_layout()
df_RC[df_impact.index.name] = df
```

### Inverter Lifetime

```{python}
DF_impact = pd.DataFrame(index = list_methods,)

for i in np.arange(10,31,5):
    print(i)
    system_inv = create_dictionary_PV_system(P = 10,
                                             P_module = 280, 
                                             module_efficiency = None, 
                                             roof = True,
                                             share_recycled_aluminium = 0.27, 
                                             elec_dataset = None,
                                             inverter_weight = None,  
                                             print_steps = False, 
                                             inverter_lifetime = i, 
                                             PV_lifetime = 30, 
                                             glass_thickness = 4, 
                                             manufacturing_efficiency_gains = 0,
                                             kerf_loss = 0.44,
                                             wafer_thickness = 200, 
                                             silver_amount = 9.6, 
                                             Silicon_electricity_intensity = 30+10,
                                             d_lorry = 1020, 
                                             d_train = 350, 
                                             d_sea = 4000,
                                             recycling_rate_alu = 0.92, 
                                             recycling_rate_cu = 0.75, 
                                             recycling_rate_glass = 0.9,
                                             recycling_rate = 0.9,
                                             electricity_recycling = 50, 
                                             heat_recycling = 75,
                                             SiC_recycled_share=0.694, 
                                             TEG_recycled_share = 0.899,
                                             DW=False)
    
    bw.calculation_setups['SA'] = {'inv': [system_inv], 'ia': list_methods}
    myMultiLCA = bw.MultiLCA('SA')
    DF_impact[i] = myMultiLCA.results.T

DF_impact.to_pickle('FINAL_PV_IMPACT/SA_Inverter_lifetime.pkl')
DF_impact
```

```{python}
df_impact = pd.read_pickle('FINAL_PV_IMPACT/SA_Inverter_lifetime.pkl')
df_impact = df_impact.T
df_impact.index.name = 'Inverter lifetime'

df_impact = df_impact[methods_no_LT]
df_impact.columns = [m[2] for m in df_impact.columns]
df_impact = df_impact / 10
#df_impact[df_impact < 0] = 10e3
df_impact
```

```{python}
fig, ax = plt.subplots(5,3, figsize = (16,9))
df_impact.plot(ax = ax, subplots= True, kind = 'area', alpha = 0.7)
for i,axi in enumerate(ax):
    for j, axj in enumerate(axi):
        axj.set_ylabel(ILCD_methods_unit[i*len(axi)+j])
plt.suptitle('Evolution of normalized impacts (impact per kWp installed) \n with the inverter lifetime', y = 0.95, fontsize = 20)
#plt.tight_layout()
```

```{python}
df = (df_impact.max() - df_impact.min())/df_impact.median() * 100
fig, ax = plt.subplots(figsize = (9, 6))
plt.title('Relative change with the inverter lifetime')
df.plot(kind = 'barh', rot = 30)
ax.set_xlabel('Relative change in percentage of the median value (%)')
plt.tight_layout()
df_RC[df_impact.index.name] = df
```

### PV Lifetime

```{python}
DF_impact = pd.DataFrame(index = list_methods,)

for i in np.arange(20,40,5):
    print(i)
    system_inv = create_dictionary_PV_system(P = 10,
                                             P_module = 280, 
                                             module_efficiency = None, 
                                             roof = True,
                                             share_recycled_aluminium = 0.27, 
                                             elec_dataset = None,
                                             inverter_weight = None,  
                                             print_steps = False, 
                                             inverter_lifetime = 15, 
                                             PV_lifetime = i, 
                                             glass_thickness = 4, 
                                             manufacturing_efficiency_gains = 0,
                                             kerf_loss = 0.44,
                                             wafer_thickness = 200, 
                                             silver_amount = 9.6, 
                                             Silicon_electricity_intensity = 30+10,
                                             d_lorry = 1020, 
                                             d_train = 350, 
                                             d_sea = 4000,
                                             recycling_rate_alu = 0.92, 
                                             recycling_rate_cu = 0.75, 
                                             recycling_rate_glass = 0.9,
                                             recycling_rate = 0.9,
                                             electricity_recycling = 50, 
                                             heat_recycling = 75,
                                             SiC_recycled_share=0.694, 
                                             TEG_recycled_share = 0.899,
                                             DW=False)
    
    bw.calculation_setups['SA'] = {'inv': [system_inv], 'ia': list_methods}
    myMultiLCA = bw.MultiLCA('SA')
    DF_impact[i] = myMultiLCA.results.T

DF_impact.to_pickle('FINAL_PV_IMPACT/SA_PV_lifetime.pkl')
DF_impact
```

```{python}
df_impact = pd.read_pickle('FINAL_PV_IMPACT/SA_PV_lifetime.pkl')
df_impact = df_impact.T
df_impact.index.name = 'PV lifetime'

df_impact = df_impact[methods_no_LT]
df_impact.columns = [m[2] for m in df_impact.columns]
df_impact = df_impact / 10
#df_impact[df_impact < 0] = 10e3
df_impact
```

```{python}
fig, ax = plt.subplots(5,3, figsize = (16,9))
df_impact.plot(ax = ax, subplots= True, kind = 'area', alpha = 0.7)
for i,axi in enumerate(ax):
    for j, axj in enumerate(axi):
        axj.set_ylabel(ILCD_methods_unit[i*len(axi)+j])
plt.suptitle('Evolution of normalized impacts (impact per kWp installed) \n with the PV lifetime', y = 0.95, fontsize = 20)
#plt.tight_layout()
```

```{python}
df = (df_impact.max() - df_impact.min())/df_impact.median() * 100
fig, ax = plt.subplots(figsize = (9, 6))
plt.title('Relative change with the PV lifetime')
df.plot(kind = 'barh', rot = 30)
ax.set_xlabel('Relative change in percentage of the median value (%)')
plt.tight_layout()
df_RC[df_impact.index.name] = df
```

### Glass Thickness

```{python}
DF_impact = pd.DataFrame(index = list_methods,)

for i in np.arange(2,4.1,1):
    print(i)
    system_inv = create_dictionary_PV_system(P = 10,
                                             P_module = 280, 
                                             module_efficiency = None, 
                                             roof = True,
                                             share_recycled_aluminium = 0.27, 
                                             elec_dataset = None,
                                             inverter_weight = None,  
                                             print_steps = False, 
                                             inverter_lifetime = 15, 
                                             PV_lifetime = 30, 
                                             glass_thickness = i, 
                                             manufacturing_efficiency_gains = 0,
                                             kerf_loss = 0.44,
                                             wafer_thickness = 200, 
                                             silver_amount = 9.6, 
                                             Silicon_electricity_intensity = 30+10,
                                             d_lorry = 1020, 
                                             d_train = 350, 
                                             d_sea = 4000,
                                             recycling_rate_alu = 0.92, 
                                             recycling_rate_cu = 0.75, 
                                             recycling_rate_glass = 0.9,
                                             recycling_rate = 0.9,
                                             electricity_recycling = 50, 
                                             heat_recycling = 75,
                                             SiC_recycled_share=0.694, 
                                             TEG_recycled_share = 0.899,
                                             DW=False)
    
    bw.calculation_setups['SA'] = {'inv': [system_inv], 'ia': list_methods}
    myMultiLCA = bw.MultiLCA('SA')
    DF_impact[i] = myMultiLCA.results.T

DF_impact.to_pickle('FINAL_PV_IMPACT/SA_glass_thickness.pkl')
DF_impact
```

```{python}
df_impact = pd.read_pickle('FINAL_PV_IMPACT/SA_glass_thickness.pkl')
df_impact = df_impact.T
df_impact.index.name = 'Glass thickness'

df_impact = df_impact[methods_no_LT]
df_impact.columns = [m[2] for m in df_impact.columns]
df_impact = df_impact / 10
#df_impact[df_impact < 0] = 10e3
df_impact
```

```{python}
fig, ax = plt.subplots(5,3, figsize = (16,9))
df_impact.plot(ax = ax, subplots= True, kind = 'area', alpha = 0.7)
for i,axi in enumerate(ax):
    for j, axj in enumerate(axi):
        axj.set_ylabel(ILCD_methods_unit[i*len(axi)+j])
plt.suptitle('Evolution of normalized impacts (impact per kWp installed) \n with the glass thickness', y = 0.95, fontsize = 20)
#plt.tight_layout()
```

```{python}
df = (df_impact.max() - df_impact.min())/df_impact.median() * 100
fig, ax = plt.subplots(figsize = (9, 6))
plt.title('Relative change with the glass thickness')
df.plot(kind = 'barh', rot = 30)
ax.set_xlabel('Relative change in percentage of the median value (%)')
plt.tight_layout()
df_RC[df_impact.index.name] = df
```

### Manufacturing Efficiency Gain

```{python}
DF_impact = pd.DataFrame(index = list_methods,)

for i in np.arange(0,1.1,0.1):
    print(i)
    system_inv = create_dictionary_PV_system(P = 10,
                                             P_module = 280, 
                                             module_efficiency = None, 
                                             roof = True,
                                             share_recycled_aluminium = 0.27, 
                                             elec_dataset = None,
                                             inverter_weight = None,  
                                             print_steps = False, 
                                             inverter_lifetime = 15, 
                                             PV_lifetime = 30, 
                                             glass_thickness = 4, 
                                             manufacturing_efficiency_gains = i,
                                             kerf_loss = 0.44,
                                             wafer_thickness = 200, 
                                             silver_amount = 9.6, 
                                             Silicon_electricity_intensity = 30+10,
                                             d_lorry = 1020, 
                                             d_train = 350, 
                                             d_sea = 4000,
                                             recycling_rate_alu = 0.92, 
                                             recycling_rate_cu = 0.75, 
                                             recycling_rate_glass = 0.9,
                                             recycling_rate = 0.9,
                                             electricity_recycling = 50, 
                                             heat_recycling = 75,
                                             SiC_recycled_share=0.694, 
                                             TEG_recycled_share = 0.899,
                                             DW=False)
    
    bw.calculation_setups['SA'] = {'inv': [system_inv], 'ia': list_methods}
    myMultiLCA = bw.MultiLCA('SA')
    DF_impact[i] = myMultiLCA.results.T

DF_impact.to_pickle('FINAL_PV_IMPACT/SA_manufacturing_efficiency_gains.pkl')
DF_impact
```

```{python}
df_impact = pd.read_pickle('FINAL_PV_IMPACT/SA_manufacturing_efficiency_gains.pkl')
df_impact = df_impact.T
df_impact.index.name = 'Manufacturing efficiency gains'

df_impact = df_impact[methods_no_LT]
df_impact.columns = [m[2] for m in df_impact.columns]
df_impact = df_impact / 10
#df_impact[df_impact < 0] = 10e3
df_impact
```

```{python}
fig, ax = plt.subplots(5,3, figsize = (16,9))
df_impact.plot(ax = ax, subplots= True, kind = 'area', alpha = 0.7)
for i,axi in enumerate(ax):
    for j, axj in enumerate(axi):
        axj.set_ylabel(ILCD_methods_unit[i*len(axi)+j])
plt.suptitle('Evolution of normalized impacts (impact per kWp installed) \n with %s'%df_impact.index.name, y = 0.95, fontsize = 20)
#plt.tight_layout()
```

```{python}
df = (df_impact.max() - df_impact.min())/df_impact.median() * 100
fig, ax = plt.subplots(figsize = (9, 6))
plt.title('Relative change with the %s'%df_impact.index.name)
df.plot(kind = 'barh', rot = 30)
ax.set_xlabel('Relative change in percentage of the median value (%)')
plt.tight_layout()

df_RC[df_impact.index.name] = df
```

### Kerf Loss

```{python}
DF_impact = pd.DataFrame(index = list_methods,)

for i in np.arange(0.25,0.51,0.1):
    print(i)
    system_inv = create_dictionary_PV_system(P = 10,
                                             P_module = 280, 
                                             module_efficiency = None, 
                                             roof = True,
                                             share_recycled_aluminium = 0.27, 
                                             elec_dataset = None,
                                             inverter_weight = None,  
                                             print_steps = False, 
                                             inverter_lifetime = 15, 
                                             PV_lifetime = 30, 
                                             glass_thickness = 4, 
                                             manufacturing_efficiency_gains = 0,
                                             kerf_loss = i,
                                             wafer_thickness = 200, 
                                             silver_amount = 9.6, 
                                             Silicon_electricity_intensity = 30+10,
                                             d_lorry = 1020, 
                                             d_train = 350, 
                                             d_sea = 4000,
                                             recycling_rate_alu = 0.92, 
                                             recycling_rate_cu = 0.75, 
                                             recycling_rate_glass = 0.9,
                                             recycling_rate = 0.9,
                                             electricity_recycling = 50, 
                                             heat_recycling = 75,
                                             SiC_recycled_share=0.694, 
                                             TEG_recycled_share = 0.899,
                                             DW=False)
    
    bw.calculation_setups['SA'] = {'inv': [system_inv], 'ia': list_methods}
    myMultiLCA = bw.MultiLCA('SA')
    DF_impact[i] = myMultiLCA.results.T

DF_impact.to_pickle('FINAL_PV_IMPACT/SA_kerf_loss.pkl')
DF_impact
```

```{python}
df_impact = pd.read_pickle('FINAL_PV_IMPACT/SA_kerf_loss.pkl')
df_impact = df_impact.T
df_impact.index.name = 'Kerf loss'

df_impact = df_impact[methods_no_LT]
df_impact.columns = [m[2] for m in df_impact.columns]
df_impact = df_impact / 10
#df_impact[df_impact < 0] = 10e3
df_impact
```

```{python}
fig, ax = plt.subplots(5,3, figsize = (16,9))
df_impact.plot(ax = ax, subplots= True, kind = 'area', alpha = 0.7)
for i,axi in enumerate(ax):
    for j, axj in enumerate(axi):
        axj.set_ylabel(ILCD_methods_unit[i*len(axi)+j])
plt.suptitle('Evolution of normalized impacts (impact per kWp installed) \n with the kerf losses', y = 0.95, fontsize = 20)
#plt.tight_layout()
```

```{python}
df = (df_impact.max() - df_impact.min())/df_impact.median() * 100
fig, ax = plt.subplots(figsize = (9, 6))
plt.title('Relative change with the kerf loss')
df.plot(kind = 'barh', rot = 30)
ax.set_xlabel('Relative change in percentage of the median value (%)')
plt.tight_layout()

df_RC[df_impact.index.name] = df
```

### Wafer Thickness

```{python}
DF_impact = pd.DataFrame(index = list_methods,)

for i in np.arange(128,300,25):
    print(i)
    system_inv = create_dictionary_PV_system(P = 10,
                                             P_module = 280, 
                                             module_efficiency = None, 
                                             roof = True,
                                             share_recycled_aluminium = 0.27, 
                                             elec_dataset = None,
                                             inverter_weight = None,  
                                             print_steps = False, 
                                             inverter_lifetime = 15, 
                                             PV_lifetime = 30, 
                                             glass_thickness = 4, 
                                             manufacturing_efficiency_gains = 0,
                                             kerf_loss = 0.44,
                                             wafer_thickness = i, 
                                             silver_amount = 9.6, 
                                             Silicon_electricity_intensity = 30+10,
                                             d_lorry = 1020, 
                                             d_train = 350, 
                                             d_sea = 4000,
                                             recycling_rate_alu = 0.92, 
                                             recycling_rate_cu = 0.75, 
                                             recycling_rate_glass = 0.9,
                                             recycling_rate = 0.9,
                                             electricity_recycling = 50, 
                                             heat_recycling = 75,
                                             SiC_recycled_share=0.694, 
                                             TEG_recycled_share = 0.899,
                                             DW=False)
    
    bw.calculation_setups['SA'] = {'inv': [system_inv], 'ia': list_methods}
    myMultiLCA = bw.MultiLCA('SA')
    DF_impact[i] = myMultiLCA.results.T

DF_impact.to_pickle('FINAL_PV_IMPACT/SA_wafer_thickness.pkl')
DF_impact
```

```{python}
df_impact = pd.read_pickle('FINAL_PV_IMPACT/SA_wafer_thickness.pkl')
df_impact = df_impact.T
df_impact.index.name = 'Wafer thickness'

df_impact = df_impact[methods_no_LT]
df_impact.columns = [m[2] for m in df_impact.columns]
df_impact = df_impact / 10
#df_impact[df_impact < 0] = 10e3
df_impact
```

```{python}
fig, ax = plt.subplots(5,3, figsize = (16,9))
df_impact.plot(ax = ax, subplots= True, kind = 'area', alpha = 0.7)
for i,axi in enumerate(ax):
    for j, axj in enumerate(axi):
        axj.set_ylabel(ILCD_methods_unit[i*len(axi)+j])
plt.suptitle('Evolution of normalized impacts (impact per kWp installed) \n with the wafer thickness', y = 0.95, fontsize = 20)
#plt.tight_layout()
```

```{python}
df = (df_impact.max() - df_impact.min())/df_impact.median() * 100
fig, ax = plt.subplots(figsize = (9, 6))
plt.title('Relative change with the wafer thickness')
df.plot(kind = 'barh', rot = 30)
ax.set_xlabel('Relative change in percentage of the median value (%)')
plt.tight_layout()

df_RC[df_impact.index.name] = df
```

### Silver Amount

```{python}
DF_impact = pd.DataFrame(index = list_methods,)

for i in [2,11.2]:
    print(i)
    system_inv = create_dictionary_PV_system(P = 10,
                                             P_module = 280, 
                                             module_efficiency = None, 
                                             roof = True,
                                             share_recycled_aluminium = 0.27, 
                                             elec_dataset = None,
                                             inverter_weight = None,  
                                             print_steps = False, 
                                             inverter_lifetime = 15, 
                                             PV_lifetime = 30, 
                                             glass_thickness = 4, 
                                             manufacturing_efficiency_gains = 0,
                                             kerf_loss = 0.44,
                                             wafer_thickness = 200, 
                                             silver_amount = i, 
                                             Silicon_electricity_intensity = 30+10,
                                             d_lorry = 1020, 
                                             d_train = 350, 
                                             d_sea = 4000,
                                             recycling_rate_alu = 0.92, 
                                             recycling_rate_cu = 0.75, 
                                             recycling_rate_glass = 0.9,
                                             recycling_rate = 0.9,
                                             electricity_recycling = 50, 
                                             heat_recycling = 75,
                                             SiC_recycled_share=0.694, 
                                             TEG_recycled_share = 0.899,
                                             DW=False)
    
    bw.calculation_setups['SA'] = {'inv': [system_inv], 'ia': list_methods}
    myMultiLCA = bw.MultiLCA('SA')
    DF_impact[i] = myMultiLCA.results.T

DF_impact.to_pickle('FINAL_PV_IMPACT/SA_silver_amount.pkl')
DF_impact
```

```{python}
df_impact = pd.read_pickle('FINAL_PV_IMPACT/SA_silver_amount.pkl')
df_impact = df_impact.T
df_impact.index.name = 'Silver content'

df_impact = df_impact[methods_no_LT]
df_impact.columns = [m[2] for m in df_impact.columns]
df_impact = df_impact / 10
#df_impact[df_impact < 0] = 10e3
df_impact
```

```{python}
fig, ax = plt.subplots(5,3, figsize = (16,9))
df_impact.plot(ax = ax, subplots= True, kind = 'area', alpha = 0.7)
for i,axi in enumerate(ax):
    for j, axj in enumerate(axi):
        axj.set_ylabel(ILCD_methods_unit[i*len(axi)+j])
plt.suptitle('Evolution of normalized impacts (impact per kWp installed) \n with the silver content', y = 0.95, fontsize = 20)
#plt.tight_layout()
```

```{python}
df = (df_impact.max() - df_impact.min())/df_impact.median() * 100
fig, ax = plt.subplots(figsize = (9, 6))
plt.title('Relative change with the wafer thickness')
df.plot(kind = 'barh', rot = 30)
ax.set_xlabel('Relative change in percentage of the median value (%)')
plt.tight_layout()

df_RC[df_impact.index.name] = df
```

### Silicon Electricity Intensity

```{python}
DF_impact = pd.DataFrame(index = list_methods,)

for i in [21, 30, 40, 50, 75,100,195]:
    print(i)
    system_inv = create_dictionary_PV_system(P = 10,
                                             P_module = 280, 
                                             module_efficiency = None, 
                                             roof = True,
                                             share_recycled_aluminium = 0.27, 
                                             elec_dataset = None,
                                             inverter_weight = None,  
                                             print_steps = False, 
                                             inverter_lifetime = 15, 
                                             PV_lifetime = 30, 
                                             glass_thickness = 4, 
                                             manufacturing_efficiency_gains = 0,
                                             kerf_loss = 0.44,
                                             wafer_thickness = 200, 
                                             silver_amount = 9.6, 
                                             Silicon_electricity_intensity = i,
                                             d_lorry = 1020, 
                                             d_train = 350, 
                                             d_sea = 4000,
                                             recycling_rate_alu = 0.92, 
                                             recycling_rate_cu = 0.75, 
                                             recycling_rate_glass = 0.9,
                                             recycling_rate = 0.9,
                                             electricity_recycling = 50, 
                                             heat_recycling = 75,
                                             SiC_recycled_share=0.694, 
                                             TEG_recycled_share = 0.899,
                                             DW=False)
    
    bw.calculation_setups['SA'] = {'inv': [system_inv], 'ia': list_methods}
    myMultiLCA = bw.MultiLCA('SA')
    DF_impact[i] = myMultiLCA.results.T

DF_impact.to_pickle('FINAL_PV_IMPACT/SA_silicon_electricity_intensity.pkl')
DF_impact
```

```{python}
df_impact = pd.read_pickle('FINAL_PV_IMPACT/SA_silicon_electricity_intensity.pkl')
df_impact = df_impact.T
df_impact.index.name = 'Silicon electricity content'

df_impact = df_impact[methods_no_LT]
df_impact.columns = [m[2] for m in df_impact.columns]
df_impact = df_impact / 10
#df_impact[df_impact < 0] = 10e3
df_impact
```

```{python}
fig, ax = plt.subplots(5,3, figsize = (16,9))
df_impact.plot(ax = ax, subplots= True, kind = 'area', alpha = 0.7)
for i,axi in enumerate(ax):
    for j, axj in enumerate(axi):
        axj.set_ylabel(ILCD_methods_unit[i*len(axi)+j])
plt.suptitle('Evolution of normalized impacts (impact per kWp installed) \n with the %s'%df_impact.index.name, y = 0.95, fontsize = 20)
#plt.tight_layout()
```

```{python}
df = (df_impact.max() - df_impact.min())/df_impact.median() * 100
fig, ax = plt.subplots(figsize = (9, 6))
plt.title('Relative change with the %s'%df_impact.index.name)
df.plot(kind = 'barh', rot = 30)
ax.set_xlabel('Relative change in percentage of the median value (%)')
plt.tight_layout()

df_RC[df_impact.index.name] = df
```

### Distance by Lorry

```{python}
DF_impact = pd.DataFrame(index = list_methods,)

for i in np.arange(40,2000, 500):
    print(i)
    system_inv = create_dictionary_PV_system(P = 10,
                                             P_module = 280, 
                                             module_efficiency = None, 
                                             roof = True,
                                             share_recycled_aluminium = 0.27, 
                                             elec_dataset = None,
                                             inverter_weight = None,  
                                             print_steps = False, 
                                             inverter_lifetime = 15, 
                                             PV_lifetime = 30, 
                                             glass_thickness = 4, 
                                             manufacturing_efficiency_gains = 0,
                                             kerf_loss = 0.44,
                                             wafer_thickness = 200, 
                                             silver_amount = 9.6, 
                                             Silicon_electricity_intensity = 30+10,
                                             d_lorry = i, 
                                             d_train = 350, 
                                             d_sea = 4000,
                                             recycling_rate_alu = 0.92, 
                                             recycling_rate_cu = 0.75, 
                                             recycling_rate_glass = 0.9,
                                             recycling_rate = 0.9,
                                             electricity_recycling = 50, 
                                             heat_recycling = 75,
                                             SiC_recycled_share=0.694, 
                                             TEG_recycled_share = 0.899,
                                             DW=False)
    
    bw.calculation_setups['SA'] = {'inv': [system_inv], 'ia': list_methods}
    myMultiLCA = bw.MultiLCA('SA')
    DF_impact[i] = myMultiLCA.results.T

DF_impact.to_pickle('FINAL_PV_IMPACT/SA_d_lorry.pkl')
DF_impact
```

```{python}
df_impact = pd.read_pickle('FINAL_PV_IMPACT/SA_d_lorry.pkl')
df_impact = df_impact.T
df_impact.index.name = 'Distance by lorry'

df_impact = df_impact[methods_no_LT]
df_impact.columns = [m[2] for m in df_impact.columns]
df_impact = df_impact / 10
df_impact
```

```{python}
fig, ax = plt.subplots(5,3, figsize = (16,9))
df_impact.plot(ax = ax, subplots= True, kind = 'area', alpha = 0.7)
for i,axi in enumerate(ax):
    for j, axj in enumerate(axi):
        axj.set_ylabel(ILCD_methods_unit[i*len(axi)+j])
plt.suptitle('Evolution of normalized impacts (impact per kWp installed) \n with the %s'%df_impact.index.name, y = 0.95, fontsize = 20)
#plt.tight_layout()
```

```{python}
df = (df_impact.max() - df_impact.min())/df_impact.median() * 100
fig, ax = plt.subplots(figsize = (9, 6))
plt.title('Relative change with the %s'%df_impact.index.name)
df.plot(kind = 'barh', rot = 30)
ax.set_xlabel('Relative change in percentage of the median value (%)')
plt.tight_layout()

df_RC[df_impact.index.name] = df
```

### Distance by Train

```{python}
DF_impact = pd.DataFrame(index = list_methods,)

for i in np.arange(0,600.1, 200):
    print(i)
    system_inv = create_dictionary_PV_system(P = 10,
                                             P_module = 280, 
                                             module_efficiency = None, 
                                             roof = True,
                                             share_recycled_aluminium = 0.27, 
                                             elec_dataset = None,
                                             inverter_weight = None,  
                                             print_steps = False, 
                                             inverter_lifetime = 15, 
                                             PV_lifetime = 30, 
                                             glass_thickness = 4, 
                                             manufacturing_efficiency_gains = 0,
                                             kerf_loss = 0.44,
                                             wafer_thickness = 200, 
                                             silver_amount = 9.6, 
                                             Silicon_electricity_intensity = 30+10,
                                             d_lorry = 1020, 
                                             d_train = i, 
                                             d_sea = 4000,
                                             recycling_rate_alu = 0.92, 
                                             recycling_rate_cu = 0.75, 
                                             recycling_rate_glass = 0.9,
                                             recycling_rate = 0.9,
                                             electricity_recycling = 50, 
                                             heat_recycling = 75,
                                             SiC_recycled_share=0.694, 
                                             TEG_recycled_share = 0.899,
                                             DW=False)
    
    bw.calculation_setups['SA'] = {'inv': [system_inv], 'ia': list_methods}
    myMultiLCA = bw.MultiLCA('SA')
    DF_impact[i] = myMultiLCA.results.T

DF_impact.to_pickle('FINAL_PV_IMPACT/SA_d_train.pkl')
DF_impact
```

```{python}
df_impact = pd.read_pickle('FINAL_PV_IMPACT/SA_d_train.pkl')
df_impact = df_impact.T
df_impact.index.name = 'Distance by train'

df_impact = df_impact[methods_no_LT]
df_impact.columns = [m[2] for m in df_impact.columns]
df_impact = df_impact / 10
df_impact
```

```{python}
fig, ax = plt.subplots(5,3, figsize = (16,9))
df_impact.plot(ax = ax, subplots= True, kind = 'area', alpha = 0.7)
for i,axi in enumerate(ax):
    for j, axj in enumerate(axi):
        axj.set_ylabel(ILCD_methods_unit[i*len(axi)+j])
plt.suptitle('Evolution of normalized impacts (impact per kWp installed) \n with the %s'%df_impact.index.name, y = 0.95, fontsize = 20)
#plt.tight_layout()
```

```{python}
df = (df_impact.max() - df_impact.min())/df_impact.median() * 100
fig, ax = plt.subplots(figsize = (9, 6))
plt.title('Relative change with the %s'%df_impact.index.name)
df.plot(kind = 'barh', rot = 30)
ax.set_xlabel('Relative change in percentage of the median value (%)')
plt.tight_layout()

df_RC[df_impact.index.name] = df
```

### Distance by Ships

```{python}
DF_impact = pd.DataFrame(index = list_methods,)

for i in np.arange(0,6000, 1000):
    print(i)
    system_inv = create_dictionary_PV_system(P = 10,
                                             P_module = 280, 
                                             module_efficiency = None, 
                                             roof = True,
                                             share_recycled_aluminium = 0.27, 
                                             elec_dataset = None,
                                             inverter_weight = None,  
                                             print_steps = False, 
                                             inverter_lifetime = 15, 
                                             PV_lifetime = 30, 
                                             glass_thickness = 4, 
                                             manufacturing_efficiency_gains = 0,
                                             kerf_loss = 0.44,
                                             wafer_thickness = 200, 
                                             silver_amount = 9.6, 
                                             Silicon_electricity_intensity = 30+10,
                                             d_lorry = 1020, 
                                             d_train = 350, 
                                             d_sea = i,
                                             recycling_rate_alu = 0.92, 
                                             recycling_rate_cu = 0.75, 
                                             recycling_rate_glass = 0.9,
                                             recycling_rate = 0.9,
                                             electricity_recycling = 50, 
                                             heat_recycling = 75,
                                             SiC_recycled_share=0.694, 
                                             TEG_recycled_share = 0.899,
                                             DW=False)
    
    bw.calculation_setups['SA'] = {'inv': [system_inv], 'ia': list_methods}
    myMultiLCA = bw.MultiLCA('SA')
    DF_impact[i] = myMultiLCA.results.T

DF_impact.to_pickle('FINAL_PV_IMPACT/SA_d_sea.pkl')
DF_impact
```

```{python}
df_impact = pd.read_pickle('FINAL_PV_IMPACT/SA_d_sea.pkl')
df_impact = df_impact.T
df_impact.index.name = 'Distance by ships'

df_impact = df_impact[methods_no_LT]
df_impact.columns = [m[2] for m in df_impact.columns]
df_impact = df_impact / 10
df_impact
```

```{python}
fig, ax = plt.subplots(5,3, figsize = (16,9))
df_impact.plot(ax = ax, subplots= True, kind = 'area', alpha = 0.7)
for i,axi in enumerate(ax):
    for j, axj in enumerate(axi):
        axj.set_ylabel(ILCD_methods_unit[i*len(axi)+j])
plt.suptitle('Evolution of normalized impacts (impact per kWp installed) \n with the %s'%df_impact.index.name, y = 0.95, fontsize = 20)
#plt.tight_layout()
```

```{python}
df = (df_impact.max() - df_impact.min())/df_impact.median() * 100
fig, ax = plt.subplots(figsize = (9, 6))
plt.title('Relative change with the %s'%df_impact.index.name)
df.plot(kind = 'barh', rot = 30)
ax.set_xlabel('Relative change in percentage of the median value (%)')
plt.tight_layout()

df_RC[df_impact.index.name] = df
```

### Recycling Rate

```{python}
DF_impact = pd.DataFrame(index = list_methods,)

for i in np.arange(0.75,1.1, 0.1):
    print(i)
    system_inv = create_dictionary_PV_system(P = 10,
                                             P_module = 280, 
                                             module_efficiency = None, 
                                             roof = True,
                                             share_recycled_aluminium = 0.27, 
                                             elec_dataset = None,
                                             inverter_weight = None,  
                                             print_steps = False, 
                                             inverter_lifetime = 15, 
                                             PV_lifetime = 30, 
                                             glass_thickness = 4, 
                                             manufacturing_efficiency_gains = 0,
                                             kerf_loss = 0.44,
                                             wafer_thickness = 200, 
                                             silver_amount = 9.6, 
                                             Silicon_electricity_intensity = 30+10,
                                             d_lorry = 1020, 
                                             d_train = 350, 
                                             d_sea = 4000,
                                             recycling_rate_alu = 0.92, 
                                             recycling_rate_cu = 0.75, 
                                             recycling_rate_glass = 0.9,
                                             recycling_rate = i,
                                             electricity_recycling = 50, 
                                             heat_recycling = 75,
                                             SiC_recycled_share=0.694, 
                                             TEG_recycled_share = 0.899,
                                             DW=False)
    
    bw.calculation_setups['SA'] = {'inv': [system_inv], 'ia': list_methods}
    myMultiLCA = bw.MultiLCA('SA')
    DF_impact[i] = myMultiLCA.results.T

DF_impact.to_pickle('FINAL_PV_IMPACT/SA_recycling_rate.pkl')
DF_impact
```

```{python}
df_impact = pd.read_pickle('FINAL_PV_IMPACT/SA_recycling_rate.pkl')
df_impact = df_impact.T
df_impact.index.name = 'Recycling rate'

df_impact = df_impact[methods_no_LT]
df_impact.columns = [m[2] for m in df_impact.columns]
df_impact = df_impact / 10
df_impact
```

```{python}
fig, ax = plt.subplots(5,3, figsize = (16,9))
df_impact.plot(ax = ax, subplots= True, kind = 'area', alpha = 0.7)
for i,axi in enumerate(ax):
    for j, axj in enumerate(axi):
        axj.set_ylabel(ILCD_methods_unit[i*len(axi)+j])
plt.suptitle('Evolution of normalized impacts (impact per kWp installed) \n with the %s'%df_impact.index.name, y = 0.95, fontsize = 20)
#plt.tight_layout()
```

```{python}
df = (df_impact.max() - df_impact.min())/df_impact.median() * 100
fig, ax = plt.subplots(figsize = (9, 6))
plt.title('Relative change with the %s'%df_impact.index.name)
df.plot(kind = 'barh', rot = 30)
ax.set_xlabel('Relative change in percentage of the median value (%)')
plt.tight_layout()

df_RC[df_impact.index.name] = df
```

### Electricity for Recycling 

```{python}
DF_impact = pd.DataFrame(index = list_methods,)

for i in np.arange(50,101,20):
    print(i)
    system_inv = create_dictionary_PV_system(P = 10,
                                             P_module = 280, 
                                             module_efficiency = None, 
                                             roof = True,
                                             share_recycled_aluminium = 0.27, 
                                             elec_dataset = None,
                                             inverter_weight = None,  
                                             print_steps = False, 
                                             inverter_lifetime = 15, 
                                             PV_lifetime = 30, 
                                             glass_thickness = 4, 
                                             manufacturing_efficiency_gains = 0,
                                             kerf_loss = 0.44,
                                             wafer_thickness = 200, 
                                             silver_amount = 9.6, 
                                             Silicon_electricity_intensity = 30+10,
                                             d_lorry = 1020, 
                                             d_train = 350, 
                                             d_sea = 4000,
                                             recycling_rate_alu = 0.92, 
                                             recycling_rate_cu = 0.75, 
                                             recycling_rate_glass = 0.9,
                                             recycling_rate = 0.9,
                                             electricity_recycling = i, 
                                             heat_recycling = 75,
                                             SiC_recycled_share=0.694, 
                                             TEG_recycled_share = 0.899,
                                             DW=False)
    
    bw.calculation_setups['SA'] = {'inv': [system_inv], 'ia': list_methods}
    myMultiLCA = bw.MultiLCA('SA')
    DF_impact[i] = myMultiLCA.results.T

DF_impact.to_pickle('FINAL_PV_IMPACT/SA_recycling_electricity.pkl')
DF_impact
```

```{python}
df_impact = pd.read_pickle('FINAL_PV_IMPACT/SA_recycling_electricity.pkl')
df_impact = df_impact.T
df_impact.index.name = 'Electricity for recycling'

df_impact = df_impact[methods_no_LT]
df_impact.columns = [m[2] for m in df_impact.columns]
df_impact = df_impact / 10
df_impact
```

```{python}
fig, ax = plt.subplots(5,3, figsize = (16,9))
df_impact.plot(ax = ax, subplots= True, kind = 'area', alpha = 0.7)
for i,axi in enumerate(ax):
    for j, axj in enumerate(axi):
        axj.set_ylabel(ILCD_methods_unit[i*len(axi)+j])
plt.suptitle('Evolution of normalized impacts (impact per kWp installed) \n with the %s'%df_impact.index.name, y = 0.95, fontsize = 20)
#plt.tight_layout()
```

```{python}
df = (df_impact.max() - df_impact.min())/df_impact.median() * 100
fig, ax = plt.subplots(figsize = (9, 6))
plt.title('Relative change with the %s'%df_impact.index.name)
df.plot(kind = 'barh', rot = 30)
ax.set_xlabel('Relative change in percentage of the median value (%)')
plt.tight_layout()

df_RC[df_impact.index.name] = df
```

### Heat for Recycling

```{python}
DF_impact = pd.DataFrame(index = list_methods,)

for i in np.arange(75,151,20):
    print(i)
    system_inv = create_dictionary_PV_system(P = 10,
                                             P_module = 280, 
                                             module_efficiency = None, 
                                             roof = True,
                                             share_recycled_aluminium = 0.27, 
                                             elec_dataset = None,
                                             inverter_weight = None,  
                                             print_steps = False, 
                                             inverter_lifetime = 15, 
                                             PV_lifetime = 30, 
                                             glass_thickness = 4, 
                                             manufacturing_efficiency_gains = 0,
                                             kerf_loss = 0.44,
                                             wafer_thickness = 200, 
                                             silver_amount = 9.6, 
                                             Silicon_electricity_intensity = 30+10,
                                             d_lorry = 1020, 
                                             d_train = 350, 
                                             d_sea = 4000,
                                             recycling_rate_alu = 0.92, 
                                             recycling_rate_cu = 0.75, 
                                             recycling_rate_glass = 0.9,
                                             recycling_rate = 0.9,
                                             electricity_recycling = 50, 
                                             heat_recycling = i,
                                             SiC_recycled_share=0.694, 
                                             TEG_recycled_share = 0.899,
                                             DW=False)
    
    bw.calculation_setups['SA'] = {'inv': [system_inv], 'ia': list_methods}
    myMultiLCA = bw.MultiLCA('SA')
    DF_impact[i] = myMultiLCA.results.T

DF_impact.to_pickle('FINAL_PV_IMPACT/SA_recycling_heat.pkl')
DF_impact
```

```{python}
df_impact = pd.read_pickle('FINAL_PV_IMPACT/SA_recycling_heat.pkl')
df_impact = df_impact.T
df_impact.index.name = 'Heat for recycling'

df_impact = df_impact[methods_no_LT]
df_impact.columns = [m[2] for m in df_impact.columns]
df_impact = df_impact / 10
df_impact
```

```{python}
fig, ax = plt.subplots(5,3, figsize = (16,9))
df_impact.plot(ax = ax, subplots= True, kind = 'area', alpha = 0.7)
for i,axi in enumerate(ax):
    for j, axj in enumerate(axi):
        axj.set_ylabel(ILCD_methods_unit[i*len(axi)+j])
plt.suptitle('Evolution of normalized impacts (impact per kWp installed) \n with the %s'%df_impact.index.name, y = 0.95, fontsize = 20)
#plt.tight_layout()
```

```{python}
df = (df_impact.max() - df_impact.min())/df_impact.median() * 100
fig, ax = plt.subplots(figsize = (9, 6))
plt.title('Relative change with the %s'%df_impact.index.name)
df.plot(kind = 'barh', rot = 30)
ax.set_xlabel('Relative change in percentage of the median value (%)')
plt.tight_layout()

df_RC[df_impact.index.name] = df
```

### Recycled SiC

```{python}
DF_impact = pd.DataFrame(index = list_methods,)

for i in np.arange(0.528,1,0.1):
    print(i)
    system_inv = create_dictionary_PV_system(P = 10,
                                             P_module = 280, 
                                             module_efficiency = None, 
                                             roof = True,
                                             share_recycled_aluminium = 0.27, 
                                             elec_dataset = None,
                                             inverter_weight = None,  
                                             print_steps = False, 
                                             inverter_lifetime = 15, 
                                             PV_lifetime = 30, 
                                             glass_thickness = 4, 
                                             manufacturing_efficiency_gains = 0,
                                             kerf_loss = 0.44,
                                             wafer_thickness = 200, 
                                             silver_amount = 9.6, 
                                             Silicon_electricity_intensity = 30+10,
                                             d_lorry = 1020, 
                                             d_train = 350, 
                                             d_sea = 4000,
                                             recycling_rate_alu = 0.92, 
                                             recycling_rate_cu = 0.75, 
                                             recycling_rate_glass = 0.9,
                                             recycling_rate = 0.9,
                                             electricity_recycling = 50, 
                                             heat_recycling = 76,
                                             SiC_recycled_share= i, 
                                             TEG_recycled_share = 0.899,
                                             DW=False)
    
    bw.calculation_setups['SA'] = {'inv': [system_inv], 'ia': list_methods}
    myMultiLCA = bw.MultiLCA('SA')
    DF_impact[i] = myMultiLCA.results.T

DF_impact.to_pickle('FINAL_PV_IMPACT/SA_recycled_SiC.pkl')
DF_impact
```

```{python}
df_impact = pd.read_pickle('FINAL_PV_IMPACT/SA_recycled_SiC.pkl')
df_impact = df_impact.T
df_impact.index.name = 'Share of recycled SiC'

df_impact = df_impact[methods_no_LT]
df_impact.columns = [m[2] for m in df_impact.columns]
df_impact = df_impact / 10
df_impact
```

```{python}
fig, ax = plt.subplots(5,3, figsize = (16,9))
df_impact.plot(ax = ax, subplots= True, kind = 'area', alpha = 0.7)
for i,axi in enumerate(ax):
    for j, axj in enumerate(axi):
        axj.set_ylabel(ILCD_methods_unit[i*len(axi)+j])
plt.suptitle('Evolution of normalized impacts (impact per kWp installed) \n with the %s'%df_impact.index.name, y = 0.95, fontsize = 20)
#plt.tight_layout()
```

```{python}
df = (df_impact.max() - df_impact.min())/df_impact.median() * 100
fig, ax = plt.subplots(figsize = (9, 6))
plt.title('Relative change with the %s'%df_impact.index.name)
df.plot(kind = 'barh', rot = 30)
ax.set_xlabel('Relative change in percentage of the median value (%)')
plt.tight_layout()

df_RC[df_impact.index.name] = df
```

### Recycled TEG

```{python}
DF_impact = pd.DataFrame(index = list_methods,)

for i in np.arange(0.528,1,0.1):
    print(i)
    system_inv = create_dictionary_PV_system(P = 10,
                                             P_module = 280, 
                                             module_efficiency = None, 
                                             roof = True,
                                             share_recycled_aluminium = 0.27, 
                                             elec_dataset = None,
                                             inverter_weight = None,  
                                             print_steps = False, 
                                             inverter_lifetime = 15, 
                                             PV_lifetime = 30, 
                                             glass_thickness = 4, 
                                             manufacturing_efficiency_gains = 0,
                                             kerf_loss = 0.44,
                                             wafer_thickness = 200, 
                                             silver_amount = 9.6, 
                                             Silicon_electricity_intensity = 30+10,
                                             d_lorry = 1020, 
                                             d_train = 350, 
                                             d_sea = 4000,
                                             recycling_rate_alu = 0.92, 
                                             recycling_rate_cu = 0.75, 
                                             recycling_rate_glass = 0.9,
                                             recycling_rate = 0.9,
                                             electricity_recycling = 50, 
                                             heat_recycling = 76,
                                             SiC_recycled_share= 0.694, 
                                             TEG_recycled_share = i,
                                             DW=False)
    
    bw.calculation_setups['SA'] = {'inv': [system_inv], 'ia': list_methods}
    myMultiLCA = bw.MultiLCA('SA')
    DF_impact[i] = myMultiLCA.results.T

DF_impact.to_pickle('FINAL_PV_IMPACT/SA_recycled_TEG.pkl')
DF_impact
```

```{python}
df_impact = pd.read_pickle('FINAL_PV_IMPACT/SA_recycled_TEG.pkl')
df_impact = df_impact.T
df_impact.index.name = 'Share of recycled TEG'

df_impact = df_impact[methods_no_LT]
df_impact.columns = [m[2] for m in df_impact.columns]
df_impact = df_impact / 10
df_impact
```

```{python}
fig, ax = plt.subplots(5,3, figsize = (16,9))
df_impact.plot(ax = ax, subplots= True, kind = 'area', alpha = 0.7)
for i,axi in enumerate(ax):
    for j, axj in enumerate(axi):
        axj.set_ylabel(ILCD_methods_unit[i*len(axi)+j])
plt.suptitle('Evolution of normalized impacts (impact per kWp installed) \n with the %s'%df_impact.index.name, y = 0.95, fontsize = 20)
#plt.tight_layout()
```

```{python}
df = (df_impact.max() - df_impact.min())/df_impact.median() * 100
fig, ax = plt.subplots(figsize = (9, 6))
plt.title('Relative change with the %s'%df_impact.index.name)
df.plot(kind = 'barh', rot = 30)
ax.set_xlabel('Relative change in percentage of the median value (%)')
plt.tight_layout()

df_RC[df_impact.index.name] = df
```

### DW

```{python}
DF_impact = pd.DataFrame(index = list_methods,)

for i in [True, False]:
    print(i)
    system_inv = create_dictionary_PV_system(P = 10,
                                             P_module = 280, 
                                             module_efficiency = None, 
                                             roof = True,
                                             share_recycled_aluminium = 0.27, 
                                             elec_dataset = None,
                                             inverter_weight = None,  
                                             print_steps = False, 
                                             inverter_lifetime = 15, 
                                             PV_lifetime = 30, 
                                             glass_thickness = 4, 
                                             manufacturing_efficiency_gains = 0,
                                             kerf_loss = 0.44,
                                             wafer_thickness = 200, 
                                             silver_amount = 9.6, 
                                             Silicon_electricity_intensity = 30+10,
                                             d_lorry = 1020, 
                                             d_train = 350, 
                                             d_sea = 4000,
                                             recycling_rate_alu = 0.92, 
                                             recycling_rate_cu = 0.75, 
                                             recycling_rate_glass = 0.9,
                                             recycling_rate = 0.9,
                                             electricity_recycling = 50, 
                                             heat_recycling = 76,
                                             SiC_recycled_share= 0.694, 
                                             TEG_recycled_share = 0.899,
                                             DW=i)
    
    bw.calculation_setups['SA'] = {'inv': [system_inv], 'ia': list_methods}
    myMultiLCA = bw.MultiLCA('SA')
    DF_impact[i] = myMultiLCA.results.T

DF_impact.to_pickle('FINAL_PV_IMPACT/SA_DW.pkl')
DF_impact
```

```{python}
df_impact = pd.read_pickle('FINAL_PV_IMPACT/SA_DW.pkl')
df_impact = df_impact.T
df_impact.index.name = 'Diamond Wiring (DW) cutting process'

df_impact = df_impact[methods_no_LT]
df_impact.columns = [m[2] for m in df_impact.columns]
df_impact = df_impact / 10
df_impact
```

```{python}
fig, ax = plt.subplots(5,3, figsize = (16,9))
df_impact.plot(ax = ax, subplots= True, kind = 'area', alpha = 0.7)
for i,axi in enumerate(ax):
    for j, axj in enumerate(axi):
        axj.set_ylabel(ILCD_methods_unit[i*len(axi)+j])
plt.suptitle('Evolution of normalized impacts (impact per kWp installed) \n with the %s'%df_impact.index.name, y = 0.95, fontsize = 20)
#plt.tight_layout()
```

```{python}
df = (df_impact.max() - df_impact.min())/df_impact.median() * 100
fig, ax = plt.subplots(figsize = (9, 6))
plt.title('Relative change with the %s'%df_impact.index.name)
df.plot(kind = 'barh', rot = 30)
ax.set_xlabel('Relative change in percentage of the median value (%)')
plt.tight_layout()

df_RC[df_impact.index.name] = df
```

### Aluminum Recycling Rate

```{python}
DF_impact = pd.DataFrame(index = list_methods,)

for i in np.arange(0.56,1.1, 0.1):
    print(i)
    system_inv = create_dictionary_PV_system(P = 10,
                                             P_module = 280, 
                                             module_efficiency = None, 
                                             roof = True,
                                             share_recycled_aluminium = 0.27, 
                                             elec_dataset = None,
                                             inverter_weight = None,  
                                             print_steps = False, 
                                             inverter_lifetime = 15, 
                                             PV_lifetime = 30, 
                                             glass_thickness = 4, 
                                             manufacturing_efficiency_gains = 0,
                                             kerf_loss = 0.44,
                                             wafer_thickness = 200, 
                                             silver_amount = 9.6, 
                                             Silicon_electricity_intensity = 30+10,
                                             d_lorry = 1020, 
                                             d_train = 350, 
                                             d_sea = 4000,
                                             recycling_rate_alu = i, 
                                             recycling_rate_cu = 0.75, 
                                             recycling_rate_glass = 0.9,
                                             recycling_rate = 0.9,
                                             electricity_recycling = 50, 
                                             heat_recycling = 76,
                                             SiC_recycled_share= 0.694, 
                                             TEG_recycled_share = 0.899,
                                             DW= False)
    
    bw.calculation_setups['SA'] = {'inv': [system_inv], 'ia': list_methods}
    myMultiLCA = bw.MultiLCA('SA')
    DF_impact[i] = myMultiLCA.results.T

DF_impact.to_pickle('FINAL_PV_IMPACT/SA_aluminum_recycling_share.pkl')
DF_impact
```

```{python}
df_impact = pd.read_pickle('FINAL_PV_IMPACT/SA_aluminum_recycling_share.pkl')
df_impact = df_impact.T
df_impact.index.name = 'Aluminum recycling rate'

df_impact = df_impact[methods_no_LT]
df_impact.columns = [m[2] for m in df_impact.columns]
df_impact = df_impact / 10
df_impact
```

```{python}
df = (df_impact.max() - df_impact.min())/df_impact.median() * 100
fig, ax = plt.subplots(figsize = (9, 6))
plt.title('Relative change with the %s'%df_impact.index.name)
df.plot(kind = 'barh', rot = 30)
ax.set_xlabel('Relative change in percentage of the median value (%)')
plt.tight_layout()

df_RC[df_impact.index.name] = df
```

### Copper Recycling Rate

```{python}
DF_impact = pd.DataFrame(index = list_methods,)

for i in np.arange(0.44,1, 0.1):
    print(i)
    system_inv = create_dictionary_PV_system(P = 10,
                                             P_module = 280, 
                                             module_efficiency = None, 
                                             roof = True,
                                             share_recycled_aluminium = 0.27, 
                                             elec_dataset = None,
                                             inverter_weight = None,  
                                             print_steps = False, 
                                             inverter_lifetime = 15, 
                                             PV_lifetime = 30, 
                                             glass_thickness = 4, 
                                             manufacturing_efficiency_gains = 0,
                                             kerf_loss = 0.44,
                                             wafer_thickness = 200, 
                                             silver_amount = 9.6, 
                                             Silicon_electricity_intensity = 30+10,
                                             d_lorry = 1020, 
                                             d_train = 350, 
                                             d_sea = 4000,
                                             recycling_rate_alu = 0.96, 
                                             recycling_rate_cu = i, 
                                             recycling_rate_glass = 0.9,
                                             recycling_rate = 0.9,
                                             electricity_recycling = 50, 
                                             heat_recycling = 76,
                                             SiC_recycled_share= 0.694, 
                                             TEG_recycled_share = 0.899,
                                             DW= False)
    
    bw.calculation_setups['SA'] = {'inv': [system_inv], 'ia': list_methods}
    myMultiLCA = bw.MultiLCA('SA')
    DF_impact[i] = myMultiLCA.results.T

DF_impact.to_pickle('FINAL_PV_IMPACT/SA_copper_recycling_share.pkl')
DF_impact
```

```{python}
df_impact = pd.read_pickle('FINAL_PV_IMPACT/SA_copper_recycling_share.pkl')
df_impact = df_impact.T
df_impact.index.name = 'Copper recycling rate'

df_impact = df_impact[methods_no_LT]
df_impact.columns = [m[2] for m in df_impact.columns]
df_impact = df_impact / 10
df_impact
```

```{python}
fig, ax = plt.subplots(5,3, figsize = (16,9))
df_impact.plot(ax = ax, subplots= True, kind = 'area', alpha = 0.7)
for i,axi in enumerate(ax):
    for j, axj in enumerate(axi):
        axj.set_ylabel(ILCD_methods_unit[i*len(axi)+j])
plt.suptitle('Evolution of normalized impacts (impact per kWp installed) \n with the %s'%df_impact.index.name, y = 0.95, fontsize = 20)
#plt.tight_layout()
```

```{python}
df = (df_impact.max() - df_impact.min())/df_impact.median() * 100
fig, ax = plt.subplots(figsize = (9, 6))
plt.title('Relative change with the %s'%df_impact.index.name)
df.plot(kind = 'barh', rot = 30)
ax.set_xlabel('Relative change in percentage of the median value (%)')
plt.tight_layout()

df_RC[df_impact.index.name] = df
```

### Glass Recycling Share

```{python}
DF_impact = pd.DataFrame(index = list_methods,)

for i in np.arange(0.6,1, 0.1):
    print(i)
    system_inv = create_dictionary_PV_system(P = 10,
                                             P_module = 280, 
                                             module_efficiency = None, 
                                             roof = True,
                                             share_recycled_aluminium = 0.27, 
                                             elec_dataset = None,
                                             inverter_weight = None,  
                                             print_steps = False, 
                                             inverter_lifetime = 15, 
                                             PV_lifetime = 30, 
                                             glass_thickness = 4, 
                                             manufacturing_efficiency_gains = 0,
                                             kerf_loss = 0.44,
                                             wafer_thickness = 200, 
                                             silver_amount = 9.6, 
                                             Silicon_electricity_intensity = 30+10,
                                             d_lorry = 1020, 
                                             d_train = 350, 
                                             d_sea = 4000,
                                             recycling_rate_alu = 0.96, 
                                             recycling_rate_cu = 0.75, 
                                             recycling_rate_glass = i,
                                             recycling_rate = 0.9,
                                             electricity_recycling = 50, 
                                             heat_recycling = 76,
                                             SiC_recycled_share= 0.694, 
                                             TEG_recycled_share = 0.899,
                                             DW= False)
    
    bw.calculation_setups['SA'] = {'inv': [system_inv], 'ia': list_methods}
    myMultiLCA = bw.MultiLCA('SA')
    DF_impact[i] = myMultiLCA.results.T

DF_impact.to_pickle('FINAL_PV_IMPACT/SA_glass_recycling_share.pkl')
DF_impact
```

```{python}
df_impact = pd.read_pickle('FINAL_PV_IMPACT/SA_glass_recycling_share.pkl')
df_impact = df_impact.T
df_impact.index.name = 'Glass recycling rate'

df_impact = df_impact[methods_no_LT]
df_impact.columns = [m[2] for m in df_impact.columns]
df_impact = df_impact / 10
df_impact
```

```{python}
fig, ax = plt.subplots(5,3, figsize = (16,9))
df_impact.plot(ax = ax, subplots= True, kind = 'area', alpha = 0.7)
for i,axi in enumerate(ax):
    for j, axj in enumerate(axi):
        axj.set_ylabel(ILCD_methods_unit[i*len(axi)+j])
plt.suptitle('Evolution of normalized impacts (impact per kWp installed) \n with the %s'%df_impact.index.name, y = 0.95, fontsize = 20)
#plt.tight_layout()
```

```{python}
df = (df_impact.max() - df_impact.min())/df_impact.median() * 100
fig, ax = plt.subplots(figsize = (9, 6))
plt.title('Relative change with the %s'%df_impact.index.name)
df.plot(kind = 'barh', rot = 30)
ax.set_xlabel('Relative change in percentage of the median value (%)')
plt.tight_layout()

df_RC[df_impact.index.name] = df
```

### Irradiation

```{python}
DF_impact = pd.DataFrame(index = list_methods,)

for i in np.arange(900,2800, 200):
    print(i)
    system_inv = create_dictionary_PV_system(P = 10,
                                             P_module = 280, 
                                             module_efficiency = None, 
                                             roof = True,
                                             share_recycled_aluminium = 0.27, 
                                             elec_dataset = None,
                                             inverter_weight = None,  
                                             print_steps = False, 
                                             inverter_lifetime = 15, 
                                             PV_lifetime = 30, 
                                             glass_thickness = 4, 
                                             manufacturing_efficiency_gains = 0,
                                             kerf_loss = 0.44,
                                             wafer_thickness = 200, 
                                             silver_amount = 9.6, 
                                             Silicon_electricity_intensity = 30+10,
                                             d_lorry = 1020, 
                                             d_train = 350, 
                                             d_sea = 4000,
                                             recycling_rate_alu = 0.96, 
                                             recycling_rate_cu = 0.75, 
                                             recycling_rate_glass = 0.9,
                                             recycling_rate = 0.9,
                                             electricity_recycling = 50, 
                                             heat_recycling = 76,
                                             SiC_recycled_share= 0.694, 
                                             TEG_recycled_share = 0.899,
                                             DW= False)
    
    bw.calculation_setups['SA'] = {'inv': [system_inv], 'ia': list_methods}
    myMultiLCA = bw.MultiLCA('SA')
    DF_impact[i] = (myMultiLCA.results.T/(i*10*30))
    

DF_impact.to_pickle('FINAL_PV_IMPACT/SA_irradiation.pkl')
DF_impact
```

```{python}
df_impact = pd.read_pickle('FINAL_PV_IMPACT/SA_irradiation.pkl')
df_impact = df_impact.T
df_impact.index.name = 'Irradiation'

df_impact = df_impact[methods_no_LT]
df_impact.columns = [m[2] for m in df_impact.columns]
df_impact = df_impact / 10
df_impact
```

```{python}
fig, ax = plt.subplots(5,3, figsize = (16,9))
df_impact.plot(ax = ax, subplots= True, kind = 'area', alpha = 0.7)
for i,axi in enumerate(ax):
    for j, axj in enumerate(axi):
        axj.set_ylabel(ILCD_methods_unit[i*len(axi)+j])
plt.suptitle('Evolution of normalized impacts (impact per kWp installed) \n with the %s'%df_impact.index.name, y = 0.95, fontsize = 20)
#plt.tight_layout()
```

```{python}
df = (df_impact.max() - df_impact.min())/df_impact.median() * 100
fig, ax = plt.subplots(figsize = (9, 6))
plt.title('Relative change with the %s'%df_impact.index.name)
df.plot(kind = 'barh', rot = 30)
ax.set_xlabel('Relative change in percentage of the median value (%)')
plt.tight_layout()

df_RC[df_impact.index.name] = df
```

### PR

```{python}
DF_impact = pd.DataFrame(index = list_methods,)

for i in np.arange(0.64,1, 0.1):
    print(i)
    system_inv = create_dictionary_PV_system(P = 10,
                                             P_module = 280, 
                                             module_efficiency = None, 
                                             roof = True,
                                             share_recycled_aluminium = 0.27, 
                                             elec_dataset = None,
                                             inverter_weight = None,  
                                             print_steps = False, 
                                             inverter_lifetime = 15, 
                                             PV_lifetime = 30, 
                                             glass_thickness = 4, 
                                             manufacturing_efficiency_gains = 0,
                                             kerf_loss = 0.44,
                                             wafer_thickness = 200, 
                                             silver_amount = 9.6, 
                                             Silicon_electricity_intensity = 30+10,
                                             d_lorry = 1020, 
                                             d_train = 350, 
                                             d_sea = 4000,
                                             recycling_rate_alu = 0.96, 
                                             recycling_rate_cu = 0.75, 
                                             recycling_rate_glass = 0.9,
                                             recycling_rate = 0.9,
                                             electricity_recycling = 50, 
                                             heat_recycling = 76,
                                             SiC_recycled_share= 0.694, 
                                             TEG_recycled_share = 0.899,
                                             DW= False)
    
    bw.calculation_setups['SA'] = {'inv': [system_inv], 'ia': list_methods}
    myMultiLCA = bw.MultiLCA('SA')
    prod = assessed_PV_productivity(weather = weather['2017'], latitude = lat,
                                    longitude = lon, inclinaison = 30, 
                                    azimuth = 180, name = 'Antibes_Production',
                                    PR = i, altitude = 0, timezone = 'Europe/Paris', 
                                    DR = 0.005, lifespan = 30, tracker = False, 
                                    gcr = 0.3, backtrack = True, max_angle = 60) 
    DF_impact[i] = (myMultiLCA.results.T/prod[0])
    

DF_impact.to_pickle('FINAL_PV_IMPACT/SA_PR.pkl')
DF_impact
```

```{python}
df_impact = pd.read_pickle('FINAL_PV_IMPACT/SA_PR.pkl')
df_impact = df_impact.T
df_impact.index.name = 'Performance Ratio (PR)'

df_impact = df_impact[methods_no_LT]
df_impact.columns = [m[2] for m in df_impact.columns]
df_impact = df_impact / 10
df_impact
```

```{python}
fig, ax = plt.subplots(5,3, figsize = (16,9))
df_impact.plot(ax = ax, subplots= True, kind = 'area', alpha = 0.7)
for i,axi in enumerate(ax):
    for j, axj in enumerate(axi):
        axj.set_ylabel(ILCD_methods_unit[i*len(axi)+j])
plt.suptitle('Evolution of normalized impacts (impact per kWp installed) \n with the %s'%df_impact.index.name, y = 0.95, fontsize = 20)
#plt.tight_layout()
```

```{python}
df = (df_impact.max() - df_impact.min())/df_impact.median() * 100
fig, ax = plt.subplots(figsize = (9, 6))
plt.title('Relative change with the %s'%df_impact.index.name)
df.plot(kind = 'barh', rot = 30)
ax.set_xlabel('Relative change in percentage of the median value (%)')
plt.tight_layout()

df_RC[df_impact.index.name] = df
```

### Degradation Rate

```{python}
DF_impact = pd.DataFrame(index = list_methods,)

for i in np.arange(0.05,0.08, 0.01):
    print(i)
    system_inv = create_dictionary_PV_system(P = 10,
                                             P_module = 280, 
                                             module_efficiency = None, 
                                             roof = True,
                                             share_recycled_aluminium = 0.27, 
                                             elec_dataset = None,
                                             inverter_weight = None,  
                                             print_steps = False, 
                                             inverter_lifetime = 15, 
                                             PV_lifetime = 30, 
                                             glass_thickness = 4, 
                                             manufacturing_efficiency_gains = 0,
                                             kerf_loss = 0.44,
                                             wafer_thickness = 200, 
                                             silver_amount = 9.6, 
                                             Silicon_electricity_intensity = 30+10,
                                             d_lorry = 1020, 
                                             d_train = 350, 
                                             d_sea = 4000,
                                             recycling_rate_alu = 0.96, 
                                             recycling_rate_cu = 0.75, 
                                             recycling_rate_glass = 0.9,
                                             recycling_rate = 0.9,
                                             electricity_recycling = 50, 
                                             heat_recycling = 76,
                                             SiC_recycled_share= 0.694, 
                                             TEG_recycled_share = 0.899,
                                             DW= False)
    
    bw.calculation_setups['SA'] = {'inv': [system_inv], 'ia': list_methods}
    myMultiLCA = bw.MultiLCA('SA')
    prod = assessed_PV_productivity(weather = weather['2017'], latitude = lat,
                                    longitude = lon, inclinaison = 30, 
                                    azimuth = 180, name = 'Antibes_Production',
                                    PR = 0.85, altitude = 0, timezone = 'Europe/Paris', 
                                    DR = i, lifespan = 30, tracker = False, 
                                    gcr = 0.3, backtrack = True, max_angle = 60) 
    DF_impact[i] = (myMultiLCA.results.T/prod[0])
    

DF_impact.to_pickle('FINAL_PV_IMPACT/SA_DR.pkl')
DF_impact
```

```{python}
DR = 0.07
(1.0-(1-DR)**(30))/(1-(1-DR))
```

```{python}

```

```{python}
15.7/12.6
```

```{python}
(1-0.05)**30/(1-0.05)
```

```{python}
(1-0.07)**30/(1-0.07)
```

```{python}
df_impact = pd.read_pickle('FINAL_PV_IMPACT/SA_DR.pkl')
df_impact = df_impact.T
df_impact.index.name = 'Degradation rate'

df_impact = df_impact[methods_no_LT]
df_impact.columns = [m[2] for m in df_impact.columns]
df_impact = df_impact / 10
df_impact
```

```{python}
fig, ax = plt.subplots(5,3, figsize = (16,9))
df_impact.plot(ax = ax, subplots= True, kind = 'area', alpha = 0.7)
for i,axi in enumerate(ax):
    for j, axj in enumerate(axi):
        axj.set_ylabel(ILCD_methods_unit[i*len(axi)+j])
plt.suptitle('Evolution of normalized impacts (impact per kWp installed) \n with the %s'%df_impact.index.name, y = 0.95, fontsize = 20)
#plt.tight_layout()
```

```{python}
df = (df_impact.max() - df_impact.min())/df_impact.median() * 100
fig, ax = plt.subplots(figsize = (9, 6))
plt.title('Relative change with the %s'%df_impact.index.name)
df.plot(kind = 'barh', rot = 30)
ax.set_xlabel('Relative change in percentage of the median value (%)')
plt.tight_layout()

df_RC[df_impact.index.name] = df
```

### Orientation

```{python}
DF_impact = pd.DataFrame(index = list_methods,)

for i in np.arange(20,60, 10):
    print(i)
    system_inv = create_dictionary_PV_system(P = 10,
                                             P_module = 280, 
                                             module_efficiency = None, 
                                             roof = True,
                                             share_recycled_aluminium = 0.27, 
                                             elec_dataset = None,
                                             inverter_weight = None,  
                                             print_steps = False, 
                                             inverter_lifetime = 15, 
                                             PV_lifetime = 30, 
                                             glass_thickness = 4, 
                                             manufacturing_efficiency_gains = 0,
                                             kerf_loss = 0.44,
                                             wafer_thickness = 200, 
                                             silver_amount = 9.6, 
                                             Silicon_electricity_intensity = 30+10,
                                             d_lorry = 1020, 
                                             d_train = 350, 
                                             d_sea = 4000,
                                             recycling_rate_alu = 0.96, 
                                             recycling_rate_cu = 0.75, 
                                             recycling_rate_glass = 0.9,
                                             recycling_rate = 0.9,
                                             electricity_recycling = 50, 
                                             heat_recycling = 76,
                                             SiC_recycled_share= 0.694, 
                                             TEG_recycled_share = 0.899,
                                             DW= False)
    
    bw.calculation_setups['SA'] = {'inv': [system_inv], 'ia': list_methods}
    myMultiLCA = bw.MultiLCA('SA')
    prod = assessed_PV_productivity(weather = weather['2017'], latitude = lat,
                                    longitude = lon, inclinaison = i, 
                                    azimuth = 180, name = 'Antibes_Production',
                                    PR = 0.85, altitude = 0, timezone = 'Europe/Paris', 
                                    DR = 0.5, lifespan = 30, tracker = False, 
                                    gcr = 0.3, backtrack = True, max_angle = 60) 
    DF_impact[i] = (myMultiLCA.results.T/prod[0])
    

DF_impact.to_pickle('FINAL_PV_IMPACT/SA_orientation.pkl')
DF_impact
```

```{python}
df_impact = pd.read_pickle('FINAL_PV_IMPACT/SA_orientation.pkl')
df_impact = df_impact.T
df_impact.index.name = 'Orientation'

df_impact = df_impact[methods_no_LT]
df_impact.columns = [m[2] for m in df_impact.columns]
df_impact = df_impact / 10
df_impact
```

```{python}
fig, ax = plt.subplots(5,3, figsize = (16,9))
df_impact.plot(ax = ax, subplots= True, kind = 'area', alpha = 0.7)
for i,axi in enumerate(ax):
    for j, axj in enumerate(axi):
        axj.set_ylabel(ILCD_methods_unit[i*len(axi)+j])
plt.suptitle('Evolution of normalized impacts (impact per kWp installed) \n with the %s'%df_impact.index.name, y = 0.95, fontsize = 20)
#plt.tight_layout()
```

```{python}
df = (df_impact.max() - df_impact.min())/df_impact.median() * 100
fig, ax = plt.subplots(figsize = (9, 6))
plt.title('Relative change with the %s'%df_impact.index.name)
df.plot(kind = 'barh', rot = 30)
ax.set_xlabel('Relative change in percentage of the median value (%)')
plt.tight_layout()

df_RC[df_impact.index.name] = df
```

```{python}
df_RC.to_pickle('FINAL_PV_IMPACT/SA_relative_change.pkl')
```

### Final Full OAT Graph

```{python}
df_RC = pd.read_pickle('FINAL_PV_IMPACT/SA_relative_change.pkl')
df_RC
```

```{python}
len(df_RC.T) #30 parameters
```

```{python}
import seaborn as sns
```

```{python}
#We drop the panel efficiency 2 because it can be calculate by 2 methods:
#either by modifying the module_efficiency or by modifying the P_module
df_RC.drop('Panel efficieny 2',axis=1, inplace=True)
```

```{python}
fig, ax = plt.subplots(figsize = (30, 12))
sns.heatmap(df_RC, cmap= "Reds", vmax=50, annot= True,)
plt.title('Relative change of impacts with respect to the variability of 30 parameters',
          fontsize = 26)
ax.tick_params(axis="x", labelsize=15)
ax.tick_params(axis="y", labelsize=15)
```

```{python}
fig, ax = plt.subplots(figsize = (30, 12))
sns.heatmap(df_RC, cmap= "Blues", vmax=50, annot= True,)
plt.title('Relative change of impacts with respect to the variability of 30 parameters',
          fontsize = 26)
ax.tick_params(axis="x", labelsize=15)
ax.tick_params(axis="y", labelsize=15)
```

```{python}
fig, ax = plt.subplots(figsize = (30, 12))
sns.heatmap(df_RC, cmap= "gist_heat_r", vmax=50, annot= True,)
plt.title('Relative change of impacts with respect to the variability of 30 parameters',
          fontsize = 26)
ax.tick_params(axis="x", labelsize=15)
ax.tick_params(axis="y", labelsize=15)
```

```{python}
fig, ax = plt.subplots(figsize = (30, 12))
sns.heatmap(df_RC, cmap= "summer", vmax=50, annot= True,)
plt.title('Relative change of impacts with respect to the variability of 30 parameters',
          fontsize = 26)
ax.tick_params(axis="x", labelsize=15)
ax.tick_params(axis="y", labelsize=15)
```
