<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.4" />
<title>lca_algebraic.params API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>lca_algebraic.params</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import builtins
import math
import numpy as np
from typing import Dict, List, Union, Tuple

import brightway2 as bw
from tabulate import tabulate
from IPython.core.display import HTML
from bw2data.parameters import ActivityParameter, ProjectParameter, DatabaseParameter, Group
from scipy.stats import triang, truncnorm, norm, beta
from sympy import Symbol
from collections import defaultdict

import lca_algebraic.base_utils
from .base_utils import _eprint, as_np_array

DEFAULT_PARAM_GROUP = &#34;acv&#34;
UNCERTAINTY_TYPE = &#34;uncertainty type&#34;

def _param_registry():
    # Prevent reset upon auto reload in jupyter notebook
    if not &#39;param_registry&#39; in builtins.__dict__:
        builtins.param_registry = dict()

    return builtins.param_registry



class ParamType:
    &#34;&#34;&#34;Type of parameters&#34;&#34;&#34;

    ENUM = &#34;enum&#34;

    BOOL = &#34;bool&#34;

    FLOAT = &#34;float&#34;


class DistributionType:
    &#34;&#34;&#34;
        Type of statistic distribution of a parameter.
        Some type of distribution requires extra parameters, in italic, to be provided in the constructor of **ParamDef**()
    &#34;&#34;&#34;

    LINEAR = &#34;linear&#34;
    &#34;&#34;&#34; Uniform distribution between *min* and *max*&#34;&#34;&#34;

    NORMAL = &#34;normal&#34;
    &#34;&#34;&#34; Normal distribution, centered on *default* value (mean), with deviation of *std* and truncated between *min* and *max*&#34;&#34;&#34;

    LOGNORMAL = &#34;lognormal&#34;
    &#34;&#34;&#34; Lognormal distribution, centered on *default* value (mean), with deviation of *std*, not truncated &#34;&#34;&#34;

    BETA = &#34;beta&#34; # requires a, b &#39;default&#39; is used as the mean. &#39;std&#39; is used as &#39;scale&#39; factor
    &#34;&#34;&#34; Beta distribution with extra params *a* and *b*, 
    using *default* value as &#39;loc&#39; (0 of beta distribution) and *std* as &#39;scale&#39; (1 of beta distribution)
    See [scipy doc](https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.beta.html#scipy.stats.beta) &#34;&#34;&#34;

    TRIANGLE = &#34;triangle&#34;
    &#34;&#34;&#34; Triangle distribution between *min* and *max* (set to zero probability), with highest probability at *default* value &#34;&#34;&#34;

    FIXED = &#34;fixed&#34;
    &#34;&#34;&#34; Fixed value, not considered as a variable input for monte carlo simulation. &#34;&#34;&#34;


class _UncertaintyType :
    &#39;&#39;&#39;Enum of uncertainty types of Brightway.
    See https://stats-arrays.readthedocs.io/en/latest/
    &#39;&#39;&#39;
    UNDEFINED = 0
    FIXED = 1
    LOGNORMAL = 2
    NORMAL = 3
    UNIFORM = 4
    TRIANGLE = 5
    DISCRETE = 7
    BETA = 10


# Map to Brightay2 / stats-arrays Distribution Type
_DistributionTypeMap = {
    DistributionType.LINEAR : _UncertaintyType.UNIFORM,
    DistributionType.BETA : _UncertaintyType.BETA,
    DistributionType.NORMAL : _UncertaintyType.NORMAL,
    DistributionType.LOGNORMAL: _UncertaintyType.LOGNORMAL,
    DistributionType.TRIANGLE : _UncertaintyType.TRIANGLE,
    DistributionType.FIXED : _UncertaintyType.FIXED, # I made that up
}

_DistributionTypeMapReverse = {val:key for key, val in _DistributionTypeMap.items()}


class FixedParamMode:
    &#34;&#34;&#34; Enum describing what value to set for fixed params &#34;&#34;&#34;
    DEFAULT = &#34;default&#34;
    MEDIAN = &#34;median&#34;
    MEAN = &#34;mean&#34;

class ParamDef(Symbol):
    &#39;&#39;&#39;Generic definition of a parameter, with name, bound, type, distribution
    This definition will serve both to generate brightway2 parameters and to evaluate.

    This class inherits sympy Symbol, making it possible to use in standard arithmetic python
    while keeping it as a symbolic expression (delayed evaluation).
    &#39;&#39;&#39;

    def __new__(cls, name, *karg, **kargs):
        return Symbol.__new__(cls, name)

    def __init__(self, name, type: str, default, min=None, max=None, unit=&#34;&#34;, description=&#34;&#34;, label=None, label_fr=None,
                 group=None, distrib=None, **kwargs):

        self.name = name
        self.type = type
        self.default = default
        self.description = description
        self.min = min
        self.max = max
        self.unit = unit
        self.label = label
        self.label_fr = label_fr
        self.group = group
        self.distrib = distrib

        # Cleanup distribution in case of overriding already existing param (reused because of inheritance of Symbol)
        if hasattr(self, &#34;_distrib&#34;) :
            del self._distrib

        if not distrib :
            if type == ParamType.FLOAT and self.min is None:
                self.distrib = DistributionType.FIXED
            else:
                self.distrib = DistributionType.LINEAR

        elif distrib in [DistributionType.NORMAL, DistributionType.LOGNORMAL] :
            if not &#39;std&#39; in kwargs:
                raise Exception(&#34;Standard deviation is mandatory for normal / lognormal distribution&#34;)
            self.std = kwargs[&#39;std&#39;]

            if distrib == DistributionType.LOGNORMAL and self.min is not None :
                _eprint(&#34;Warning : LogNormal does not support min/max boundaries for parameter : &#34;, self.name)

        elif distrib == DistributionType.BETA :
            if not &#39;a&#39; in kwargs or not &#39;b&#39; in kwargs or not &#39;std&#39; in kwargs :
                raise Exception(&#34;Beta distribution requires params &#39;a&#39; &#39;b&#39; and &#39;std&#39; (used as scale)&#34;)
            self.a = kwargs[&#39;a&#39;]
            self.b = kwargs[&#39;b&#39;]
            self.std = kwargs[&#39;std&#39;]

    def stat_value(self, mode : FixedParamMode):
        &#34;&#34;&#34;Method used to compute fixed statistic value to use for fixed variables&#34;&#34;&#34;
        if mode == FixedParamMode.DEFAULT :
            return self.default
        else :
            # Compute statistical value for replacement
            rnd = np.random.rand(1000)
            x = self.rand(rnd)

            if mode == FixedParamMode.MEAN :
                return np.mean(x)
            elif mode == FixedParamMode.MEDIAN :
                return np.median(x)
            else :
                raise Exception(&#34;Unkown mode &#34; + mode)


    def get_label(self):
        if lca_algebraic.base_utils.LANG == &#34;fr &#34; and self.label_fr is not None :
            return self.label_fr
        elif self.label is not None:
            return self.label
        else:
            return self.name.replace(&#34;_&#34;, &#34; &#34;)

    def range(self, n):
        &#39;&#39;&#39;Used for parametric analysis&#39;&#39;&#39;
        step = (self.max - self.min) / (n - 1)
        return list(i * step + self.min for i in range(0, n))

    def rand(self, alpha):
        &#34;&#34;&#34;Transforms a random number between 0 and 1 to valid value according to the distribution of probability of the parameter&#34;&#34;&#34;

        if self.distrib == DistributionType.FIXED :
            return self.default
        
        elif self.distrib == DistributionType.LINEAR:
            return self.min + alpha * (self.max - self.min)

        else :
            if not hasattr(self, &#34;_distrib&#34;):

                if self.distrib == DistributionType.TRIANGLE:
                    scale = self.max - self.min
                    c = (self.default - self.min) / scale
                    self._distrib = triang(c, loc=self.min, scale=scale)

                elif self.distrib == DistributionType.NORMAL:

                    if self.min :
                        # Truncated normal
                        self._distrib = truncnorm(
                            (self.min - self.default) / self.std,
                            (self.max - self.min) / self.std,
                            loc=self.default,
                            scale=self.std)
                    else :
                        # Normal
                        self._distrib = norm(
                            loc=self.default,
                            scale=self.std)

                elif self.distrib == DistributionType.BETA:
                    self._distrib = beta(
                        self.a,
                        self.b,
                        loc=self.default,
                        scale=self.std)

                else:
                    raise Exception(&#34;Unkown distribution type &#34; + self.distrib)


            return self._distrib.ppf(alpha)



    # Expand parameter (useful for enum param)
    def expandParams(self, value=None) -&gt; Dict[str, float]:
        if value == None:
            value = self.default
        return {self.name: value}

    # Useful for enum param, having several names
    def names(self, use_label=False):
        if use_label :
            return [self.get_label()]
        else:
            return [self.name]

    def __repr__(self):
        return self.name


class BooleanDef(ParamDef):
    &#34;&#34;&#34;Parameter with discrete value 0 or 1&#34;&#34;&#34;

    def __init__(self, name, **argv):
        if not &#34;min&#34; in argv:
            argv = dict(argv, min=None, max=None)
        super(BooleanDef, self).__init__(name, ParamType.BOOL, **argv)


    def range(self, n):
        return [0, 1]

    def rand(self, alpha):
        return np.around(alpha)


class EnumParam(ParamDef):
    &#34;&#34;&#34;Enum param is a facility representing a choice / switch as many boolean parameters.
    It is not itself a Sympy symbol. use #symbol(&#34;value&#34;) to access it.
    Statistics weight can be attached to values by providing a dict.
    &#34;&#34;&#34;

    def __init__(self, name, values: Union[List[str], Dict[str, float]], **argv):

        if not &#34;min&#34; in argv :
            argv = dict(argv, min=None, max=None)
        super(EnumParam, self).__init__(name, ParamType.ENUM, **argv)
        if type(values) == list :
            self.values = values
            self.weights = {key:1 for key in values}
        else :
            self.weights = values
            self.values = list(values)
        self.sum = sum(self.weights.values())

    def expandParams(self, currValue=None):

        # A dict of weights was passed
        if isinstance(currValue, dict) :
            res = { &#34;%s_%s&#34; % (self.name, key) : val / self.sum for key, val in currValue.items()}
            res[&#34;%s_default&#34; % self.name] = 0
            return res

        # Normal case
        values = self.values + [None]
        res = dict()
        for enum_val in values:
            var_name = &#34;%s_%s&#34; % (self.name, enum_val if enum_val is not None else &#34;default&#34;)
            res[var_name] = 1.0 if enum_val == currValue else 0.0
        return res

    def symbol(self, enumValue):
        &#34;&#34;&#34;Access parameter for each enum value : &lt;paramName&gt;_&lt;paramValue&gt;&#34;&#34;&#34;
        if enumValue is None:
            return Symbol(self.name + &#39;_default&#39;)
        if not enumValue in self.values:
            raise Exception(&#34;enumValue should be one of %s. Was %s&#34; % (str(self.values), enumValue))
        return Symbol(self.name + &#39;_&#39; + enumValue)

    def names(self, use_label=False):
        if use_label :
            base_name = self.get_label()
        else :
            base_name = self.name
        return [&#34;%s_%s&#34; % (base_name, value) for value in (self.values + [&#34;default&#34;])]

    def rand(self, alpha):
        alpha = as_np_array(alpha)
        alpha = alpha * self.sum

        # Build bins
        if not hasattr(self, &#34;_bins&#34;):
            self._bins = [0]
            for i in range(len(self.values)) :
                enumvalue = self.values[i]
                self._bins.append(self._bins[i] + self.weights[enumvalue])

        inds = np.digitize(alpha, self._bins, right=True)
        values = np.asarray(self.values)

        return values[inds - 1]

    def range(self, n):
        return self.values

    def stat_value(self, mode : FixedParamMode):
        if mode == FixedParamMode.DEFAULT :
            return self.default
        else :
            # For statistical analysis we setup enum as its weights of values,
            # This distrib is then expanded as float parameters, for better fit of the distribution
            return self.weights


def newParamDef(name, type, save=True, **kwargs):
    &#34;&#34;&#34;
        Creates a parameter and register it into a global registry and as a brightway parameter.

        Parameters
        ----------

        type : Type of the parameter (From ParamType)
        save : Boolean, persist this into Brightway2 project (True by default)
        other arguments : Refer to the documentation of BooleanDef ParamDef and EnumParam

    &#34;&#34;&#34;
    if type == ParamType.ENUM:
        param = EnumParam(name, **kwargs)
    elif type == ParamType.BOOL:
        param = BooleanDef(name, **kwargs)
    else:
        param = ParamDef(name, type=type, **kwargs)

    # Put it in global registry (in memory)
    if name in _param_registry():
        _eprint(&#34;Param %s was already defined : overriding&#34; % name)
    _param_registry()[name] = param

    # Save in brightway2 project
    if save :
        _persistParam(param)

    return param

_BOOLEAN_UNCERTAINTY_ATTRIBUTES = {
    UNCERTAINTY_TYPE: _UncertaintyType.DISCRETE,
    &#34;minimum&#34; : 0,
    &#34;maximum&#34; : 2 # upper bound + 1
}

def persistParams() :
    &#34;&#34;&#34; Persist parameters into Brightway project, as per :
     https://stats-arrays.readthedocs.io/en/latest/
    &#34;&#34;&#34;

    for name, param in _param_registry().items() :
        _persistParam(param)

def _persistParam(param):
    &#34;&#34;&#34; Persist parameter into Brightway project &#34;&#34;&#34;
    out = []

    # Common attributes for all types of params
    bwParam = dict(name=param.name, group=param.group, label=param.label, description=param.description)

    if param.type == ParamType.ENUM :
        # Enum are not real params but a set of parameters
        for value in param.values :
            enumValueParam = dict(bwParam)
            enumValueParam[&#34;name&#34;] = param.name + &#39;_&#39; + value
            enumValueParam.update(_BOOLEAN_UNCERTAINTY_ATTRIBUTES)
            # Use &#39;scale&#39; as weight for this enum value
            enumValueParam[&#39;scale&#39;] = param.weights[value]
            enumValueParam[&#39;amount&#39;] = 1 if param.default == value else 0
            out.append(enumValueParam)
    else :

        bwParam[&#34;amount&#34;] = param.default

        if param.type == ParamType.BOOL :
            # &#34;Discrete uniform&#34;
            bwParam.update(_BOOLEAN_UNCERTAINTY_ATTRIBUTES)

        elif param.type == ParamType.FLOAT :

            # Save uncertainty
            bwParam[UNCERTAINTY_TYPE] = _DistributionTypeMap[param.distrib]
            bwParam[&#34;minimum&#34;] = param.min
            bwParam[&#34;maximum&#34;] = param.max
            bwParam[&#34;loc&#34;] = param.default

            if param.distrib in [DistributionType.NORMAL, DistributionType.LOGNORMAL] :
                bwParam[&#34;scale&#34;] = param.std

            elif param.distrib == DistributionType.BETA:

                bwParam[&#34;scale&#34;] = param.std
                bwParam[&#34;loc&#34;] = param.a
                bwParam[&#34;shape&#34;] = param.b

        else :
            _eprint(&#34;Param type not supported&#34;, param.type)

        out.append(bwParam)

    bw.parameters.new_project_parameters(out)

def _loadArgs(data) :
    &#34;&#34;&#34;Load persisted data attributes into ParamDef attributes&#34;&#34;&#34;
    return {
        &#34;group&#34;: data.get(&#34;group&#34;),
        &#34;default&#34;: data.get(&#34;amount&#34;),
        &#34;label&#34;: data.get(&#34;label&#34;),
        &#34;description&#34;: data.get(&#34;description&#34;),
        &#34;min&#34;: data.get(&#34;mininum&#34;),
        &#34;max&#34;: data.get(&#34;maximum&#34;),
    }

def loadParams():
    &#34;&#34;&#34;Load parameters from Brightway database, as per : https://stats-arrays.readthedocs.io/en/latest/&#34;&#34;&#34;

    enumParams=defaultdict(lambda : dict())

    for bwParam in ProjectParameter.select():
        data = bwParam.data
        data[&#34;amount&#34;] = bwParam.amount
        name = bwParam.name

        type = data.get(UNCERTAINTY_TYPE, None)

        # print(&#34;Data for &#34;, name, data)

        # Common extra args
        args = _loadArgs(data)

        if type == _UncertaintyType.DISCRETE :
            # Boolean or enum

            if data.get(&#39;scale&#39;) is not None :
                # Enum param : group them by common prefix
                splits = name.split(&#34;_&#34;)
                enum_value = splits.pop()
                enum_name = &#34;_&#34;.join(splits)
                enumParams[enum_name][enum_value] = data
                continue

            elif data[&#34;maximum&#34;] == 2 :
                param = newBoolParam(name, save=False, **args)
            else:
                _eprint(&#34;Non boolean discrete values (max != 2) are not supported for param :&#34;, name)
                continue
        else :

            # Uncertainty type to distribution type
            args[&#34;distrib&#34;] = _DistributionTypeMapReverse[type]

            if type == _UncertaintyType.TRIANGLE :
                args[&#34;default&#34;] = data[&#34;loc&#34;]

            if type in [_UncertaintyType.NORMAL, _UncertaintyType.LOGNORMAL]:
                args[&#34;default&#34;] = data[&#34;loc&#34;]
                args[&#34;std&#34;] = data[&#34;scale&#34;]

            elif type == _UncertaintyType.BETA:
                args[&#34;default&#34;] = data[&#34;loc&#34;]
                args[&#34;std&#34;] = data[&#34;scale&#34;]
                args[&#34;a&#34;] = data[&#34;loc&#34;]
                args[&#34;b&#34;] = data[&#34;shape&#34;]

            param = newFloatParam(name, save=False, **args)

        # Save it in shared dict
        _param_registry()[bwParam.name] = param

    # Loop on EnumParams
    for param_name, param_values in enumParams.items() :
        first_enum_param = list(param_values.values())[0]
        args = _loadArgs(first_enum_param)
        del args[&#34;default&#34;]

        # Dictionary of enum values with scale as weight
        args[&#34;values&#34;] = {key : data[&#34;scale&#34;] for key, data in param_values.items()}

        # Default enum value is the one with amount=1
        defaults = list(key for key, data in param_values.items() if data.get(&#34;amount&#34;) == 1)
        if len(defaults) == 1 :
            default = defaults[0]
        else :
            default= None
            _eprint(&#34;No default enum value found for &#34;, param_name, defaults)

        param = newEnumParam(param_name, default, save=False, **args)

        # Save it in shared dict
        _param_registry()[bwParam.name] = param


def newFloatParam(name, default, **kwargs):
    &#34;&#34;&#34; Create a FLOAT parameter. See the documentation of arguments for #newParamDef().&#34;&#34;&#34;
    return newParamDef(name, ParamType.FLOAT, default=default, **kwargs)


def newBoolParam(name, default, save=True, **kwargs):
    &#34;&#34;&#34; Create a BOOL parameter. See the documentation of arguments for #newParamDef().&#34;&#34;&#34;
    return newParamDef(name, ParamType.BOOL, default=default, **kwargs)

def newEnumParam(name, default, save=True, **kwargs):
    &#34;&#34;&#34; Create a ENUM parameter. See the documentation of arguments for #newParamDef().&#34;&#34;&#34;
    return newParamDef(name, ParamType.ENUM, default=default, **kwargs)

def _variable_params(param_names=None):
    if param_names is None :
        param_names =  _param_registry().keys()
    params = {key : _param_registry()[key] for key in param_names}
    return {key: param for key, param in params.items() if param.distrib != DistributionType.FIXED}


def _fixed_params(param_names=None):
    if param_names is None :
        param_names =  _param_registry().keys()
    params = {key : _param_registry()[key] for key in param_names}
    return {key: param for key, param in params.items() if param.distrib == DistributionType.FIXED}


def _listOfDictToDictOflist(LD):
    return {k: [dic[k] for dic in LD] for k in LD[0]}


def _completeParamValues(params, required_params : List[str]=None):
    &#34;&#34;&#34;Check parameters and expand enum params.

    Returns
    -------
        Dict of param_name =&gt; float value
    &#34;&#34;&#34;

    # Add default values for required params
    if required_params :
        for param_name in required_params :
            param = _param_registry()[param_name]
            if not param_name in params :
                params[param_name] = param.default
                _eprint(&#34;Required param &#39;%s&#39; was missing, replacing by default value : %s&#34; % (param_name, str(param.default)))

    res = dict()
    for key, val in params.items():
        if key in _param_registry():
            param = _param_registry()[key]
        else:
            raise Exception(&#34;Parameter not found : %s. Valid parameters : %s&#34; % (key, list(_param_registry().keys())))

        if isinstance(val, list):
            newvals = [param.expandParams(val) for val in val]
            res.update(_listOfDictToDictOflist(newvals))
        else:
            res.update(param.expandParams(val))
    return res


def resetParams(db_name):
    &#34;&#34;&#34;Reset project and activity parameters&#34;&#34;&#34;
    _param_registry().clear()
    ProjectParameter.delete().execute()
    ActivityParameter.delete().execute()
    DatabaseParameter.delete().execute()
    Group.delete().execute()


def list_parameters():
    &#34;&#34;&#34; Print a pretty list of all defined parameters &#34;&#34;&#34;
    params = [[param.group, param.get_label(), param.default, param.min, param.max, param.std if hasattr(param, &#39;std&#39;) else None, param.distrib, param.unit] for param in
              _param_registry().values()]
    groups = list({p[0] for p in params})
    sorted_params = sorted(params, key=lambda p: groups.index(p[0]))
    return HTML((tabulate(sorted_params, tablefmt=&#34;html&#34;, headers=[&#34;Phase&#34;, &#34;param&#34;, &#34;default&#34;, &#34;min&#34;, &#34;max&#34;, &#34;std&#34;, &#34;distrib&#34;, &#34;unit&#34;])))</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="lca_algebraic.params.list_parameters"><code class="name flex">
<span>def <span class="ident">list_parameters</span></span>(<span>)</span>
</code></dt>
<dd>
<section class="desc"><p>Print a pretty list of all defined parameters</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def list_parameters():
    &#34;&#34;&#34; Print a pretty list of all defined parameters &#34;&#34;&#34;
    params = [[param.group, param.get_label(), param.default, param.min, param.max, param.std if hasattr(param, &#39;std&#39;) else None, param.distrib, param.unit] for param in
              _param_registry().values()]
    groups = list({p[0] for p in params})
    sorted_params = sorted(params, key=lambda p: groups.index(p[0]))
    return HTML((tabulate(sorted_params, tablefmt=&#34;html&#34;, headers=[&#34;Phase&#34;, &#34;param&#34;, &#34;default&#34;, &#34;min&#34;, &#34;max&#34;, &#34;std&#34;, &#34;distrib&#34;, &#34;unit&#34;])))</code></pre>
</details>
</dd>
<dt id="lca_algebraic.params.loadParams"><code class="name flex">
<span>def <span class="ident">loadParams</span></span>(<span>)</span>
</code></dt>
<dd>
<section class="desc"><p>Load parameters from Brightway database, as per : <a href="https://stats-arrays.readthedocs.io/en/latest/">https://stats-arrays.readthedocs.io/en/latest/</a></p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def loadParams():
    &#34;&#34;&#34;Load parameters from Brightway database, as per : https://stats-arrays.readthedocs.io/en/latest/&#34;&#34;&#34;

    enumParams=defaultdict(lambda : dict())

    for bwParam in ProjectParameter.select():
        data = bwParam.data
        data[&#34;amount&#34;] = bwParam.amount
        name = bwParam.name

        type = data.get(UNCERTAINTY_TYPE, None)

        # print(&#34;Data for &#34;, name, data)

        # Common extra args
        args = _loadArgs(data)

        if type == _UncertaintyType.DISCRETE :
            # Boolean or enum

            if data.get(&#39;scale&#39;) is not None :
                # Enum param : group them by common prefix
                splits = name.split(&#34;_&#34;)
                enum_value = splits.pop()
                enum_name = &#34;_&#34;.join(splits)
                enumParams[enum_name][enum_value] = data
                continue

            elif data[&#34;maximum&#34;] == 2 :
                param = newBoolParam(name, save=False, **args)
            else:
                _eprint(&#34;Non boolean discrete values (max != 2) are not supported for param :&#34;, name)
                continue
        else :

            # Uncertainty type to distribution type
            args[&#34;distrib&#34;] = _DistributionTypeMapReverse[type]

            if type == _UncertaintyType.TRIANGLE :
                args[&#34;default&#34;] = data[&#34;loc&#34;]

            if type in [_UncertaintyType.NORMAL, _UncertaintyType.LOGNORMAL]:
                args[&#34;default&#34;] = data[&#34;loc&#34;]
                args[&#34;std&#34;] = data[&#34;scale&#34;]

            elif type == _UncertaintyType.BETA:
                args[&#34;default&#34;] = data[&#34;loc&#34;]
                args[&#34;std&#34;] = data[&#34;scale&#34;]
                args[&#34;a&#34;] = data[&#34;loc&#34;]
                args[&#34;b&#34;] = data[&#34;shape&#34;]

            param = newFloatParam(name, save=False, **args)

        # Save it in shared dict
        _param_registry()[bwParam.name] = param

    # Loop on EnumParams
    for param_name, param_values in enumParams.items() :
        first_enum_param = list(param_values.values())[0]
        args = _loadArgs(first_enum_param)
        del args[&#34;default&#34;]

        # Dictionary of enum values with scale as weight
        args[&#34;values&#34;] = {key : data[&#34;scale&#34;] for key, data in param_values.items()}

        # Default enum value is the one with amount=1
        defaults = list(key for key, data in param_values.items() if data.get(&#34;amount&#34;) == 1)
        if len(defaults) == 1 :
            default = defaults[0]
        else :
            default= None
            _eprint(&#34;No default enum value found for &#34;, param_name, defaults)

        param = newEnumParam(param_name, default, save=False, **args)

        # Save it in shared dict
        _param_registry()[bwParam.name] = param</code></pre>
</details>
</dd>
<dt id="lca_algebraic.params.newBoolParam"><code class="name flex">
<span>def <span class="ident">newBoolParam</span></span>(<span>name, default, save=True, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Create a BOOL parameter. See the documentation of arguments for #newParamDef().</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def newBoolParam(name, default, save=True, **kwargs):
    &#34;&#34;&#34; Create a BOOL parameter. See the documentation of arguments for #newParamDef().&#34;&#34;&#34;
    return newParamDef(name, ParamType.BOOL, default=default, **kwargs)</code></pre>
</details>
</dd>
<dt id="lca_algebraic.params.newEnumParam"><code class="name flex">
<span>def <span class="ident">newEnumParam</span></span>(<span>name, default, save=True, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Create a ENUM parameter. See the documentation of arguments for #newParamDef().</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def newEnumParam(name, default, save=True, **kwargs):
    &#34;&#34;&#34; Create a ENUM parameter. See the documentation of arguments for #newParamDef().&#34;&#34;&#34;
    return newParamDef(name, ParamType.ENUM, default=default, **kwargs)</code></pre>
</details>
</dd>
<dt id="lca_algebraic.params.newFloatParam"><code class="name flex">
<span>def <span class="ident">newFloatParam</span></span>(<span>name, default, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Create a FLOAT parameter. See the documentation of arguments for #newParamDef().</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def newFloatParam(name, default, **kwargs):
    &#34;&#34;&#34; Create a FLOAT parameter. See the documentation of arguments for #newParamDef().&#34;&#34;&#34;
    return newParamDef(name, ParamType.FLOAT, default=default, **kwargs)</code></pre>
</details>
</dd>
<dt id="lca_algebraic.params.newParamDef"><code class="name flex">
<span>def <span class="ident">newParamDef</span></span>(<span>name, type, save=True, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Creates a parameter and register it into a global registry and as a brightway parameter.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>type</code></strong> :&ensp;<code>Type</code> of <code>the</code> <code>parameter</code> (<code>From</code> <a title="lca_algebraic.params.ParamType" href="#lca_algebraic.params.ParamType"><code>ParamType</code></a>)</dt>
<dd>&nbsp;</dd>
<dt><strong><code>save</code></strong> :&ensp;<code>Boolean</code>, <code>persist</code> <code>this</code> <code>into</code> <code>Brightway2</code> <code>project</code> (<code>True</code> <code>by</code> default)</dt>
<dd>&nbsp;</dd>
</dl>
<p>other arguments : Refer to the documentation of BooleanDef ParamDef and EnumParam</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def newParamDef(name, type, save=True, **kwargs):
    &#34;&#34;&#34;
        Creates a parameter and register it into a global registry and as a brightway parameter.

        Parameters
        ----------

        type : Type of the parameter (From ParamType)
        save : Boolean, persist this into Brightway2 project (True by default)
        other arguments : Refer to the documentation of BooleanDef ParamDef and EnumParam

    &#34;&#34;&#34;
    if type == ParamType.ENUM:
        param = EnumParam(name, **kwargs)
    elif type == ParamType.BOOL:
        param = BooleanDef(name, **kwargs)
    else:
        param = ParamDef(name, type=type, **kwargs)

    # Put it in global registry (in memory)
    if name in _param_registry():
        _eprint(&#34;Param %s was already defined : overriding&#34; % name)
    _param_registry()[name] = param

    # Save in brightway2 project
    if save :
        _persistParam(param)

    return param</code></pre>
</details>
</dd>
<dt id="lca_algebraic.params.persistParams"><code class="name flex">
<span>def <span class="ident">persistParams</span></span>(<span>)</span>
</code></dt>
<dd>
<section class="desc"><p>Persist parameters into Brightway project, as per :
<a href="https://stats-arrays.readthedocs.io/en/latest/">https://stats-arrays.readthedocs.io/en/latest/</a></p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def persistParams() :
    &#34;&#34;&#34; Persist parameters into Brightway project, as per :
     https://stats-arrays.readthedocs.io/en/latest/
    &#34;&#34;&#34;

    for name, param in _param_registry().items() :
        _persistParam(param)</code></pre>
</details>
</dd>
<dt id="lca_algebraic.params.resetParams"><code class="name flex">
<span>def <span class="ident">resetParams</span></span>(<span>db_name)</span>
</code></dt>
<dd>
<section class="desc"><p>Reset project and activity parameters</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def resetParams(db_name):
    &#34;&#34;&#34;Reset project and activity parameters&#34;&#34;&#34;
    _param_registry().clear()
    ProjectParameter.delete().execute()
    ActivityParameter.delete().execute()
    DatabaseParameter.delete().execute()
    Group.delete().execute()</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="lca_algebraic.params.BooleanDef"><code class="flex name class">
<span>class <span class="ident">BooleanDef</span></span>
<span>(</span><span>name, *karg, **kargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Parameter with discrete value 0 or 1</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BooleanDef(ParamDef):
    &#34;&#34;&#34;Parameter with discrete value 0 or 1&#34;&#34;&#34;

    def __init__(self, name, **argv):
        if not &#34;min&#34; in argv:
            argv = dict(argv, min=None, max=None)
        super(BooleanDef, self).__init__(name, ParamType.BOOL, **argv)


    def range(self, n):
        return [0, 1]

    def rand(self, alpha):
        return np.around(alpha)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="lca_algebraic.params.ParamDef" href="#lca_algebraic.params.ParamDef">ParamDef</a></li>
<li>sympy.core.symbol.Symbol</li>
<li>sympy.core.expr.AtomicExpr</li>
<li>sympy.core.basic.Atom</li>
<li>sympy.core.expr.Expr</li>
<li>sympy.logic.boolalg.Boolean</li>
<li>sympy.core.basic.Basic</li>
<li>sympy.core.evalf.EvalfMixin</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="lca_algebraic.params.ParamDef" href="#lca_algebraic.params.ParamDef">ParamDef</a></b></code>:
<ul class="hlist">
<li><code><a title="lca_algebraic.params.ParamDef.default_assumptions" href="#lca_algebraic.params.ParamDef.default_assumptions">default_assumptions</a></code></li>
<li><code><a title="lca_algebraic.params.ParamDef.rand" href="#lca_algebraic.params.ParamDef.rand">rand</a></code></li>
<li><code><a title="lca_algebraic.params.ParamDef.range" href="#lca_algebraic.params.ParamDef.range">range</a></code></li>
<li><code><a title="lca_algebraic.params.ParamDef.stat_value" href="#lca_algebraic.params.ParamDef.stat_value">stat_value</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="lca_algebraic.params.DistributionType"><code class="flex name class">
<span>class <span class="ident">DistributionType</span></span>
</code></dt>
<dd>
<section class="desc"><p>Type of statistic distribution of a parameter.
Some type of distribution requires extra parameters, in italic, to be provided in the constructor of <strong>ParamDef</strong>()</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DistributionType:
    &#34;&#34;&#34;
        Type of statistic distribution of a parameter.
        Some type of distribution requires extra parameters, in italic, to be provided in the constructor of **ParamDef**()
    &#34;&#34;&#34;

    LINEAR = &#34;linear&#34;
    &#34;&#34;&#34; Uniform distribution between *min* and *max*&#34;&#34;&#34;

    NORMAL = &#34;normal&#34;
    &#34;&#34;&#34; Normal distribution, centered on *default* value (mean), with deviation of *std* and truncated between *min* and *max*&#34;&#34;&#34;

    LOGNORMAL = &#34;lognormal&#34;
    &#34;&#34;&#34; Lognormal distribution, centered on *default* value (mean), with deviation of *std*, not truncated &#34;&#34;&#34;

    BETA = &#34;beta&#34; # requires a, b &#39;default&#39; is used as the mean. &#39;std&#39; is used as &#39;scale&#39; factor
    &#34;&#34;&#34; Beta distribution with extra params *a* and *b*, 
    using *default* value as &#39;loc&#39; (0 of beta distribution) and *std* as &#39;scale&#39; (1 of beta distribution)
    See [scipy doc](https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.beta.html#scipy.stats.beta) &#34;&#34;&#34;

    TRIANGLE = &#34;triangle&#34;
    &#34;&#34;&#34; Triangle distribution between *min* and *max* (set to zero probability), with highest probability at *default* value &#34;&#34;&#34;

    FIXED = &#34;fixed&#34;
    &#34;&#34;&#34; Fixed value, not considered as a variable input for monte carlo simulation. &#34;&#34;&#34;</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="lca_algebraic.params.DistributionType.BETA"><code class="name">var <span class="ident">BETA</span></code></dt>
<dd>
<section class="desc"><p>Beta distribution with extra params <em>a</em> and <em>b</em>,
using <em>default</em> value as 'loc' (0 of beta distribution) and <em>std</em> as 'scale' (1 of beta distribution)
See <a href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.beta.html#scipy.stats.beta">scipy doc</a></p></section>
</dd>
<dt id="lca_algebraic.params.DistributionType.FIXED"><code class="name">var <span class="ident">FIXED</span></code></dt>
<dd>
<section class="desc"><p>Fixed value, not considered as a variable input for monte carlo simulation.</p></section>
</dd>
<dt id="lca_algebraic.params.DistributionType.LINEAR"><code class="name">var <span class="ident">LINEAR</span></code></dt>
<dd>
<section class="desc"><p>Uniform distribution between <em>min</em> and <em>max</em></p></section>
</dd>
<dt id="lca_algebraic.params.DistributionType.LOGNORMAL"><code class="name">var <span class="ident">LOGNORMAL</span></code></dt>
<dd>
<section class="desc"><p>Lognormal distribution, centered on <em>default</em> value (mean), with deviation of <em>std</em>, not truncated</p></section>
</dd>
<dt id="lca_algebraic.params.DistributionType.NORMAL"><code class="name">var <span class="ident">NORMAL</span></code></dt>
<dd>
<section class="desc"><p>Normal distribution, centered on <em>default</em> value (mean), with deviation of <em>std</em> and truncated between <em>min</em> and <em>max</em></p></section>
</dd>
<dt id="lca_algebraic.params.DistributionType.TRIANGLE"><code class="name">var <span class="ident">TRIANGLE</span></code></dt>
<dd>
<section class="desc"><p>Triangle distribution between <em>min</em> and <em>max</em> (set to zero probability), with highest probability at <em>default</em> value</p></section>
</dd>
</dl>
</dd>
<dt id="lca_algebraic.params.EnumParam"><code class="flex name class">
<span>class <span class="ident">EnumParam</span></span>
<span>(</span><span>name, *karg, **kargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Enum param is a facility representing a choice / switch as many boolean parameters.
It is not itself a Sympy symbol. use #symbol("value") to access it.
Statistics weight can be attached to values by providing a dict.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EnumParam(ParamDef):
    &#34;&#34;&#34;Enum param is a facility representing a choice / switch as many boolean parameters.
    It is not itself a Sympy symbol. use #symbol(&#34;value&#34;) to access it.
    Statistics weight can be attached to values by providing a dict.
    &#34;&#34;&#34;

    def __init__(self, name, values: Union[List[str], Dict[str, float]], **argv):

        if not &#34;min&#34; in argv :
            argv = dict(argv, min=None, max=None)
        super(EnumParam, self).__init__(name, ParamType.ENUM, **argv)
        if type(values) == list :
            self.values = values
            self.weights = {key:1 for key in values}
        else :
            self.weights = values
            self.values = list(values)
        self.sum = sum(self.weights.values())

    def expandParams(self, currValue=None):

        # A dict of weights was passed
        if isinstance(currValue, dict) :
            res = { &#34;%s_%s&#34; % (self.name, key) : val / self.sum for key, val in currValue.items()}
            res[&#34;%s_default&#34; % self.name] = 0
            return res

        # Normal case
        values = self.values + [None]
        res = dict()
        for enum_val in values:
            var_name = &#34;%s_%s&#34; % (self.name, enum_val if enum_val is not None else &#34;default&#34;)
            res[var_name] = 1.0 if enum_val == currValue else 0.0
        return res

    def symbol(self, enumValue):
        &#34;&#34;&#34;Access parameter for each enum value : &lt;paramName&gt;_&lt;paramValue&gt;&#34;&#34;&#34;
        if enumValue is None:
            return Symbol(self.name + &#39;_default&#39;)
        if not enumValue in self.values:
            raise Exception(&#34;enumValue should be one of %s. Was %s&#34; % (str(self.values), enumValue))
        return Symbol(self.name + &#39;_&#39; + enumValue)

    def names(self, use_label=False):
        if use_label :
            base_name = self.get_label()
        else :
            base_name = self.name
        return [&#34;%s_%s&#34; % (base_name, value) for value in (self.values + [&#34;default&#34;])]

    def rand(self, alpha):
        alpha = as_np_array(alpha)
        alpha = alpha * self.sum

        # Build bins
        if not hasattr(self, &#34;_bins&#34;):
            self._bins = [0]
            for i in range(len(self.values)) :
                enumvalue = self.values[i]
                self._bins.append(self._bins[i] + self.weights[enumvalue])

        inds = np.digitize(alpha, self._bins, right=True)
        values = np.asarray(self.values)

        return values[inds - 1]

    def range(self, n):
        return self.values

    def stat_value(self, mode : FixedParamMode):
        if mode == FixedParamMode.DEFAULT :
            return self.default
        else :
            # For statistical analysis we setup enum as its weights of values,
            # This distrib is then expanded as float parameters, for better fit of the distribution
            return self.weights</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="lca_algebraic.params.ParamDef" href="#lca_algebraic.params.ParamDef">ParamDef</a></li>
<li>sympy.core.symbol.Symbol</li>
<li>sympy.core.expr.AtomicExpr</li>
<li>sympy.core.basic.Atom</li>
<li>sympy.core.expr.Expr</li>
<li>sympy.logic.boolalg.Boolean</li>
<li>sympy.core.basic.Basic</li>
<li>sympy.core.evalf.EvalfMixin</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="lca_algebraic.params.EnumParam.expandParams"><code class="name flex">
<span>def <span class="ident">expandParams</span></span>(<span>self, currValue=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def expandParams(self, currValue=None):

    # A dict of weights was passed
    if isinstance(currValue, dict) :
        res = { &#34;%s_%s&#34; % (self.name, key) : val / self.sum for key, val in currValue.items()}
        res[&#34;%s_default&#34; % self.name] = 0
        return res

    # Normal case
    values = self.values + [None]
    res = dict()
    for enum_val in values:
        var_name = &#34;%s_%s&#34; % (self.name, enum_val if enum_val is not None else &#34;default&#34;)
        res[var_name] = 1.0 if enum_val == currValue else 0.0
    return res</code></pre>
</details>
</dd>
<dt id="lca_algebraic.params.EnumParam.names"><code class="name flex">
<span>def <span class="ident">names</span></span>(<span>self, use_label=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def names(self, use_label=False):
    if use_label :
        base_name = self.get_label()
    else :
        base_name = self.name
    return [&#34;%s_%s&#34; % (base_name, value) for value in (self.values + [&#34;default&#34;])]</code></pre>
</details>
</dd>
<dt id="lca_algebraic.params.EnumParam.symbol"><code class="name flex">
<span>def <span class="ident">symbol</span></span>(<span>self, enumValue)</span>
</code></dt>
<dd>
<section class="desc"><p>Access parameter for each enum value : <paramName>_<paramValue></p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def symbol(self, enumValue):
    &#34;&#34;&#34;Access parameter for each enum value : &lt;paramName&gt;_&lt;paramValue&gt;&#34;&#34;&#34;
    if enumValue is None:
        return Symbol(self.name + &#39;_default&#39;)
    if not enumValue in self.values:
        raise Exception(&#34;enumValue should be one of %s. Was %s&#34; % (str(self.values), enumValue))
    return Symbol(self.name + &#39;_&#39; + enumValue)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="lca_algebraic.params.ParamDef" href="#lca_algebraic.params.ParamDef">ParamDef</a></b></code>:
<ul class="hlist">
<li><code><a title="lca_algebraic.params.ParamDef.default_assumptions" href="#lca_algebraic.params.ParamDef.default_assumptions">default_assumptions</a></code></li>
<li><code><a title="lca_algebraic.params.ParamDef.rand" href="#lca_algebraic.params.ParamDef.rand">rand</a></code></li>
<li><code><a title="lca_algebraic.params.ParamDef.range" href="#lca_algebraic.params.ParamDef.range">range</a></code></li>
<li><code><a title="lca_algebraic.params.ParamDef.stat_value" href="#lca_algebraic.params.ParamDef.stat_value">stat_value</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="lca_algebraic.params.FixedParamMode"><code class="flex name class">
<span>class <span class="ident">FixedParamMode</span></span>
</code></dt>
<dd>
<section class="desc"><p>Enum describing what value to set for fixed params</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FixedParamMode:
    &#34;&#34;&#34; Enum describing what value to set for fixed params &#34;&#34;&#34;
    DEFAULT = &#34;default&#34;
    MEDIAN = &#34;median&#34;
    MEAN = &#34;mean&#34;</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="lca_algebraic.params.FixedParamMode.DEFAULT"><code class="name">var <span class="ident">DEFAULT</span></code></dt>
<dd>
<section class="desc"><p>str(object='') -&gt; str
str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p>
<p>Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.<strong>str</strong>() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.</p></section>
</dd>
<dt id="lca_algebraic.params.FixedParamMode.MEAN"><code class="name">var <span class="ident">MEAN</span></code></dt>
<dd>
<section class="desc"><p>str(object='') -&gt; str
str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p>
<p>Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.<strong>str</strong>() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.</p></section>
</dd>
<dt id="lca_algebraic.params.FixedParamMode.MEDIAN"><code class="name">var <span class="ident">MEDIAN</span></code></dt>
<dd>
<section class="desc"><p>str(object='') -&gt; str
str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p>
<p>Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.<strong>str</strong>() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.</p></section>
</dd>
</dl>
</dd>
<dt id="lca_algebraic.params.ParamDef"><code class="flex name class">
<span>class <span class="ident">ParamDef</span></span>
<span>(</span><span>name, *karg, **kargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Generic definition of a parameter, with name, bound, type, distribution
This definition will serve both to generate brightway2 parameters and to evaluate.</p>
<p>This class inherits sympy Symbol, making it possible to use in standard arithmetic python
while keeping it as a symbolic expression (delayed evaluation).</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ParamDef(Symbol):
    &#39;&#39;&#39;Generic definition of a parameter, with name, bound, type, distribution
    This definition will serve both to generate brightway2 parameters and to evaluate.

    This class inherits sympy Symbol, making it possible to use in standard arithmetic python
    while keeping it as a symbolic expression (delayed evaluation).
    &#39;&#39;&#39;

    def __new__(cls, name, *karg, **kargs):
        return Symbol.__new__(cls, name)

    def __init__(self, name, type: str, default, min=None, max=None, unit=&#34;&#34;, description=&#34;&#34;, label=None, label_fr=None,
                 group=None, distrib=None, **kwargs):

        self.name = name
        self.type = type
        self.default = default
        self.description = description
        self.min = min
        self.max = max
        self.unit = unit
        self.label = label
        self.label_fr = label_fr
        self.group = group
        self.distrib = distrib

        # Cleanup distribution in case of overriding already existing param (reused because of inheritance of Symbol)
        if hasattr(self, &#34;_distrib&#34;) :
            del self._distrib

        if not distrib :
            if type == ParamType.FLOAT and self.min is None:
                self.distrib = DistributionType.FIXED
            else:
                self.distrib = DistributionType.LINEAR

        elif distrib in [DistributionType.NORMAL, DistributionType.LOGNORMAL] :
            if not &#39;std&#39; in kwargs:
                raise Exception(&#34;Standard deviation is mandatory for normal / lognormal distribution&#34;)
            self.std = kwargs[&#39;std&#39;]

            if distrib == DistributionType.LOGNORMAL and self.min is not None :
                _eprint(&#34;Warning : LogNormal does not support min/max boundaries for parameter : &#34;, self.name)

        elif distrib == DistributionType.BETA :
            if not &#39;a&#39; in kwargs or not &#39;b&#39; in kwargs or not &#39;std&#39; in kwargs :
                raise Exception(&#34;Beta distribution requires params &#39;a&#39; &#39;b&#39; and &#39;std&#39; (used as scale)&#34;)
            self.a = kwargs[&#39;a&#39;]
            self.b = kwargs[&#39;b&#39;]
            self.std = kwargs[&#39;std&#39;]

    def stat_value(self, mode : FixedParamMode):
        &#34;&#34;&#34;Method used to compute fixed statistic value to use for fixed variables&#34;&#34;&#34;
        if mode == FixedParamMode.DEFAULT :
            return self.default
        else :
            # Compute statistical value for replacement
            rnd = np.random.rand(1000)
            x = self.rand(rnd)

            if mode == FixedParamMode.MEAN :
                return np.mean(x)
            elif mode == FixedParamMode.MEDIAN :
                return np.median(x)
            else :
                raise Exception(&#34;Unkown mode &#34; + mode)


    def get_label(self):
        if lca_algebraic.base_utils.LANG == &#34;fr &#34; and self.label_fr is not None :
            return self.label_fr
        elif self.label is not None:
            return self.label
        else:
            return self.name.replace(&#34;_&#34;, &#34; &#34;)

    def range(self, n):
        &#39;&#39;&#39;Used for parametric analysis&#39;&#39;&#39;
        step = (self.max - self.min) / (n - 1)
        return list(i * step + self.min for i in range(0, n))

    def rand(self, alpha):
        &#34;&#34;&#34;Transforms a random number between 0 and 1 to valid value according to the distribution of probability of the parameter&#34;&#34;&#34;

        if self.distrib == DistributionType.FIXED :
            return self.default
        
        elif self.distrib == DistributionType.LINEAR:
            return self.min + alpha * (self.max - self.min)

        else :
            if not hasattr(self, &#34;_distrib&#34;):

                if self.distrib == DistributionType.TRIANGLE:
                    scale = self.max - self.min
                    c = (self.default - self.min) / scale
                    self._distrib = triang(c, loc=self.min, scale=scale)

                elif self.distrib == DistributionType.NORMAL:

                    if self.min :
                        # Truncated normal
                        self._distrib = truncnorm(
                            (self.min - self.default) / self.std,
                            (self.max - self.min) / self.std,
                            loc=self.default,
                            scale=self.std)
                    else :
                        # Normal
                        self._distrib = norm(
                            loc=self.default,
                            scale=self.std)

                elif self.distrib == DistributionType.BETA:
                    self._distrib = beta(
                        self.a,
                        self.b,
                        loc=self.default,
                        scale=self.std)

                else:
                    raise Exception(&#34;Unkown distribution type &#34; + self.distrib)


            return self._distrib.ppf(alpha)



    # Expand parameter (useful for enum param)
    def expandParams(self, value=None) -&gt; Dict[str, float]:
        if value == None:
            value = self.default
        return {self.name: value}

    # Useful for enum param, having several names
    def names(self, use_label=False):
        if use_label :
            return [self.get_label()]
        else:
            return [self.name]

    def __repr__(self):
        return self.name</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>sympy.core.symbol.Symbol</li>
<li>sympy.core.expr.AtomicExpr</li>
<li>sympy.core.basic.Atom</li>
<li>sympy.core.expr.Expr</li>
<li>sympy.logic.boolalg.Boolean</li>
<li>sympy.core.basic.Basic</li>
<li>sympy.core.evalf.EvalfMixin</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="lca_algebraic.params.BooleanDef" href="#lca_algebraic.params.BooleanDef">BooleanDef</a></li>
<li><a title="lca_algebraic.params.EnumParam" href="#lca_algebraic.params.EnumParam">EnumParam</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="lca_algebraic.params.ParamDef.default_assumptions"><code class="name">var <span class="ident">default_assumptions</span></code></dt>
<dd>
<section class="desc"><p>A FactKB specialised for the built-in rules</p>
<p>This is the only kind of FactKB that Basic objects should use.</p></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="lca_algebraic.params.ParamDef.expandParams"><code class="name flex">
<span>def <span class="ident">expandParams</span></span>(<span>self, value=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def expandParams(self, value=None) -&gt; Dict[str, float]:
    if value == None:
        value = self.default
    return {self.name: value}</code></pre>
</details>
</dd>
<dt id="lca_algebraic.params.ParamDef.get_label"><code class="name flex">
<span>def <span class="ident">get_label</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_label(self):
    if lca_algebraic.base_utils.LANG == &#34;fr &#34; and self.label_fr is not None :
        return self.label_fr
    elif self.label is not None:
        return self.label
    else:
        return self.name.replace(&#34;_&#34;, &#34; &#34;)</code></pre>
</details>
</dd>
<dt id="lca_algebraic.params.ParamDef.names"><code class="name flex">
<span>def <span class="ident">names</span></span>(<span>self, use_label=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def names(self, use_label=False):
    if use_label :
        return [self.get_label()]
    else:
        return [self.name]</code></pre>
</details>
</dd>
<dt id="lca_algebraic.params.ParamDef.rand"><code class="name flex">
<span>def <span class="ident">rand</span></span>(<span>self, alpha)</span>
</code></dt>
<dd>
<section class="desc"><p>Transforms a random number between 0 and 1 to valid value according to the distribution of probability of the parameter</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rand(self, alpha):
    &#34;&#34;&#34;Transforms a random number between 0 and 1 to valid value according to the distribution of probability of the parameter&#34;&#34;&#34;

    if self.distrib == DistributionType.FIXED :
        return self.default
    
    elif self.distrib == DistributionType.LINEAR:
        return self.min + alpha * (self.max - self.min)

    else :
        if not hasattr(self, &#34;_distrib&#34;):

            if self.distrib == DistributionType.TRIANGLE:
                scale = self.max - self.min
                c = (self.default - self.min) / scale
                self._distrib = triang(c, loc=self.min, scale=scale)

            elif self.distrib == DistributionType.NORMAL:

                if self.min :
                    # Truncated normal
                    self._distrib = truncnorm(
                        (self.min - self.default) / self.std,
                        (self.max - self.min) / self.std,
                        loc=self.default,
                        scale=self.std)
                else :
                    # Normal
                    self._distrib = norm(
                        loc=self.default,
                        scale=self.std)

            elif self.distrib == DistributionType.BETA:
                self._distrib = beta(
                    self.a,
                    self.b,
                    loc=self.default,
                    scale=self.std)

            else:
                raise Exception(&#34;Unkown distribution type &#34; + self.distrib)


        return self._distrib.ppf(alpha)</code></pre>
</details>
</dd>
<dt id="lca_algebraic.params.ParamDef.range"><code class="name flex">
<span>def <span class="ident">range</span></span>(<span>self, n)</span>
</code></dt>
<dd>
<section class="desc"><p>Used for parametric analysis</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def range(self, n):
    &#39;&#39;&#39;Used for parametric analysis&#39;&#39;&#39;
    step = (self.max - self.min) / (n - 1)
    return list(i * step + self.min for i in range(0, n))</code></pre>
</details>
</dd>
<dt id="lca_algebraic.params.ParamDef.stat_value"><code class="name flex">
<span>def <span class="ident">stat_value</span></span>(<span>self, mode)</span>
</code></dt>
<dd>
<section class="desc"><p>Method used to compute fixed statistic value to use for fixed variables</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stat_value(self, mode : FixedParamMode):
    &#34;&#34;&#34;Method used to compute fixed statistic value to use for fixed variables&#34;&#34;&#34;
    if mode == FixedParamMode.DEFAULT :
        return self.default
    else :
        # Compute statistical value for replacement
        rnd = np.random.rand(1000)
        x = self.rand(rnd)

        if mode == FixedParamMode.MEAN :
            return np.mean(x)
        elif mode == FixedParamMode.MEDIAN :
            return np.median(x)
        else :
            raise Exception(&#34;Unkown mode &#34; + mode)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="lca_algebraic.params.ParamType"><code class="flex name class">
<span>class <span class="ident">ParamType</span></span>
</code></dt>
<dd>
<section class="desc"><p>Type of parameters</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ParamType:
    &#34;&#34;&#34;Type of parameters&#34;&#34;&#34;

    ENUM = &#34;enum&#34;

    BOOL = &#34;bool&#34;

    FLOAT = &#34;float&#34;</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="lca_algebraic.params.ParamType.BOOL"><code class="name">var <span class="ident">BOOL</span></code></dt>
<dd>
<section class="desc"><p>str(object='') -&gt; str
str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p>
<p>Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.<strong>str</strong>() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.</p></section>
</dd>
<dt id="lca_algebraic.params.ParamType.ENUM"><code class="name">var <span class="ident">ENUM</span></code></dt>
<dd>
<section class="desc"><p>str(object='') -&gt; str
str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p>
<p>Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.<strong>str</strong>() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.</p></section>
</dd>
<dt id="lca_algebraic.params.ParamType.FLOAT"><code class="name">var <span class="ident">FLOAT</span></code></dt>
<dd>
<section class="desc"><p>str(object='') -&gt; str
str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p>
<p>Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.<strong>str</strong>() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.</p></section>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="lca_algebraic" href="index.html">lca_algebraic</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="lca_algebraic.params.list_parameters" href="#lca_algebraic.params.list_parameters">list_parameters</a></code></li>
<li><code><a title="lca_algebraic.params.loadParams" href="#lca_algebraic.params.loadParams">loadParams</a></code></li>
<li><code><a title="lca_algebraic.params.newBoolParam" href="#lca_algebraic.params.newBoolParam">newBoolParam</a></code></li>
<li><code><a title="lca_algebraic.params.newEnumParam" href="#lca_algebraic.params.newEnumParam">newEnumParam</a></code></li>
<li><code><a title="lca_algebraic.params.newFloatParam" href="#lca_algebraic.params.newFloatParam">newFloatParam</a></code></li>
<li><code><a title="lca_algebraic.params.newParamDef" href="#lca_algebraic.params.newParamDef">newParamDef</a></code></li>
<li><code><a title="lca_algebraic.params.persistParams" href="#lca_algebraic.params.persistParams">persistParams</a></code></li>
<li><code><a title="lca_algebraic.params.resetParams" href="#lca_algebraic.params.resetParams">resetParams</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="lca_algebraic.params.BooleanDef" href="#lca_algebraic.params.BooleanDef">BooleanDef</a></code></h4>
</li>
<li>
<h4><code><a title="lca_algebraic.params.DistributionType" href="#lca_algebraic.params.DistributionType">DistributionType</a></code></h4>
<ul class="two-column">
<li><code><a title="lca_algebraic.params.DistributionType.BETA" href="#lca_algebraic.params.DistributionType.BETA">BETA</a></code></li>
<li><code><a title="lca_algebraic.params.DistributionType.FIXED" href="#lca_algebraic.params.DistributionType.FIXED">FIXED</a></code></li>
<li><code><a title="lca_algebraic.params.DistributionType.LINEAR" href="#lca_algebraic.params.DistributionType.LINEAR">LINEAR</a></code></li>
<li><code><a title="lca_algebraic.params.DistributionType.LOGNORMAL" href="#lca_algebraic.params.DistributionType.LOGNORMAL">LOGNORMAL</a></code></li>
<li><code><a title="lca_algebraic.params.DistributionType.NORMAL" href="#lca_algebraic.params.DistributionType.NORMAL">NORMAL</a></code></li>
<li><code><a title="lca_algebraic.params.DistributionType.TRIANGLE" href="#lca_algebraic.params.DistributionType.TRIANGLE">TRIANGLE</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="lca_algebraic.params.EnumParam" href="#lca_algebraic.params.EnumParam">EnumParam</a></code></h4>
<ul class="">
<li><code><a title="lca_algebraic.params.EnumParam.expandParams" href="#lca_algebraic.params.EnumParam.expandParams">expandParams</a></code></li>
<li><code><a title="lca_algebraic.params.EnumParam.names" href="#lca_algebraic.params.EnumParam.names">names</a></code></li>
<li><code><a title="lca_algebraic.params.EnumParam.symbol" href="#lca_algebraic.params.EnumParam.symbol">symbol</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="lca_algebraic.params.FixedParamMode" href="#lca_algebraic.params.FixedParamMode">FixedParamMode</a></code></h4>
<ul class="">
<li><code><a title="lca_algebraic.params.FixedParamMode.DEFAULT" href="#lca_algebraic.params.FixedParamMode.DEFAULT">DEFAULT</a></code></li>
<li><code><a title="lca_algebraic.params.FixedParamMode.MEAN" href="#lca_algebraic.params.FixedParamMode.MEAN">MEAN</a></code></li>
<li><code><a title="lca_algebraic.params.FixedParamMode.MEDIAN" href="#lca_algebraic.params.FixedParamMode.MEDIAN">MEDIAN</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="lca_algebraic.params.ParamDef" href="#lca_algebraic.params.ParamDef">ParamDef</a></code></h4>
<ul class="two-column">
<li><code><a title="lca_algebraic.params.ParamDef.default_assumptions" href="#lca_algebraic.params.ParamDef.default_assumptions">default_assumptions</a></code></li>
<li><code><a title="lca_algebraic.params.ParamDef.expandParams" href="#lca_algebraic.params.ParamDef.expandParams">expandParams</a></code></li>
<li><code><a title="lca_algebraic.params.ParamDef.get_label" href="#lca_algebraic.params.ParamDef.get_label">get_label</a></code></li>
<li><code><a title="lca_algebraic.params.ParamDef.names" href="#lca_algebraic.params.ParamDef.names">names</a></code></li>
<li><code><a title="lca_algebraic.params.ParamDef.rand" href="#lca_algebraic.params.ParamDef.rand">rand</a></code></li>
<li><code><a title="lca_algebraic.params.ParamDef.range" href="#lca_algebraic.params.ParamDef.range">range</a></code></li>
<li><code><a title="lca_algebraic.params.ParamDef.stat_value" href="#lca_algebraic.params.ParamDef.stat_value">stat_value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="lca_algebraic.params.ParamType" href="#lca_algebraic.params.ParamType">ParamType</a></code></h4>
<ul class="">
<li><code><a title="lca_algebraic.params.ParamType.BOOL" href="#lca_algebraic.params.ParamType.BOOL">BOOL</a></code></li>
<li><code><a title="lca_algebraic.params.ParamType.ENUM" href="#lca_algebraic.params.ParamType.ENUM">ENUM</a></code></li>
<li><code><a title="lca_algebraic.params.ParamType.FLOAT" href="#lca_algebraic.params.ParamType.FLOAT">FLOAT</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.4</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>