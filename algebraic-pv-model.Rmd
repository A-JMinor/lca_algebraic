---
jupyter:
  jupytext:
    formats: ipynb,Rmd
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.2'
      jupytext_version: 1.3.2
  kernelspec:
    display_name: Python 3
    language: python
    name: python3
---

# Imports

Besides external libraries, we import several function from the local file : `utils.py`

```{python}
# %load_ext autoreload
# %autoreload 2
import pandas as pd
import time
import matplotlib.pyplot as plt
import numpy as np
import brightway2 as bw

# Custom utils defined for inter-acv
from utils import *
from expression import *

pd.options.display.max_rows = 100
```

# Init brightway2 and databases

```{python}
# Setup bw2
bw.projects.set_current('B_Publication')
bw.bw2setup()

# Import Ecoinvent DB (if not already done)
# Update the PATH to suit your installation
#resetDb(ECOINVENT_DB_NAME)
importDb(ECOINVENT_DB_NAME, './ecoinvent 3.4_cutoff_ecoSpold02/datasets')

# We use a separate DB for defining our model, reset it beforehand
resetDb(ACV_DB_NAME)

# Parameters are stored at project level : reset them
resetParams()
```

#  Parameters of the model

We define the parameters of the model.

The numeric parametes are instances of sympy' 'Symbol' . Thus, any python arithmetic expression composed of parameters will not result into direct evaluation, but the creation of a symbolic formula that can be manipulated later.


# Select the impacts to consider

```{python}
# List of impacts to consider
impacts = [m for m in bw.methods if 'ILCD 1.0.8 2016' in str(m) and 'no LT' in str(m)]
```

# Electricity mix


```{python}
# Switch parameter for electricity mix
elec_switch = newParamDef(
    'elec_switch', 
    ParamType.ENUM, 
    values=["us", "eu", "row", "cn", "fr" ], 
    default=None, 
    description="Switch on electricty mix")
```

```{python}
ELEC_NAME = 'market for electricity, medium voltage'
ELEC_GROUP_NAME = 'market group for electricity, medium voltage'
elec_us = findTechAct(ELEC_GROUP_NAME, "US")
elec_eu = findTechAct(ELEC_GROUP_NAME, "ENTSO-E")
elec_fr = findTechAct(ELEC_NAME, "FR")
elec_cn = findTechAct(ELEC_NAME, "CN-CSG")
elec_row = findTechAct(ELEC_NAME, "RoW")
```

```{python}
# Virtual activity corresponding to switch upon elec mixes
elec = newSwitchAct("elec", elec_switch, {
    "us" : elec_us,
    "eu" : elec_eu,
    "fr" : elec_fr,
    "cn" : elec_cn,
    "row" : elec_row})
```

```{python}
multiLCA([elec_us, elec_eu, elec_row, elec_cn, elec_fr], impacts)
```

# Aluminium 

```{python}
alu=findTechAct('aluminium alloy production, AlMg3', 'RER')
alu_scrap=findTechAct('aluminium scrap, new, Recycled Content cut-off')
alu_cast_amount = alu.getAmount('aluminium, cast alloy')
```

```{python}
share_recycled_aluminium = newFloatParam(
    'share_recycled_aluminium',  
    default=0.3, 
    description="Share of reycled aluminium")
```

```{python}
alu_adjusted = copyActivity(alu, "Alu adjusted")

alu_adjusted.updateExchanges( 
    {"aluminium, cast alloy": alu_cast_amount * (1 - share_recycled_aluminium)}) 
alu_adjusted.addExchanges( 
    {alu_scrap : alu_cast_amount * share_recycled_aluminium} )

alu_adjusted.substituteWithDefault(
    'electricity, high voltage, aluminium industry', 
    elec)
```

```{python}
printAct(alu, alu_adjusted, share_recycled_aluminium=0.3, elec_switch=None)
multiLCA([alu, alu_adjusted], impacts, share_recycled_aluminium=0.3, elec_switch=None)
```

# Mounting system

```{python}
# 2 Mounting system are identified (Aluminium and stainless steel based)
ground_system = findTechAct('photovoltaic mounting system production, for 570kWp open ground module')
roof_system = findTechAct('photovoltaic mounting system production, for slanted-roof installation', 'RER')
```

```{python}
# Build a modified roof system with recycled output
roof_alu_amount = roof_system.getAmount('aluminium, wrought alloy')
roof_steel_amount = roof_system.getAmount('steel, low-alloyed, hot rolled')
scrap_steel_market = findTechAct('market for scrap steel', 'Europe without Switzerland')
scrap_alu_market= findTechAct('market for scrap aluminium', 'Europe without Switzerland')


roof_system_modified = copyActivity(roof_system, "Roof system recycled")

# Add scrap alu and steel output 
roof_system_modified.addExchanges({
    scrap_alu_market : - roof_alu_amount,
    scrap_steel_market : - roof_steel_amount})
```

```{python}
# Replace alu with recycled alu
ground_system_modified = copyActivity(ground_system, "Ground system modified")

roof_system_modified.updateExchanges(
    {'aluminium, wrought alloy' : dict(input=alu_adjusted)})
ground_system_modified.updateExchanges(
    {'aluminium, wrought alloy' : dict(input=alu_adjusted)})
```

```{python}
printAct(ground_system, ground_system_modified)
printAct(roof_system, roof_system_modified)
```

```{python}
multiLCA(
    [roof_system_modified, ground_system_modified], 
    impacts, 
    elec_switch=None, 
    share_recycled_aluminium=0.3)
```


# Electrical installation

```{python}
P = newFloatParam("P", 10, description="power Kwc")

electrical_installation_3kW = findTechAct('photovoltaics, electric installation for 3kWp module, at building', 'RoW')

# 3kW system weights 33 kg, 570kW system weight 1570kg
# We compute a formula computing the number of unit of 3kw electrical installation for given power, based on weigth
unit_3kW_equiv = interpolate(P, 3, 570, 1, 1570/33)
```

# Inverter

```{python}
inverter_500kW = findTechAct('inverter production, 500kW', 'RER')
inverter_2500W = findTechAct('inverter production, 2.5kW', 'RER')
weigth_2500W = 18.5
weigth_500kW = 3000
printAct(inverter_500kW, inverter_2500W)
```

```{python}
# Generate a dataset for 1kG of inverter, based on the power
inverter_per_kg = newInterpolatedAct(
    "Inverter production, P kW per kg",
    inverter_2500W, 
    inverter_500kW,
    2.5, # FIXME : Wrong in original model should be 2.5 ?
    500,
    P,
    1 / weigth_2500W,
    1 / weigth_500kW, 
    unit="kilogram")
```

```{python}
# Add recycling 
recycling_rate = newFloatParam("recycling_rate", 0.3, description="Recycling rate for inverter")

scrap_alu = findTechAct("market for scrap aluminium", "Europe without Switzerland")
scrap_steel = findTechAct("market for scrap steel", "Europe without Switzerland")
scrap_coper = findTechAct("market for scrap copper", "Europe without Switzerland")
scrap_electronic = findTechAct("market for electronics scrap")

amount_alu = inverter_per_kg.getAmount('aluminium, cast alloy')
amount_copper = inverter_per_kg.getAmount('copper')
amount_steel = inverter_per_kg.getAmount('steel, low-alloyed, hot rolled')
amount_electronic = inverter_per_kg.getAmount(
    ['capacitor*', 'diode*', 'integrated circuit*', 'printed wiring*', 'resistor*', 'transitor*'], 
    sum=True)

inverter_per_kg.addExchanges({
    scrap_alu : amount_alu * recycling_rate,
    scrap_coper : amount_copper * recycling_rate,
    scrap_electronic : amount_electronic * recycling_rate,
    scrap_steel : amount_steel * recycling_rate})
```

```{python}
printAct(inverter_per_kg, P=500, recycling_rate=0.3)
```

# Metalization paste

This section replaces all the silver used in the metallization paste by copper. However, the adequate replacement will be accomplished in the following sections according to the conductivity.


```{python}
# Find root activities
metal_paste = findTechAct("metallization paste production, back side", "RER")
copper = findTechAct('copper production, primary', "RoW")

# Copy and update mateal paste with copper
metal_paste_copper = copyActivity(metal_paste, 'metal paste, copper')
updateExchanges(metal_paste_copper, {'silver' : dict(input=copper, name="copper")})
```

```{python}
printAct(metal_paste_copper)
```

# Silicon solar grade manufacturing

In this section, the main modification implemented is the change of the electrcity intensity used for the manufacturing of the solar grade.

```{python}
silicon_elec_intensity = newFloatParam(
    "silicon_elec_intensity", 
    40, 
    description="electricity used for solar processing and casting ")
```

```{python}
silicon = findTechAct('silicon production, solar grade, modified Siemens process', 'RER')
silicon_adjusted = copyActivity(silicon, "Silicon adjusted")

# Delete hydroelectricy, for not counting it twice
silicon_adjusted.updateExchanges({'electricity, high voltage#RoW' : None})

# Replace elec with elec switch, and update amount as a parameter
silicon_adjusted.substituteWithDefault('electricity, high voltage#RER', elec, silicon_elec_intensity)
```

```{python}
printAct(silicon_adjusted)
```

```{python}
multiLCAAlgebric([silicon, silicon_adjusted], impacts, elec_switch=None, silicon_elec_intensity=40)
```

# Casting Dataset 

Let's remove the use of silicon electronics grade (it was significant when the world silicon production was relatively low, nowadays this volume can be neglected compared to the level reached by the solar industry).
Let's remove also silicon solar grade as it is directly call by the wafer dataset and also electricity that is already accounted in the amount of electricity for solar grade manufacturing.
As a consequence, only chemicals, the factory and ceramic will be left and this dataset will complement the silicon solar grade dataset and both will be called for the wafer dataset.

```{python}
silicon_casting = findTechAct('silicon production, multi-Si, casted', 'RoW')
```

```{python}
silicon_casting_adjusted = copyActivity(silicon_casting, 'silicon casting updated')
```

```{python}
silicon_casting_adjusted.updateExchanges({
    'silicon,*' : None,
    'electricity, medium voltage*' : None})
```

```{python}
printAct(silicon_casting, silicon_casting_adjusted)
```

# Wafer manufacturing

In this section, some modifications were integrated by creating new datasets related mainly to the emerging practices in the cutting processes: 6 new datasets were created to serve this purpose.
On one hand, 2 of them (SiC recycled and TEG recycled) are related to the advancements of the traditional cutting process (loose abrasive slurry). The advancement of their recycling has resulted in the use of their recycled material recovered.
On another hand, the 4 new datasets are created to represent 1 meter of wire used in the emerging technology: the diamond wiring.


## Cutting Process

### SiC, Recycled

```{python}
silicon_carbide = findTechAct('silicon carbide production', 'RER')
silicon_carbide_adjusted = copyActivity(silicon_carbide, 'Silicon carbid adjusted', withExchanges=False)
silicon_carbide_adjusted.addExchanges({
    findTechAct('market group for electricity, medium voltage', 'ENTSO-E') : 0.78571,
    findTechAct('market for transport, freight, lorry, unspecified', 'GLO') : 0.2625,
    findTechAct('market for silicone factory') : 1e-11,
    findBioAct('Heat, waste', categories=['air']) : 2.8286,
    findTechAct('market for waste, from silicon wafer production, inorganic') : -0.042857,
    findTechAct('treatment of spent antifreezer liquid, hazardous waste incineration', 'CH') : -0.071429,
    findTechAct('market for sludge, pig iron production', 'Europe without Switzerland') : -0.13571,
})
```

```{python}
printAct(silicon_carbide, silicon_carbide_adjusted)
```

```{python}
multiLCAAlgebric([silicon_carbide, silicon_carbide_adjusted], impacts)
```

### TEG, Recycled

```{python}
teg = findTechAct(code='85c5a45f05a8e40c76aebf8a4dbdc3ad')
teg_recycled = copyActivity(teg, "TEG recycled", withExchanges=False)

addExchanges(teg_recycled, {
    findTechAct('market group for electricity, medium voltage', 'ENTSO-E') : 0.78571,
    findTechAct('market for transport, freight, lorry, unspecified', 'GLO') : 0.2625,
```

```{python}

```

```{python}

```
